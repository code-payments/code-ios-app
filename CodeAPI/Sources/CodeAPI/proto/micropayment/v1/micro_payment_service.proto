syntax = "proto3";

package code.micropayment.v1;

option go_package = "github.com/code-wallet/code-api/genproto/micropayment/v1;micropayment";
option java_package = "com.codeinc.gen.micropayment.v1";
option objc_class_prefix = "APBMicroPaymentV1";

import "common/v1/model.proto";
import "validate/validate.proto";

service MicroPayment {
    // GetStatus gets basic micro payment status
    rpc GetStatus(GetStatusRequest) returns (GetStatusResponse);

    // RegisterWebhook registers a webhook for a micro payment
    //
    // todo: Once Kik codes can encode the entire payment request details, we can
    //       remove the messaging service component and have a Create RPC that
    //       reserves the intent ID with payment details, plus registers the webhook
    //       at the same time. Until that's possible, we're stuck with two RPC calls.
    rpc RegisterWebhook(RegisterWebhookRequest) returns (RegisterWebhookResponse);

    // Codify adds a trial micro paywall to any url
    rpc Codify(CodifyRequest) returns (CodifyResponse);

    // GetPathMetadata gets codified website metadata for a given path
    //
    // Important Note: This RPC's current implementation is insecure and
    // it's sole design is to enable a micro payment PoC.
    rpc GetPathMetadata(GetPathMetadataRequest) returns (GetPathMetadataResponse);
}

message GetStatusRequest {
    common.v1.IntentId intent_id = 1 [(validate.rules).message.required = true];
}

message GetStatusResponse {
    bool exists = 1;

    bool code_scanned = 2;

    bool intent_submitted = 3;
}

message RegisterWebhookRequest {
    common.v1.IntentId intent_id = 1 [(validate.rules).message.required = true];

    string url = 2 [(validate.rules).string = {
        min_len: 1
        max_len: 1024

        prefix: "http"
        uri: true
    }];
}

message RegisterWebhookResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        ALREADY_REGISTERED = 1;
        PAYMENT_REQUEST_NOT_FOUND = 2;
        INTENT_EXISTS = 3;
        INVALID_URL = 4;
    }
}

message CodifyRequest {
    // The URL to codify
    string url = 1 [(validate.rules).string = {
        min_len: 1,
        max_len: 512,

        prefix: "http"
        uri: true
    }];

    // ISO 4217 alpha-3 currency code the payment should be made in
    string currency = 2 [(validate.rules).string = { pattern: "^[a-z]{3}$" }];

    // The amount that should be paid in the native currency
    double native_amount = 3 [(validate.rules).double.gt = 0];

    // The verified owner account public key
    common.v1.SolanaAccountId owner_account = 4 [(validate.rules).message.required = true];

    // The primary account public key where payment will be sent
    common.v1.SolanaAccountId primary_account = 5 [(validate.rules).message.required = true];;

    // The signature is of serialize(CodifyRequest) without this field set using the
    // private key of the owner account. This provides an authentication mechanism
    // to the RPC and can be used to validate payment details.
    common.v1.Signature signature = 6 [(validate.rules).message.required = true];
}

message CodifyResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        INVALID_URL = 1;
        INVALID_ACCOUNT = 2;
        UNSUPPORTED_CURRENCY = 3;
        NATIVE_AMOUNT_EXCEEDS_LIMIT = 4;
    }

    string codified_url = 2 [(validate.rules).string.max_len = 64 ];
}

message GetPathMetadataRequest {
    string path = 1 [(validate.rules).string = { pattern: "^[0-9a-zA-Z]{1,8}$" }];
}

message GetPathMetadataResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        NOT_FOUND = 1;
    }

    // The account where the payment should be sent to
    common.v1.SolanaAccountId destination = 2;
    
    // ISO 4217 alpha-3 currency code the payment should be made in
    string currency = 3;

    // The amount that should be paid in the native currency
    double native_amount = 4;

    // The URL to redirect upon successful payment
    string redirct_url = 5;
}
