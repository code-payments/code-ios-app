// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction/v2/transaction_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Code_Transaction_V2_AirdropType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Reward for giving someone else their first Kin
  case giveFirstKin // = 1

  /// Airdrop for getting a user started with first Kin balance
  case getFirstKin // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .giveFirstKin
    case 2: self = .getFirstKin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .giveFirstKin: return 1
    case .getFirstKin: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Transaction_V2_AirdropType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_AirdropType] = [
    .unknown,
    .giveFirstKin,
    .getFirstKin,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_SubmitIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request? = nil

  public var submitActions: Code_Transaction_V2_SubmitIntentRequest.SubmitActions {
    get {
      if case .submitActions(let v)? = request {return v}
      return Code_Transaction_V2_SubmitIntentRequest.SubmitActions()
    }
    set {request = .submitActions(newValue)}
  }

  public var submitSignatures: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures {
    get {
      if case .submitSignatures(let v)? = request {return v}
      return Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures()
    }
    set {request = .submitSignatures(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case submitActions(Code_Transaction_V2_SubmitIntentRequest.SubmitActions)
    case submitSignatures(Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request, rhs: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.submitActions, .submitActions): return {
        guard case .submitActions(let l) = lhs, case .submitActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.submitSignatures, .submitSignatures): return {
        guard case .submitSignatures(let l) = lhs, case .submitSignatures(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct SubmitActions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The globally unique client generated intent ID. Use the original intent
    /// ID when operating on actions that mutate the intent.
    public var id: Code_Common_V1_IntentId {
      get {return _id ?? Code_Common_V1_IntentId()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// The verified owner account public key
    public var owner: Code_Common_V1_SolanaAccountId {
      get {return _owner ?? Code_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// Additional metadata that describes the high-level intention
    public var metadata: Code_Transaction_V2_Metadata {
      get {return _metadata ?? Code_Transaction_V2_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    /// The set of all ordered actions required to fulfill the intent
    public var actions: [Code_Transaction_V2_Action] = []

    /// The signature is of serialize(SubmitActions) without this field set using the
    /// private key of the owner account. This provides an authentication mechanism
    /// to the RPC.
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    /// Device token for antispam measures against fake devices
    public var deviceToken: Code_Common_V1_DeviceToken {
      get {return _deviceToken ?? Code_Common_V1_DeviceToken()}
      set {_deviceToken = newValue}
    }
    /// Returns true if `deviceToken` has been explicitly set.
    public var hasDeviceToken: Bool {return self._deviceToken != nil}
    /// Clears the value of `deviceToken`. Subsequent reads from it will return its default value.
    public mutating func clearDeviceToken() {self._deviceToken = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Code_Common_V1_IntentId? = nil
    fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _metadata: Code_Transaction_V2_Metadata? = nil
    fileprivate var _signature: Code_Common_V1_Signature? = nil
    fileprivate var _deviceToken: Code_Common_V1_DeviceToken? = nil
  }

  public struct SubmitSignatures {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all signatures for each transaction requiring signature from the
    /// authority accounts.
    public var signatures: [Code_Common_V1_Signature] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Code_Transaction_V2_SubmitIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response? = nil

  public var serverParameters: Code_Transaction_V2_SubmitIntentResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Code_Transaction_V2_SubmitIntentResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Code_Transaction_V2_SubmitIntentResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case serverParameters(Code_Transaction_V2_SubmitIntentResponse.ServerParameters)
    case success(Code_Transaction_V2_SubmitIntentResponse.Success)
    case error(Code_Transaction_V2_SubmitIntentResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response, rhs: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serverParameters, .serverParameters): return {
        guard case .serverParameters(let l) = lhs, case .serverParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ServerParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all server paremeters required to fill missing transaction
    /// details. Server guarantees to provide a message for each client action
    /// in an order consistent with the received action list. 
    public var serverParameters: [Code_Transaction_V2_ServerParameter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SubmitIntentResponse.Success.Code = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The intent was successfully created and is now scheduled.
      case ok // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .ok
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ok
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .ok: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SubmitIntentResponse.Error.Code = .denied

    public var errorDetails: [Code_Transaction_V2_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// The intent is invalid.
      case invalidIntent // = 1

      /// There is an issue with provided signatures.
      case signatureError // = 2

      /// Server detected client has stale state.
      case staleState // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 1: self = .invalidIntent
        case 2: self = .signatureError
        case 3: self = .staleState
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .invalidIntent: return 1
        case .signatureError: return 2
        case .staleState: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SubmitIntentResponse.Success.Code] = [
    .ok,
  ]
}

extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SubmitIntentResponse.Error.Code] = [
    .denied,
    .invalidIntent,
    .signatureError,
    .staleState,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetIntentMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID to query
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The verified owner account public key when not signing with the rendezvous
  /// key. Only owner accounts involved in the intent can access the metadata.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetIntentStatusRequest) without this field set
  /// using the private key of the rendezvous or owner account. This provides an
  /// authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_GetIntentMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetIntentMetadataResponse.Result = .ok

  public var metadata: Code_Transaction_V2_Metadata {
    get {return _metadata ?? Code_Transaction_V2_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Code_Transaction_V2_Metadata? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetIntentMetadataResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetIntentMetadataResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetPrivacyUpgradeStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The action ID for private transaction
  public var actionID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
}

public struct Code_Transaction_V2_GetPrivacyUpgradeStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Result = .ok

  public var status: Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The provided intent ID doesn't exist
    case intentNotFound // = 1

    /// The provided action ID doesn't exist
    case actionNotFound // = 2

    /// The provided action doesn't map to a private transaction
    case invalidAction // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .intentNotFound
      case 2: self = .actionNotFound
      case 3: self = .invalidAction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .intentNotFound: return 1
      case .actionNotFound: return 2
      case .invalidAction: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The transaction for the temporary private transaction was submitted and
    /// finalized. The opportunity to upgrade was missed.
    case temporaryTransactionFinalized // = 1

    /// The next block of transactions hasn't been created. Wait and try again
    /// later.
    case waitingForNextBlock // = 2

    /// The transaction can be upgraded to permanent privacy
    case readyForUpgrade // = 3

    /// The transaction has already been upgraded
    case alreadyUpgraded // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .temporaryTransactionFinalized
      case 2: self = .waitingForNextBlock
      case 3: self = .readyForUpgrade
      case 4: self = .alreadyUpgraded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .temporaryTransactionFinalized: return 1
      case .waitingForNextBlock: return 2
      case .readyForUpgrade: return 3
      case .alreadyUpgraded: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Result] = [
    .ok,
    .intentNotFound,
    .actionNotFound,
    .invalidAction,
  ]
}

extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Status] = [
    .unknown,
    .temporaryTransactionFinalized,
    .waitingForNextBlock,
    .readyForUpgrade,
    .alreadyUpgraded,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to query against for upgradeable intents.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The maximum number of intents to return in the response. Default is 10.
  public var limit: UInt32 = 0

  /// The signature is of serialize(GetPrioritizedIntentsForPrivacyUpgradeRequest)
  /// without this field set using the private key of the owner account. This
  /// provides an authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse.Result = .ok

  /// Ordered from highest to lowest priority
  public var items: [Code_Transaction_V2_UpgradeableIntent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetLimitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account whose limits will be calculated. Any other owner accounts
  /// linked with the same identity of the owner will also be applied.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetLimitsRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// All transactions starting at this time will be incorporated into the consumed
  /// limit calculation. Clients should set this to the start of the current day in
  /// the client's current time zone (because server has no knowledge of this atm).
  public var consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _consumedSince ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_consumedSince = newValue}
  }
  /// Returns true if `consumedSince` has been explicitly set.
  public var hasConsumedSince: Bool {return self._consumedSince != nil}
  /// Clears the value of `consumedSince`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedSince() {self._consumedSince = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Code_Transaction_V2_GetLimitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetLimitsResponse.Result = .ok

  /// Send limits keyed by currency
  public var sendLimitsByCurrency: Dictionary<String,Code_Transaction_V2_SendLimit> = [:]

  /// Deposit limits
  public var depositLimit: Code_Transaction_V2_DepositLimit {
    get {return _depositLimit ?? Code_Transaction_V2_DepositLimit()}
    set {_depositLimit = newValue}
  }
  /// Returns true if `depositLimit` has been explicitly set.
  public var hasDepositLimit: Bool {return self._depositLimit != nil}
  /// Clears the value of `depositLimit`. Subsequent reads from it will return its default value.
  public mutating func clearDepositLimit() {self._depositLimit = nil}

  /// Micro payment limits keyed by currency
  public var microPaymentLimitsByCurrency: Dictionary<String,Code_Transaction_V2_MicroPaymentLimit> = [:]

  /// Buy module limits keyed by currency
  public var buyModuleLimitsByCurrency: Dictionary<String,Code_Transaction_V2_BuyModuleLimit> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _depositLimit: Code_Transaction_V2_DepositLimit? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetLimitsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetLimitsResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetPaymentHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to get payment history for
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// An optional history cursor indicating where in the history to resume from.
  public var cursor: Code_Transaction_V2_Cursor {
    get {return _cursor ?? Code_Transaction_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  /// The number of results to return per request. Default is 100.
  public var pageSize: UInt32 = 0

  /// The order in which to return history items from the cursor.
  public var direction: Code_Transaction_V2_GetPaymentHistoryRequest.Direction = .asc

  /// The signature is of serialize(GetPaymentHistoryRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// ASC direction returns all history items in ascending order.
    case asc // = 0

    /// DESC direction returns all history items in descending order.
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _cursor: Code_Transaction_V2_Cursor? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetPaymentHistoryRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetPaymentHistoryRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetPaymentHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetPaymentHistoryResponse.Result = .ok

  public var items: [Code_Transaction_V2_PaymentHistoryItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetPaymentHistoryResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetPaymentHistoryResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_CanWithdrawToAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Code_Common_V1_SolanaAccountId {
    get {return _account ?? Code_Common_V1_SolanaAccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_CanWithdrawToAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata so the client knows how to withdraw to the account. Server cannot
  /// provide precalculated addresses in this response to maintain non-custodial
  /// status.
  public var accountType: Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType = .unknown

  /// Server-controlled flag to indicate if the account can be withdrawn to.
  /// There are several reasons server may deny it, including:
  ///  - Wrong type of Code account
  ///  - Not wanting to subsidize the creation of an ATA
  ///  - Unsupported external account type (eg. token account but of the wrong mint)
  /// This is guaranteed to be false when account_type = Unknown.
  public var isValidPaymentDestination: Bool = false

  /// Token account requires initialization before the withdrawal can occur.
  /// Server has chosen not to subsidize the fees. The response is guaranteed
  /// to have set is_valid_payment_destination = false in this case.
  public var requiresInitialization: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AccountType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Server cannot determine
    case unknown // = 0

    /// Client uses the address as is in SubmitIntent
    case tokenAccount // = 1

    /// Client locally derives the ATA to use in SubmitIntent
    case ownerAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tokenAccount
      case 2: self = .ownerAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tokenAccount: return 1
      case .ownerAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType] = [
    .unknown,
    .tokenAccount,
    .ownerAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_AirdropRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of airdrop to claim
  public var airdropType: Code_Transaction_V2_AirdropType = .unknown

  /// The owner account to airdrop Kin to
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(AirdropRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_AirdropResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_AirdropResponse.Result = .ok

  /// Exchange data for the amount of Kin airdropped when successful
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// Airdrops are unavailable
    case unavailable // = 1

    /// The airdrop has already been claimed by the owner
    case alreadyClaimed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unavailable
      case 2: self = .alreadyClaimed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unavailable: return 1
      case .alreadyClaimed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_AirdropResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_AirdropResponse.Result] = [
    .ok,
    .unavailable,
    .alreadyClaimed,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_SwapRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Code_Transaction_V2_SwapRequest.OneOf_Request? = nil

  public var initiate: Code_Transaction_V2_SwapRequest.Initiate {
    get {
      if case .initiate(let v)? = request {return v}
      return Code_Transaction_V2_SwapRequest.Initiate()
    }
    set {request = .initiate(newValue)}
  }

  public var submitSignature: Code_Transaction_V2_SwapRequest.SubmitSignature {
    get {
      if case .submitSignature(let v)? = request {return v}
      return Code_Transaction_V2_SwapRequest.SubmitSignature()
    }
    set {request = .submitSignature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case initiate(Code_Transaction_V2_SwapRequest.Initiate)
    case submitSignature(Code_Transaction_V2_SwapRequest.SubmitSignature)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SwapRequest.OneOf_Request, rhs: Code_Transaction_V2_SwapRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initiate, .initiate): return {
        guard case .initiate(let l) = lhs, case .initiate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.submitSignature, .submitSignature): return {
        guard case .submitSignature(let l) = lhs, case .submitSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Initiate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The verified owner account public key
    public var owner: Code_Common_V1_SolanaAccountId {
      get {return _owner ?? Code_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// The user authority account that will sign to authorize the swap. Ideally,
    /// this is an account derived off the owner account that is solely responsible
    /// for swapping.
    public var swapAuthority: Code_Common_V1_SolanaAccountId {
      get {return _swapAuthority ?? Code_Common_V1_SolanaAccountId()}
      set {_swapAuthority = newValue}
    }
    /// Returns true if `swapAuthority` has been explicitly set.
    public var hasSwapAuthority: Bool {return self._swapAuthority != nil}
    /// Clears the value of `swapAuthority`. Subsequent reads from it will return its default value.
    public mutating func clearSwapAuthority() {self._swapAuthority = nil}

    /// Maximum amount to swap from the source mint, in quarks. If value is set to zero,
    /// the entire amount will be swapped.
    public var limit: UInt64 = 0

    /// Whether the client wants the RPC to wait for blockchain status. If false,
    /// then the RPC will return Success when the swap is submitted to the blockchain.
    /// Otherwise, the RPC will observe and report back the status of the transaction. 
    public var waitForBlockchainStatus: Bool = false

    /// The signature is of serialize(Initiate) without this field set using the
    /// private key of the owner account. This provides an authentication mechanism
    /// to the RPC.
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _swapAuthority: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _signature: Code_Common_V1_Signature? = nil
  }

  public struct SubmitSignature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The signature for the locally constructed swap transaction
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _signature: Code_Common_V1_Signature? = nil
  }

  public init() {}
}

public struct Code_Transaction_V2_SwapResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Code_Transaction_V2_SwapResponse.OneOf_Response? = nil

  public var serverParameters: Code_Transaction_V2_SwapResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Code_Transaction_V2_SwapResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Code_Transaction_V2_SwapResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case serverParameters(Code_Transaction_V2_SwapResponse.ServerParameters)
    case success(Code_Transaction_V2_SwapResponse.Success)
    case error(Code_Transaction_V2_SwapResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SwapResponse.OneOf_Response, rhs: Code_Transaction_V2_SwapResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serverParameters, .serverParameters): return {
        guard case .serverParameters(let l) = lhs, case .serverParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ServerParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Subisdizer account that will be paying for the swap
    public var payer: Code_Common_V1_SolanaAccountId {
      get {return _payer ?? Code_Common_V1_SolanaAccountId()}
      set {_payer = newValue}
    }
    /// Returns true if `payer` has been explicitly set.
    public var hasPayer: Bool {return self._payer != nil}
    /// Clears the value of `payer`. Subsequent reads from it will return its default value.
    public mutating func clearPayer() {self._payer = nil}

    /// Recent blockhash
    public var recentBlockhash: Code_Common_V1_Blockhash {
      get {return _recentBlockhash ?? Code_Common_V1_Blockhash()}
      set {_recentBlockhash = newValue}
    }
    /// Returns true if `recentBlockhash` has been explicitly set.
    public var hasRecentBlockhash: Bool {return self._recentBlockhash != nil}
    /// Clears the value of `recentBlockhash`. Subsequent reads from it will return its default value.
    public mutating func clearRecentBlockhash() {self._recentBlockhash = nil}

    /// Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
    /// instruction. If the value is 0, then the instruction can be omitted.
    public var computeUnitLimit: UInt32 = 0

    /// Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
    /// instruction. If the value is 0, then the instruction can be omitted.
    public var computeUnitPrice: UInt64 = 0

    /// On-chain program that will be performing the swap
    public var swapProgram: Code_Common_V1_SolanaAccountId {
      get {return _swapProgram ?? Code_Common_V1_SolanaAccountId()}
      set {_swapProgram = newValue}
    }
    /// Returns true if `swapProgram` has been explicitly set.
    public var hasSwapProgram: Bool {return self._swapProgram != nil}
    /// Clears the value of `swapProgram`. Subsequent reads from it will return its default value.
    public mutating func clearSwapProgram() {self._swapProgram = nil}

    /// Accounts provided to the swap instruction
    public var swapIxnAccounts: [Code_Common_V1_InstructionAccount] = []

    /// Instruction data for the swap instruction
    public var swapIxnData: Data = Data()

    /// Maximum quarks that will be sent out of the source account after
    /// executing the swap. If not, the validation instruction will cause
    /// the transaction to fail.
    public var maxToSend: UInt64 = 0

    /// Minimum quarks that will be received into the destination account
    /// after executing the swap. If not, the validation instruction will
    /// cause the transaction to fail.
    public var minToReceive: UInt64 = 0

    /// Nonce to use in swap validator state account PDA
    public var nonce: Code_Common_V1_SolanaAccountId {
      get {return _nonce ?? Code_Common_V1_SolanaAccountId()}
      set {_nonce = newValue}
    }
    /// Returns true if `nonce` has been explicitly set.
    public var hasNonce: Bool {return self._nonce != nil}
    /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
    public mutating func clearNonce() {self._nonce = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _payer: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _recentBlockhash: Code_Common_V1_Blockhash? = nil
    fileprivate var _swapProgram: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _nonce: Code_Common_V1_SolanaAccountId? = nil
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SwapResponse.Success.Code = .swapSubmitted

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The swap was submitted to the blockchain.
      case swapSubmitted // = 0

      /// The swap was finalized on the blockchain.
      case swapFinalized // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .swapSubmitted
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .swapSubmitted
        case 1: self = .swapFinalized
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .swapSubmitted: return 0
        case .swapFinalized: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SwapResponse.Error.Code = .denied

    public var errorDetails: [Code_Transaction_V2_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// There is an issue with the provided signature.
      case signatureError // = 2

      /// The swap failed server-side validation
      case invalidSwap // = 3

      /// The submitted swap transaction failed. Attempt the swap again.
      case swapFailed // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 2: self = .signatureError
        case 3: self = .invalidSwap
        case 4: self = .swapFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .signatureError: return 2
        case .invalidSwap: return 3
        case .swapFailed: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_SwapResponse.Success.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SwapResponse.Success.Code] = [
    .swapSubmitted,
    .swapFinalized,
  ]
}

extension Code_Transaction_V2_SwapResponse.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SwapResponse.Error.Code] = [
    .denied,
    .signatureError,
    .invalidSwap,
    .swapFailed,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account invoking the buy module
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The amount being purchased
  public var purchaseAmount: Code_Transaction_V2_ExchangeDataWithoutRate {
    get {return _purchaseAmount ?? Code_Transaction_V2_ExchangeDataWithoutRate()}
    set {_purchaseAmount = newValue}
  }
  /// Returns true if `purchaseAmount` has been explicitly set.
  public var hasPurchaseAmount: Bool {return self._purchaseAmount != nil}
  /// Clears the value of `purchaseAmount`. Subsequent reads from it will return its default value.
  public mutating func clearPurchaseAmount() {self._purchaseAmount = nil}

  /// A nonce value unique to the purchase. If it's included in a memo for the
  /// transaction for the deposit to the owner, then purchase_amount will be used
  /// for display values. Otherwise, the amount will be inferred from the transaction.
  public var nonce: Code_Common_V1_UUID {
    get {return _nonce ?? Code_Common_V1_UUID()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  public var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  public mutating func clearNonce() {self._nonce = nil}

  /// The signature is of serialize(DeclareFiatOnrampPurchaseAttemptRequest) without
  /// this field set using the private key of the owner account. This provides an
  /// authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _purchaseAmount: Code_Transaction_V2_ExchangeDataWithoutRate? = nil
  fileprivate var _nonce: Code_Common_V1_UUID? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The owner account is not valid (ie. it isn't a Code account)
    case invalidOwner // = 1

    /// The currency isn't supported
    case unsupportedCurrency // = 2

    /// The amount specified exceeds limits
    case amountExceedsMaximum // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidOwner
      case 2: self = .unsupportedCurrency
      case 3: self = .amountExceedsMaximum
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidOwner: return 1
      case .unsupportedCurrency: return 2
      case .amountExceedsMaximum: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result] = [
    .ok,
    .invalidOwner,
    .unsupportedCurrency,
    .amountExceedsMaximum,
  ]
}

#endif  // swift(>=4.2)

/// Metadata describes the high-level details of an intent
public struct Code_Transaction_V2_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Transaction_V2_Metadata.OneOf_Type? = nil

  public var openAccounts: Code_Transaction_V2_OpenAccountsMetadata {
    get {
      if case .openAccounts(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountsMetadata()
    }
    set {type = .openAccounts(newValue)}
  }

  public var sendPrivatePayment: Code_Transaction_V2_SendPrivatePaymentMetadata {
    get {
      if case .sendPrivatePayment(let v)? = type {return v}
      return Code_Transaction_V2_SendPrivatePaymentMetadata()
    }
    set {type = .sendPrivatePayment(newValue)}
  }

  public var receivePaymentsPrivately: Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata {
    get {
      if case .receivePaymentsPrivately(let v)? = type {return v}
      return Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata()
    }
    set {type = .receivePaymentsPrivately(newValue)}
  }

  public var upgradePrivacy: Code_Transaction_V2_UpgradePrivacyMetadata {
    get {
      if case .upgradePrivacy(let v)? = type {return v}
      return Code_Transaction_V2_UpgradePrivacyMetadata()
    }
    set {type = .upgradePrivacy(newValue)}
  }

  public var migrateToPrivacy2022: Code_Transaction_V2_MigrateToPrivacy2022Metadata {
    get {
      if case .migrateToPrivacy2022(let v)? = type {return v}
      return Code_Transaction_V2_MigrateToPrivacy2022Metadata()
    }
    set {type = .migrateToPrivacy2022(newValue)}
  }

  public var sendPublicPayment: Code_Transaction_V2_SendPublicPaymentMetadata {
    get {
      if case .sendPublicPayment(let v)? = type {return v}
      return Code_Transaction_V2_SendPublicPaymentMetadata()
    }
    set {type = .sendPublicPayment(newValue)}
  }

  public var receivePaymentsPublicly: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata {
    get {
      if case .receivePaymentsPublicly(let v)? = type {return v}
      return Code_Transaction_V2_ReceivePaymentsPubliclyMetadata()
    }
    set {type = .receivePaymentsPublicly(newValue)}
  }

  public var establishRelationship: Code_Transaction_V2_EstablishRelationshipMetadata {
    get {
      if case .establishRelationship(let v)? = type {return v}
      return Code_Transaction_V2_EstablishRelationshipMetadata()
    }
    set {type = .establishRelationship(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case openAccounts(Code_Transaction_V2_OpenAccountsMetadata)
    case sendPrivatePayment(Code_Transaction_V2_SendPrivatePaymentMetadata)
    case receivePaymentsPrivately(Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata)
    case upgradePrivacy(Code_Transaction_V2_UpgradePrivacyMetadata)
    case migrateToPrivacy2022(Code_Transaction_V2_MigrateToPrivacy2022Metadata)
    case sendPublicPayment(Code_Transaction_V2_SendPublicPaymentMetadata)
    case receivePaymentsPublicly(Code_Transaction_V2_ReceivePaymentsPubliclyMetadata)
    case establishRelationship(Code_Transaction_V2_EstablishRelationshipMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_Metadata.OneOf_Type, rhs: Code_Transaction_V2_Metadata.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccounts, .openAccounts): return {
        guard case .openAccounts(let l) = lhs, case .openAccounts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendPrivatePayment, .sendPrivatePayment): return {
        guard case .sendPrivatePayment(let l) = lhs, case .sendPrivatePayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receivePaymentsPrivately, .receivePaymentsPrivately): return {
        guard case .receivePaymentsPrivately(let l) = lhs, case .receivePaymentsPrivately(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upgradePrivacy, .upgradePrivacy): return {
        guard case .upgradePrivacy(let l) = lhs, case .upgradePrivacy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.migrateToPrivacy2022, .migrateToPrivacy2022): return {
        guard case .migrateToPrivacy2022(let l) = lhs, case .migrateToPrivacy2022(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendPublicPayment, .sendPublicPayment): return {
        guard case .sendPublicPayment(let l) = lhs, case .sendPublicPayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receivePaymentsPublicly, .receivePaymentsPublicly): return {
        guard case .receivePaymentsPublicly(let l) = lhs, case .receivePaymentsPublicly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.establishRelationship, .establishRelationship): return {
        guard case .establishRelationship(let l) = lhs, case .establishRelationship(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Open a set of accounts. Currently, clients should only use this for new users
/// to open all required accounts up front (buckets, incoming, and outgoing).
///
/// Action Spec:
///
/// actions = [OpenAccountAction(PRIMARY)]
/// for account in [TEMPORARY_INCOMING, TEMPORARY_OUTGOING, BUCKET_1_KIN, ... , BUCKET_1_000_000_KIN]
///   actions.push_back(OpenAccountAction(account))
///   actions.push_back(CloseDormantAccount(account))
public struct Code_Transaction_V2_OpenAccountsMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sends a payment to a destination account with initial temporary privacy. Clients
/// should also reorganize their bucket accounts and rotate their temporary outgoing
/// account.
///
/// Action Spec (In Person Cash Payment or Withdrawal or Tip):
///
/// actions = [
///   // Section 1: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
///
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///   ...,
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///
///   // Section 2: Rotate TEMPORARY_OUTGOING account
///
///   // Below must appear last in this exact order
///   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], destination, ExchangeData.Quarks),
///   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
///   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
/// ]
///
/// Action Spec (Remote Send):
///
/// actions = [
///   // Section 1: Open REMOTE_SEND_GIFT_CARD account
///
///   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
///
///   // Section 2: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
///
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///   ...,
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///
///   // Section 3: Rotate TEMPORARY_OUTGOING account
///
///   // Below must appear last in this exact order
///   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
///   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
///   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
///
///   // Section 4: Close REMOTE_SEND_GIFT_CARD if not redeemed after period of time
///
///   CloseDormantAccount(REMOTE_SEND_GIFT_CARD),
///
/// Action Spec (Micro Payment):
///
/// actions = [
///   // Section 1: Transfer ExchangeData.Quarks from BUCKET_X_KIN accounts to TEMPORARY_OUTGOING account with reogranizations
///
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///   ...,
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyTransferAction(BUCKET_X_KIN, TEMPORARY_OUTGOING[index], multiple * bucketSize),
///
///   // Section 2: Fee payments
///
///   // Hard-coded Code $0.01 USD fee to a dynamic fee account
///   FeePayment(TEMPORARY_OUTGOING[index], codeFeeAccount, $0.01 USD of Kin),
///
///   // Additional fees, exactly as specified in the original payment request
///   FeePayment(TEMPORARY_OUTGOING[index], additionalFeeAccount0, additionalFeeQuarks0),
///   ...
///   FeePayment(TEMPORARY_OUTGOING[index], additionalFeeAccountN, additionalFeeQuarksN),
///
///   // Section 3: Rotate TEMPORARY_OUTGOING account
///
///   // Below must appear last in this exact order
///   NoPrivacyWithdrawAction(TEMPORARY_OUTGOING[index], destination, ExchangeData.Quarks - $0.01 USD of Kin - additionalFeeQuarks0 - ... - additionalFeeQuarksN),
///   OpenAccountAction(TEMPORARY_OUTGOING[index + 1]),
///   CloseDormantAccount(TEMPORARY_OUTGOING[index + 1]),
/// ]
public struct Code_Transaction_V2_SendPrivatePaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination token account to send funds to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The exchange data of total funds being sent to the destination
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// Is the payment a withdrawal? For destinations that are not Code temporary
  /// accounts, this must be set to true.
  public var isWithdrawal: Bool = false

  /// Is the payment for a remote send?
  public var isRemoteSend: Bool = false

  /// Is the payment for a tip?
  public var isTip: Bool = false

  /// If is_tip is true, the user being tipped
  public var tippedUser: Code_Transaction_V2_TippedUser {
    get {return _tippedUser ?? Code_Transaction_V2_TippedUser()}
    set {_tippedUser = newValue}
  }
  /// Returns true if `tippedUser` has been explicitly set.
  public var hasTippedUser: Bool {return self._tippedUser != nil}
  /// Clears the value of `tippedUser`. Subsequent reads from it will return its default value.
  public mutating func clearTippedUser() {self._tippedUser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
  fileprivate var _tippedUser: Code_Transaction_V2_TippedUser? = nil
}

/// Send a payment to a destination account publicly.
///
/// Action Spec:
///
/// source = PRIMARY or RELATIONSHIP
/// actions = [NoPrivacyTransferAction(source, destination, ExchangeData.Quarks)]
public struct Code_Transaction_V2_SendPublicPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The primary or relatinship account where funds will be sent from. The primary
  /// account is assumed if this field is not set for backwards compatibility with
  /// old clients.
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination token account to send funds to. This cannot be a Code
  /// temporary account.
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The exchange data of total funds being sent to the destination
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// Is the payment a withdrawal? Currently, this is always true.
  public var isWithdrawal: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

/// Receive funds into an organizer with initial temporary privacy. Clients should
/// also reorganize their bucket accounts and rotate their temporary incoming account
/// as applicable. Only accounts owned and derived by a user's 12 words should operate
/// as a source in this intent type to guarantee privacy upgradeability.
///
/// Action Spec (Payment):
///
/// actions = [
///   // Section 1: Transfer Quarks from TEMPORARY_INCOMING account to BUCKET_X_KIN accounts with reorganizations
///
///   TemporaryPrivacyTransferAction(TEMPORARY_INCOMING[index], BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   ...,
///   TemporaryPrivacyTransferAction(TEMPORARY_INCOMING[index], BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///
///   // Section 2: Rotate TEMPORARY_INCOMING account
///
///   // Below must appear last in this exact order
///   CloseEmptyAccountAction(TEMPORARY_INCOMING[index]),
///   OpenAccountAction(TEMPORARY_INCOMING[index + 1])
///   CloseDormantAccount(TEMPORARY_INCOMING[index + 1]),
/// ]
///
/// Action Spec (Deposit):
///
/// source = PRIMARY or RELATIONSHIP
/// actions = [
///   TemporaryPrivacyTransferAction(source, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
///   ...,
///   TemporaryPrivacyTransferAction(source, BUCKET_X_KIN, multiple * bucketSize),
///   TemporaryPrivacyExchangeAction(BUCKET_X_KIN, BUCKET_X_KIN, multiple * bucketSize),
/// ]
public struct Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The temporary incoming, primary or relationship account to receive funds from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The exact amount of Kin in quarks being received
  public var quarks: UInt64 = 0

  /// Is the receipt of funds from a deposit? If true, the source account must
  /// be a primary or relationship account. Otherwise, it must be from a temporary
  /// incoming account.
  public var isDeposit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
}

/// Receive funds into a user-owned account publicly. All use cases of this intent
/// close the account, so all funds must be moved. Use this intent to receive payments
/// from an account not owned by a user's 12 words into a temporary incoming account,
/// which will guarantee privacy upgradeability.
///
/// Action Spec (Remote Send):
///
/// actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, TEMPORARY_INCOMING[latest_index], quarks)]
public struct Code_Transaction_V2_ReceivePaymentsPubliclyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The remote send gift card to receive funds from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The exact amount of Kin in quarks being received
  public var quarks: UInt64 = 0

  /// Is the receipt of funds from a remote send gift card? Currently, this is
  /// the only use case for this intent and validation enforces the flag to true.
  public var isRemoteSend: Bool = false

  /// If is_remote_send is true, is the gift card being voided? The user owner
  /// account's 12 words that issued the gift card may only set this flag to true.
  /// Functionally, this doesn't affect the intent, but rather if we decide to show
  /// it in a user-friendly payment history.
  public var isIssuerVoidingGiftCard: Bool = false

  /// If is_remote_send is true, the original exchange data that was provided as
  /// part of creating the gift card account. This is purely a server-provided value.
  /// SubmitIntent will disallow this being set.
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

/// Upgrade existing private transactions from temporary to permanent privacy.
public struct Code_Transaction_V2_UpgradePrivacyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Migrates existing users prior to the privacy implementation by:
///  1. If there are funds in the LEGACY_PRIMARY_2022 account, then move them
///     to the new PRIMARY account, so the client can later simulate a deposit
///     by submitting a *separate* ReceivePaymentsPrivately intent.
///  2. Close the LEGACY_PRIMARY_2022 account.
///
/// Prereqs:
///  - OpenAccounts intent has been submitted
///
/// Action spec:
///
/// if balance == 0 {
///    actions = [CloseEmptyAccountAction(LEGACY_PRIMARY_2022)]
/// } else {
///    actions = [NoPrivacyWitdraw(LEGACY_PRIMARY_2022, PRIMARY, Quarks)]
/// }
public struct Code_Transaction_V2_MigrateToPrivacy2022Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The exact amount of Kin in quarks being migrated. Set this to zero if
  /// the account is empty.
  public var quarks: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Establishes a long-lived private relationship between a user and another
/// entity.
///
/// Prereqs:
///  - OpenAccounts intent has been submitted
///
/// Action spec:
///
/// actions = [OpenAccountAction(RELATIONSHIP)]
public struct Code_Transaction_V2_EstablishRelationshipMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var relationship: Code_Common_V1_Relationship {
    get {return _relationship ?? Code_Common_V1_Relationship()}
    set {_relationship = newValue}
  }
  /// Returns true if `relationship` has been explicitly set.
  public var hasRelationship: Bool {return self._relationship != nil}
  /// Clears the value of `relationship`. Subsequent reads from it will return its default value.
  public mutating func clearRelationship() {self._relationship = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _relationship: Code_Common_V1_Relationship? = nil
}

/// Action is a well-defined, ordered and small set of transactions for a unit of work
/// that the client wants to perform on the blockchain. Clients provide parameters known
/// to them in the action.
public struct Code_Transaction_V2_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this action, which is unique within an intent. It must match
  /// the index of the action's location in the SubmitAction's actions field.
  public var id: UInt32 = 0

  /// The type of action to perform.
  public var type: Code_Transaction_V2_Action.OneOf_Type? = nil

  public var openAccount: Code_Transaction_V2_OpenAccountAction {
    get {
      if case .openAccount(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountAction()
    }
    set {type = .openAccount(newValue)}
  }

  public var closeEmptyAccount: Code_Transaction_V2_CloseEmptyAccountAction {
    get {
      if case .closeEmptyAccount(let v)? = type {return v}
      return Code_Transaction_V2_CloseEmptyAccountAction()
    }
    set {type = .closeEmptyAccount(newValue)}
  }

  public var closeDormantAccount: Code_Transaction_V2_CloseDormantAccountAction {
    get {
      if case .closeDormantAccount(let v)? = type {return v}
      return Code_Transaction_V2_CloseDormantAccountAction()
    }
    set {type = .closeDormantAccount(newValue)}
  }

  public var noPrivacyTransfer: Code_Transaction_V2_NoPrivacyTransferAction {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyTransferAction()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Code_Transaction_V2_NoPrivacyWithdrawAction {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyWithdrawAction()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var temporaryPrivacyTransfer: Code_Transaction_V2_TemporaryPrivacyTransferAction {
    get {
      if case .temporaryPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_TemporaryPrivacyTransferAction()
    }
    set {type = .temporaryPrivacyTransfer(newValue)}
  }

  public var temporaryPrivacyExchange: Code_Transaction_V2_TemporaryPrivacyExchangeAction {
    get {
      if case .temporaryPrivacyExchange(let v)? = type {return v}
      return Code_Transaction_V2_TemporaryPrivacyExchangeAction()
    }
    set {type = .temporaryPrivacyExchange(newValue)}
  }

  public var permanentPrivacyUpgrade: Code_Transaction_V2_PermanentPrivacyUpgradeAction {
    get {
      if case .permanentPrivacyUpgrade(let v)? = type {return v}
      return Code_Transaction_V2_PermanentPrivacyUpgradeAction()
    }
    set {type = .permanentPrivacyUpgrade(newValue)}
  }

  public var feePayment: Code_Transaction_V2_FeePaymentAction {
    get {
      if case .feePayment(let v)? = type {return v}
      return Code_Transaction_V2_FeePaymentAction()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of action to perform.
  public enum OneOf_Type: Equatable {
    case openAccount(Code_Transaction_V2_OpenAccountAction)
    case closeEmptyAccount(Code_Transaction_V2_CloseEmptyAccountAction)
    case closeDormantAccount(Code_Transaction_V2_CloseDormantAccountAction)
    case noPrivacyTransfer(Code_Transaction_V2_NoPrivacyTransferAction)
    case noPrivacyWithdraw(Code_Transaction_V2_NoPrivacyWithdrawAction)
    case temporaryPrivacyTransfer(Code_Transaction_V2_TemporaryPrivacyTransferAction)
    case temporaryPrivacyExchange(Code_Transaction_V2_TemporaryPrivacyExchangeAction)
    case permanentPrivacyUpgrade(Code_Transaction_V2_PermanentPrivacyUpgradeAction)
    case feePayment(Code_Transaction_V2_FeePaymentAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_Action.OneOf_Type, rhs: Code_Transaction_V2_Action.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccount, .openAccount): return {
        guard case .openAccount(let l) = lhs, case .openAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeEmptyAccount, .closeEmptyAccount): return {
        guard case .closeEmptyAccount(let l) = lhs, case .closeEmptyAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeDormantAccount, .closeDormantAccount): return {
        guard case .closeDormantAccount(let l) = lhs, case .closeDormantAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyTransfer, .noPrivacyTransfer): return {
        guard case .noPrivacyTransfer(let l) = lhs, case .noPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyWithdraw, .noPrivacyWithdraw): return {
        guard case .noPrivacyWithdraw(let l) = lhs, case .noPrivacyWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temporaryPrivacyTransfer, .temporaryPrivacyTransfer): return {
        guard case .temporaryPrivacyTransfer(let l) = lhs, case .temporaryPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temporaryPrivacyExchange, .temporaryPrivacyExchange): return {
        guard case .temporaryPrivacyExchange(let l) = lhs, case .temporaryPrivacyExchange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permanentPrivacyUpgrade, .permanentPrivacyUpgrade): return {
        guard case .permanentPrivacyUpgrade(let l) = lhs, case .permanentPrivacyUpgrade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feePayment, .feePayment): return {
        guard case .feePayment(let l) = lhs, case .feePayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. timelock::Initialize
///  Client Signature Required: No
///
/// All OpenAccountActions for non-primary accounts must be followed with an associated
/// CloseDormantAccountAction to enable server to perform cleanup.
public struct Code_Transaction_V2_OpenAccountAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of account, which will dictate its intended use
  public var accountType: Code_Common_V1_AccountType = .unknown

  /// The owner of the account. For accounts liked to a user's 12 words, this is
  /// the verified parent owner account public key. All other account types should
  /// set this to the authority value.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The index used to for accounts that are derived from owner
  public var index: UInt64 = 0

  /// The public key of the private key that has authority over the opened token account
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The token account being opened
  public var token: Code_Common_V1_SolanaAccountId {
    get {return _token ?? Code_Common_V1_SolanaAccountId()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The signature is of serialize(OpenAccountAction) without this field set
  /// using the private key of the authority account. This provides a proof
  /// of authorization to link authority to owner.
  public var authoritySignature: Code_Common_V1_Signature {
    get {return _authoritySignature ?? Code_Common_V1_Signature()}
    set {_authoritySignature = newValue}
  }
  /// Returns true if `authoritySignature` has been explicitly set.
  public var hasAuthoritySignature: Bool {return self._authoritySignature != nil}
  /// Clears the value of `authoritySignature`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritySignature() {self._authoritySignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _token: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _authoritySignature: Code_Common_V1_Signature? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. timelock::BurnDustWithAuthority (max 1 Kin)
///    3. timelock::CloseAccounts
///  Client Signature Required: Yes
public struct Code_Transaction_V2_CloseEmptyAccountAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of account being closed
  public var accountType: Code_Common_V1_AccountType = .unknown

  /// The public key of the private key that has authority over the token account
  /// that should be closed
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The token account being closed
  public var token: Code_Common_V1_SolanaAccountId {
    get {return _token ?? Code_Common_V1_SolanaAccountId()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _token: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::RevokeLockWithAuthority
///    4. timelock::DeactivateLock
///    5. timelock::Withdraw (token -> primary)
///    6. timelock::CloseAccounts
///  Client Signature Required: Yes
public struct Code_Transaction_V2_CloseDormantAccountAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of account being closed
  public var accountType: Code_Common_V1_AccountType = .unknown

  /// The public key of the private key that has authority over the token account
  /// that should be closed
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The token account being closed
  public var token: Code_Common_V1_SolanaAccountId {
    get {return _token ?? Code_Common_V1_SolanaAccountId()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The destination where funds are withdrawn to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _token: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::TransferWithAuthority (source -> destination)
///  Client Signature Required: Yes
public struct Code_Transaction_V2_NoPrivacyTransferAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The Kin quark amount to transfer
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::RevokeLockWithAuthority
///    4. timelock::DeactivateLock
///    5. timelock::Withdraw (source -> destination)
///    6. timelock::CloseAccounts
///  Client Signature Required: Yes
public struct Code_Transaction_V2_NoPrivacyWithdrawAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The intended Kin quark amount to withdraw
  public var amount: UInt64 = 0

  /// Whether the account is closed afterwards. This is always true, since there
  /// are no current se cases to leave it open.
  public var shouldClose: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. splitter::TransferWithCommitment (treasury -> destination)
///  Client Signature Required: No
///
/// Transaction 2
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::TransferWithAuthority (source -> commitment)
///  Client Signature Required: Yes
public struct Code_Transaction_V2_TemporaryPrivacyTransferAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The Kin quark amount to transfer
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. splitter::TransferWithCommitment (treasury -> destination)
///  Client Signature Required: No
///
/// Transaction 2
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::TransferWithAuthority (source -> commitment)
///  Client Signature Required: Yes
public struct Code_Transaction_V2_TemporaryPrivacyExchangeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are exchanged from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are exchanged to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The Kin quark amount to exchange
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::TransferWithAuthority (source -> different commitment)
///  Client Signature Required: Yes
public struct Code_Transaction_V2_PermanentPrivacyUpgradeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action ID of the temporary private transfer or exchange to upgrade
  public var actionID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transaction 1
///  Instructions:
///    1. system::AdvanceNonce
///    2. memo::Memo
///    3. timelock::TransferWithAuthority (source -> fee account)
///  Client Signature Required: Yes
///
/// Note: This is exactly a NoPrivacyTransferAction, but with specialized metadata
///       for fees.
public struct Code_Transaction_V2_FeePaymentAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of fee being operated on
  public var type: Code_Transaction_V2_FeePaymentAction.FeeType = .code

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The Kin quark amount to transfer
  public var amount: UInt64 = 0

  /// The destination where the fee payment is being made for fees outside of
  /// Code.
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FeeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Hardcoded $0.01 USD fee to a dynamic fee account specified by server
    case code // = 0

    /// Third party fee specified at time of payment request
    case thirdParty // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .code
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .code
      case 1: self = .thirdParty
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .code: return 0
      case .thirdParty: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_FeePaymentAction.FeeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_FeePaymentAction.FeeType] = [
    .code,
    .thirdParty,
  ]
}

#endif  // swift(>=4.2)

/// ServerParameter are a set of parameters known and returned by server that
/// enables clients to complete transaction construction. Any necessary proofs,
/// which are required to be locally verifiable, are also provided to ensure
/// safe use in the event of a malicious server.
public struct Code_Transaction_V2_ServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action the server parameters belong to
  public var actionID: UInt32 = 0

  /// The set of nonces used for the action. Server will only provide values
  /// for transactions requiring client signatures.
  public var nonces: [Code_Transaction_V2_NoncedTransactionMetadata] = []

  /// The type of server parameter which maps to the type of action requested
  public var type: Code_Transaction_V2_ServerParameter.OneOf_Type? = nil

  public var openAccount: Code_Transaction_V2_OpenAccountServerParameter {
    get {
      if case .openAccount(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountServerParameter()
    }
    set {type = .openAccount(newValue)}
  }

  public var closeEmptyAccount: Code_Transaction_V2_CloseEmptyAccountServerParameter {
    get {
      if case .closeEmptyAccount(let v)? = type {return v}
      return Code_Transaction_V2_CloseEmptyAccountServerParameter()
    }
    set {type = .closeEmptyAccount(newValue)}
  }

  public var closeDormantAccount: Code_Transaction_V2_CloseDormantAccountServerParameter {
    get {
      if case .closeDormantAccount(let v)? = type {return v}
      return Code_Transaction_V2_CloseDormantAccountServerParameter()
    }
    set {type = .closeDormantAccount(newValue)}
  }

  public var noPrivacyTransfer: Code_Transaction_V2_NoPrivacyTransferServerParameter {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyTransferServerParameter()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Code_Transaction_V2_NoPrivacyWithdrawServerParameter {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyWithdrawServerParameter()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var temporaryPrivacyTransfer: Code_Transaction_V2_TemporaryPrivacyTransferServerParameter {
    get {
      if case .temporaryPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_TemporaryPrivacyTransferServerParameter()
    }
    set {type = .temporaryPrivacyTransfer(newValue)}
  }

  public var temporaryPrivacyExchange: Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter {
    get {
      if case .temporaryPrivacyExchange(let v)? = type {return v}
      return Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter()
    }
    set {type = .temporaryPrivacyExchange(newValue)}
  }

  public var permanentPrivacyUpgrade: Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter {
    get {
      if case .permanentPrivacyUpgrade(let v)? = type {return v}
      return Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter()
    }
    set {type = .permanentPrivacyUpgrade(newValue)}
  }

  public var feePayment: Code_Transaction_V2_FeePaymentServerParameter {
    get {
      if case .feePayment(let v)? = type {return v}
      return Code_Transaction_V2_FeePaymentServerParameter()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of server parameter which maps to the type of action requested
  public enum OneOf_Type: Equatable {
    case openAccount(Code_Transaction_V2_OpenAccountServerParameter)
    case closeEmptyAccount(Code_Transaction_V2_CloseEmptyAccountServerParameter)
    case closeDormantAccount(Code_Transaction_V2_CloseDormantAccountServerParameter)
    case noPrivacyTransfer(Code_Transaction_V2_NoPrivacyTransferServerParameter)
    case noPrivacyWithdraw(Code_Transaction_V2_NoPrivacyWithdrawServerParameter)
    case temporaryPrivacyTransfer(Code_Transaction_V2_TemporaryPrivacyTransferServerParameter)
    case temporaryPrivacyExchange(Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter)
    case permanentPrivacyUpgrade(Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter)
    case feePayment(Code_Transaction_V2_FeePaymentServerParameter)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_ServerParameter.OneOf_Type, rhs: Code_Transaction_V2_ServerParameter.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccount, .openAccount): return {
        guard case .openAccount(let l) = lhs, case .openAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeEmptyAccount, .closeEmptyAccount): return {
        guard case .closeEmptyAccount(let l) = lhs, case .closeEmptyAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeDormantAccount, .closeDormantAccount): return {
        guard case .closeDormantAccount(let l) = lhs, case .closeDormantAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyTransfer, .noPrivacyTransfer): return {
        guard case .noPrivacyTransfer(let l) = lhs, case .noPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyWithdraw, .noPrivacyWithdraw): return {
        guard case .noPrivacyWithdraw(let l) = lhs, case .noPrivacyWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temporaryPrivacyTransfer, .temporaryPrivacyTransfer): return {
        guard case .temporaryPrivacyTransfer(let l) = lhs, case .temporaryPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temporaryPrivacyExchange, .temporaryPrivacyExchange): return {
        guard case .temporaryPrivacyExchange(let l) = lhs, case .temporaryPrivacyExchange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permanentPrivacyUpgrade, .permanentPrivacyUpgrade): return {
        guard case .permanentPrivacyUpgrade(let l) = lhs, case .permanentPrivacyUpgrade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feePayment, .feePayment): return {
        guard case .feePayment(let l) = lhs, case .feePayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Transaction_V2_NoncedTransactionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nonce account to use in the system::AdvanceNonce instruction
  public var nonce: Code_Common_V1_SolanaAccountId {
    get {return _nonce ?? Code_Common_V1_SolanaAccountId()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  public var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  public mutating func clearNonce() {self._nonce = nil}

  /// The blockhash to set in the transaction
  public var blockhash: Code_Common_V1_Blockhash {
    get {return _blockhash ?? Code_Common_V1_Blockhash()}
    set {_blockhash = newValue}
  }
  /// Returns true if `blockhash` has been explicitly set.
  public var hasBlockhash: Bool {return self._blockhash != nil}
  /// Clears the value of `blockhash`. Subsequent reads from it will return its default value.
  public mutating func clearBlockhash() {self._blockhash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nonce: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _blockhash: Code_Common_V1_Blockhash? = nil
}

/// There are no transactions requiring client signatures
public struct Code_Transaction_V2_OpenAccountServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_CloseEmptyAccountServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_CloseDormantAccountServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_NoPrivacyTransferServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_NoPrivacyWithdrawServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_TemporaryPrivacyTransferServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The treasury that will be used to split payments and provide a level of privacy
  public var treasury: Code_Common_V1_SolanaAccountId {
    get {return _treasury ?? Code_Common_V1_SolanaAccountId()}
    set {_treasury = newValue}
  }
  /// Returns true if `treasury` has been explicitly set.
  public var hasTreasury: Bool {return self._treasury != nil}
  /// Clears the value of `treasury`. Subsequent reads from it will return its default value.
  public mutating func clearTreasury() {self._treasury = nil}

  /// A recent root server observed from the treasury
  public var recentRoot: Code_Common_V1_Hash {
    get {return _recentRoot ?? Code_Common_V1_Hash()}
    set {_recentRoot = newValue}
  }
  /// Returns true if `recentRoot` has been explicitly set.
  public var hasRecentRoot: Bool {return self._recentRoot != nil}
  /// Clears the value of `recentRoot`. Subsequent reads from it will return its default value.
  public mutating func clearRecentRoot() {self._recentRoot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _treasury: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _recentRoot: Code_Common_V1_Hash? = nil
}

public struct Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The treasury that will be used to split payments and provide a level of privacy
  public var treasury: Code_Common_V1_SolanaAccountId {
    get {return _treasury ?? Code_Common_V1_SolanaAccountId()}
    set {_treasury = newValue}
  }
  /// Returns true if `treasury` has been explicitly set.
  public var hasTreasury: Bool {return self._treasury != nil}
  /// Clears the value of `treasury`. Subsequent reads from it will return its default value.
  public mutating func clearTreasury() {self._treasury = nil}

  /// A recent root server observed from the treasury
  public var recentRoot: Code_Common_V1_Hash {
    get {return _recentRoot ?? Code_Common_V1_Hash()}
    set {_recentRoot = newValue}
  }
  /// Returns true if `recentRoot` has been explicitly set.
  public var hasRecentRoot: Bool {return self._recentRoot != nil}
  /// Clears the value of `recentRoot`. Subsequent reads from it will return its default value.
  public mutating func clearRecentRoot() {self._recentRoot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _treasury: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _recentRoot: Code_Common_V1_Hash? = nil
}

public struct Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new commitment that is being paid
  public var newCommitment: Code_Common_V1_SolanaAccountId {
    get {return _newCommitment ?? Code_Common_V1_SolanaAccountId()}
    set {_newCommitment = newValue}
  }
  /// Returns true if `newCommitment` has been explicitly set.
  public var hasNewCommitment: Bool {return self._newCommitment != nil}
  /// Clears the value of `newCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearNewCommitment() {self._newCommitment = nil}

  /// The new commitment account's transcript. This is purely needed by client
  /// to validate merkle_root with commitment PDA logic.
  public var newCommitmentTranscript: Code_Common_V1_Hash {
    get {return _newCommitmentTranscript ?? Code_Common_V1_Hash()}
    set {_newCommitmentTranscript = newValue}
  }
  /// Returns true if `newCommitmentTranscript` has been explicitly set.
  public var hasNewCommitmentTranscript: Bool {return self._newCommitmentTranscript != nil}
  /// Clears the value of `newCommitmentTranscript`. Subsequent reads from it will return its default value.
  public mutating func clearNewCommitmentTranscript() {self._newCommitmentTranscript = nil}

  /// The new commitment account's destination. This is purely needed by client
  /// to validate merkle_root with commitment PDA logic.
  public var newCommitmentDestination: Code_Common_V1_SolanaAccountId {
    get {return _newCommitmentDestination ?? Code_Common_V1_SolanaAccountId()}
    set {_newCommitmentDestination = newValue}
  }
  /// Returns true if `newCommitmentDestination` has been explicitly set.
  public var hasNewCommitmentDestination: Bool {return self._newCommitmentDestination != nil}
  /// Clears the value of `newCommitmentDestination`. Subsequent reads from it will return its default value.
  public mutating func clearNewCommitmentDestination() {self._newCommitmentDestination = nil}

  /// The new commitment account's payment amount. This is purely needed by client
  /// to validate merkle_root with commitment PDA logic.
  public var newCommitmentAmount: UInt64 = 0

  /// The merkle root, which was the recent root used in the new commitment account
  public var merkleRoot: Code_Common_V1_Hash {
    get {return _merkleRoot ?? Code_Common_V1_Hash()}
    set {_merkleRoot = newValue}
  }
  /// Returns true if `merkleRoot` has been explicitly set.
  public var hasMerkleRoot: Bool {return self._merkleRoot != nil}
  /// Clears the value of `merkleRoot`. Subsequent reads from it will return its default value.
  public mutating func clearMerkleRoot() {self._merkleRoot = nil}

  /// The merkle proof that validates the original commitment occurred prior to
  /// the new commitment server is asking client to pay
  public var merkleProof: [Code_Common_V1_Hash] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newCommitment: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _newCommitmentTranscript: Code_Common_V1_Hash? = nil
  fileprivate var _newCommitmentDestination: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _merkleRoot: Code_Common_V1_Hash? = nil
}

public struct Code_Transaction_V2_FeePaymentServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination account where Code fee payments should be sent. This will
  /// only be set when the corresponding FeePaymentAction Type is CODE.
  public var codeDestination: Code_Common_V1_SolanaAccountId {
    get {return _codeDestination ?? Code_Common_V1_SolanaAccountId()}
    set {_codeDestination = newValue}
  }
  /// Returns true if `codeDestination` has been explicitly set.
  public var hasCodeDestination: Bool {return self._codeDestination != nil}
  /// Clears the value of `codeDestination`. Subsequent reads from it will return its default value.
  public mutating func clearCodeDestination() {self._codeDestination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _codeDestination: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_ErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Transaction_V2_ErrorDetails.OneOf_Type? = nil

  public var reasonString: Code_Transaction_V2_ReasonStringErrorDetails {
    get {
      if case .reasonString(let v)? = type {return v}
      return Code_Transaction_V2_ReasonStringErrorDetails()
    }
    set {type = .reasonString(newValue)}
  }

  public var invalidSignature: Code_Transaction_V2_InvalidSignatureErrorDetails {
    get {
      if case .invalidSignature(let v)? = type {return v}
      return Code_Transaction_V2_InvalidSignatureErrorDetails()
    }
    set {type = .invalidSignature(newValue)}
  }

  public var denied: Code_Transaction_V2_DeniedErrorDetails {
    get {
      if case .denied(let v)? = type {return v}
      return Code_Transaction_V2_DeniedErrorDetails()
    }
    set {type = .denied(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case reasonString(Code_Transaction_V2_ReasonStringErrorDetails)
    case invalidSignature(Code_Transaction_V2_InvalidSignatureErrorDetails)
    case denied(Code_Transaction_V2_DeniedErrorDetails)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_ErrorDetails.OneOf_Type, rhs: Code_Transaction_V2_ErrorDetails.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reasonString, .reasonString): return {
        guard case .reasonString(let l) = lhs, case .reasonString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invalidSignature, .invalidSignature): return {
        guard case .invalidSignature(let l) = lhs, case .invalidSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.denied, .denied): return {
        guard case .denied(let l) = lhs, case .denied(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Transaction_V2_ReasonStringErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_InvalidSignatureErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action whose signature mismatched 
  public var actionID: UInt32 = 0

  /// The transaction the server expected to have signed.
  public var expectedTransaction: Code_Common_V1_Transaction {
    get {return _expectedTransaction ?? Code_Common_V1_Transaction()}
    set {_expectedTransaction = newValue}
  }
  /// Returns true if `expectedTransaction` has been explicitly set.
  public var hasExpectedTransaction: Bool {return self._expectedTransaction != nil}
  /// Clears the value of `expectedTransaction`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedTransaction() {self._expectedTransaction = nil}

  /// The signature that was provided by the client.
  public var providedSignature: Code_Common_V1_Signature {
    get {return _providedSignature ?? Code_Common_V1_Signature()}
    set {_providedSignature = newValue}
  }
  /// Returns true if `providedSignature` has been explicitly set.
  public var hasProvidedSignature: Bool {return self._providedSignature != nil}
  /// Clears the value of `providedSignature`. Subsequent reads from it will return its default value.
  public mutating func clearProvidedSignature() {self._providedSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expectedTransaction: Code_Common_V1_Transaction? = nil
  fileprivate var _providedSignature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_DeniedErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Code_Transaction_V2_DeniedErrorDetails.Code = .unspecified

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Reason code not yet defined
    case unspecified // = 0

    /// Phone number has exceeded its free account allocation
    case tooManyFreeAccountsForPhoneNumber // = 1

    /// Device has exceeded its free account allocation
    case tooManyFreeAccountsForDevice // = 2

    /// The country associated with the phone number with the account is not
    /// supported (eg. it is on the sanctioned list).
    case unsupportedCountry // = 3

    /// The device is not supported (eg. it fails device attestation checks)
    case unsupportedDevice // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tooManyFreeAccountsForPhoneNumber
      case 2: self = .tooManyFreeAccountsForDevice
      case 3: self = .unsupportedCountry
      case 4: self = .unsupportedDevice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tooManyFreeAccountsForPhoneNumber: return 1
      case .tooManyFreeAccountsForDevice: return 2
      case .unsupportedCountry: return 3
      case .unsupportedDevice: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_DeniedErrorDetails.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_DeniedErrorDetails.Code] = [
    .unspecified,
    .tooManyFreeAccountsForPhoneNumber,
    .tooManyFreeAccountsForDevice,
    .unsupportedCountry,
    .unsupportedDevice,
  ]
}

#endif  // swift(>=4.2)

/// UpgradeableIntent is an intent whose actions can be upgraded.
public struct Code_Transaction_V2_UpgradeableIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID
  public var id: Code_Common_V1_IntentId {
    get {return _id ?? Code_Common_V1_IntentId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The set of private actions that can be upgraded
  public var actions: [Code_Transaction_V2_UpgradeableIntent.UpgradeablePrivateAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct UpgradeablePrivateAction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The transaction blob that was signed by the client. Clients *MUST* use
    /// the source and destination account in the timelock::TransferWithAuthority
    /// instruction to validate all fields provided by server by locally computing
    /// the expected addresses.
    public var transactionBlob: Code_Common_V1_Transaction {
      get {return _transactionBlob ?? Code_Common_V1_Transaction()}
      set {_transactionBlob = newValue}
    }
    /// Returns true if `transactionBlob` has been explicitly set.
    public var hasTransactionBlob: Bool {return self._transactionBlob != nil}
    /// Clears the value of `transactionBlob`. Subsequent reads from it will return its default value.
    public mutating func clearTransactionBlob() {self._transactionBlob = nil}

    /// The client's signature for the transaction. Clients MUST use this to
    /// locally validate the transaction blob provided by server.
    public var clientSignature: Code_Common_V1_Signature {
      get {return _clientSignature ?? Code_Common_V1_Signature()}
      set {_clientSignature = newValue}
    }
    /// Returns true if `clientSignature` has been explicitly set.
    public var hasClientSignature: Bool {return self._clientSignature != nil}
    /// Clears the value of `clientSignature`. Subsequent reads from it will return its default value.
    public mutating func clearClientSignature() {self._clientSignature = nil}

    /// The action ID of this transaction
    public var actionID: UInt32 = 0

    /// The source account's type, which hints how to efficiently derive source
    public var sourceAccountType: Code_Common_V1_AccountType = .unknown

    /// The source account's derivation index, which hints how to efficiently derive source
    public var sourceDerivationIndex: UInt64 = 0

    /// The original destination account that was paid by the treasury
    public var originalDestination: Code_Common_V1_SolanaAccountId {
      get {return _originalDestination ?? Code_Common_V1_SolanaAccountId()}
      set {_originalDestination = newValue}
    }
    /// Returns true if `originalDestination` has been explicitly set.
    public var hasOriginalDestination: Bool {return self._originalDestination != nil}
    /// Clears the value of `originalDestination`. Subsequent reads from it will return its default value.
    public mutating func clearOriginalDestination() {self._originalDestination = nil}

    /// The original quark amount for the action
    public var originalAmount: UInt64 = 0

    /// The treasury used for this the private action
    public var treasury: Code_Common_V1_SolanaAccountId {
      get {return _treasury ?? Code_Common_V1_SolanaAccountId()}
      set {_treasury = newValue}
    }
    /// Returns true if `treasury` has been explicitly set.
    public var hasTreasury: Bool {return self._treasury != nil}
    /// Clears the value of `treasury`. Subsequent reads from it will return its default value.
    public mutating func clearTreasury() {self._treasury = nil}

    /// The recent root observed at the time of intent creation for this private action
    public var recentRoot: Code_Common_V1_Hash {
      get {return _recentRoot ?? Code_Common_V1_Hash()}
      set {_recentRoot = newValue}
    }
    /// Returns true if `recentRoot` has been explicitly set.
    public var hasRecentRoot: Bool {return self._recentRoot != nil}
    /// Clears the value of `recentRoot`. Subsequent reads from it will return its default value.
    public mutating func clearRecentRoot() {self._recentRoot = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _transactionBlob: Code_Common_V1_Transaction? = nil
    fileprivate var _clientSignature: Code_Common_V1_Signature? = nil
    fileprivate var _originalDestination: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _treasury: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _recentRoot: Code_Common_V1_Hash? = nil
  }

  public init() {}

  fileprivate var _id: Code_Common_V1_IntentId? = nil
}

public struct Code_Transaction_V2_PaymentHistoryItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cursor position of this item.
  public var cursor: Code_Transaction_V2_Cursor {
    get {return _cursor ?? Code_Transaction_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  /// Exchange data related to the payment
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// Is this payment a send or receive?
  public var paymentType: Code_Transaction_V2_PaymentHistoryItem.PaymentType = .unknown

  /// If the payment was a SEND, was it a withdraw?
  public var isWithdraw: Bool = false

  /// If the payment was a RECEIVE, was it a deposit?
  public var isDeposit: Bool = false

  /// The timestamp of the payment
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Was the payment involved in a remote send?
  public var isRemoteSend: Bool = false

  /// If payment_type is RECEIVE and is_remote_send is true, was the funds being
  /// returned back to the issuer?
  public var isReturned: Bool = false

  /// If payment_type is RECEIVE, is this receive an airdrop part of a reward, incentive, etc.?
  public var isAirdrop: Bool = false

  /// If is_airdrop is true, the type of airdrop received.
  public var airdropType: Code_Transaction_V2_AirdropType = .unknown

  /// Is this a micro payment? 
  public var isMicroPayment: Bool = false

  /// The intent ID associated with this history item
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PaymentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case send // = 1
    case receive // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .send
      case 2: self = .receive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .send: return 1
      case .receive: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _cursor: Code_Transaction_V2_Cursor? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_PaymentHistoryItem.PaymentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_PaymentHistoryItem.PaymentType] = [
    .unknown,
    .send,
    .receive,
  ]
}

#endif  // swift(>=4.2)

/// ExchangeData defines an amount of Kin with currency exchange data
public struct Code_Transaction_V2_ExchangeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon exchange rate. This might not be the same as the
  /// actual exchange rate at the time of intent or fund transfer.
  public var exchangeRate: Double = 0

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  /// The exact amount of quarks to send. This will be used as the source of
  /// truth for validating transaction transfer amounts.
  public var quarks: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_ExchangeDataWithoutRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_AdditionalFeePayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination Kin token account where the fee payment will be made
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// Fee percentage, in basis points, of the total quark amount of a payment.
  public var feeBps: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_SendLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remaining limit to apply on the next transaction
  public var nextTransaction: Float = 0

  /// Maximum allowed on a per-transaction basis
  public var maxPerTransaction: Float = 0

  /// Maximum allowed on a per-day basis
  public var maxPerDay: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_DepositLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum quarks that may be deposited at any time. Server will guarantee
  /// this threshold will be below enforced dollar value limits, while also
  /// ensuring sufficient funds are available for a full organizer that supports
  /// max payment sends. Total dollar value limits may be spread across many deposits.
  public var maxQuarks: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_MicroPaymentLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum native amount that can be applied per micro payment transaction
  public var maxPerTransaction: Float = 0

  /// Minimum native amount that can be applied per micro payment transaction
  public var minPerTransaction: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_BuyModuleLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum amount that can be purchased through the buy module
  public var minPerTransaction: Float = 0

  /// Maximum amount that can be purchased through the buy module
  public var maxPerTransaction: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_TippedUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platform: Code_Transaction_V2_TippedUser.Platform = .unknown

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Platform: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case twitter // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .twitter
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .twitter: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_TippedUser.Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_TippedUser.Platform] = [
    .unknown,
    .twitter,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Transaction_V2_AirdropType: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.OneOf_Request: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.SubmitActions: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.OneOf_Response: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.ServerParameters: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Success: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Error: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrivacyUpgradeStatusRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Status: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_GetPaymentHistoryRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetPaymentHistoryRequest.Direction: @unchecked Sendable {}
extension Code_Transaction_V2_GetPaymentHistoryResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetPaymentHistoryResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountRequest: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountResponse: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropRequest: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropResponse: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.OneOf_Request: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.Initiate: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.SubmitSignature: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.OneOf_Response: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.ServerParameters: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Success: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Success.Code: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Error: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Error.Code: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_Metadata: @unchecked Sendable {}
extension Code_Transaction_V2_Metadata.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountsMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_SendPrivatePaymentMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_SendPublicPaymentMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_ReceivePaymentsPubliclyMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_UpgradePrivacyMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_MigrateToPrivacy2022Metadata: @unchecked Sendable {}
extension Code_Transaction_V2_EstablishRelationshipMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_Action: @unchecked Sendable {}
extension Code_Transaction_V2_Action.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountAction: @unchecked Sendable {}
extension Code_Transaction_V2_CloseEmptyAccountAction: @unchecked Sendable {}
extension Code_Transaction_V2_CloseDormantAccountAction: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyTransferAction: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyWithdrawAction: @unchecked Sendable {}
extension Code_Transaction_V2_TemporaryPrivacyTransferAction: @unchecked Sendable {}
extension Code_Transaction_V2_TemporaryPrivacyExchangeAction: @unchecked Sendable {}
extension Code_Transaction_V2_PermanentPrivacyUpgradeAction: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentAction: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentAction.FeeType: @unchecked Sendable {}
extension Code_Transaction_V2_ServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_ServerParameter.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_NoncedTransactionMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_CloseEmptyAccountServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_CloseDormantAccountServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyTransferServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyWithdrawServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_TemporaryPrivacyTransferServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_ErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_ErrorDetails.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_ReasonStringErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_InvalidSignatureErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_DeniedErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_DeniedErrorDetails.Code: @unchecked Sendable {}
extension Code_Transaction_V2_UpgradeableIntent: @unchecked Sendable {}
extension Code_Transaction_V2_UpgradeableIntent.UpgradeablePrivateAction: @unchecked Sendable {}
extension Code_Transaction_V2_PaymentHistoryItem: @unchecked Sendable {}
extension Code_Transaction_V2_PaymentHistoryItem.PaymentType: @unchecked Sendable {}
extension Code_Transaction_V2_ExchangeData: @unchecked Sendable {}
extension Code_Transaction_V2_ExchangeDataWithoutRate: @unchecked Sendable {}
extension Code_Transaction_V2_AdditionalFeePayment: @unchecked Sendable {}
extension Code_Transaction_V2_SendLimit: @unchecked Sendable {}
extension Code_Transaction_V2_DepositLimit: @unchecked Sendable {}
extension Code_Transaction_V2_MicroPaymentLimit: @unchecked Sendable {}
extension Code_Transaction_V2_BuyModuleLimit: @unchecked Sendable {}
extension Code_Transaction_V2_TippedUser: @unchecked Sendable {}
extension Code_Transaction_V2_TippedUser.Platform: @unchecked Sendable {}
extension Code_Transaction_V2_Cursor: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.transaction.v2"

extension Code_Transaction_V2_AirdropType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GIVE_FIRST_KIN"),
    2: .same(proto: "GET_FIRST_KIN"),
  ]
}

extension Code_Transaction_V2_SubmitIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "submit_actions"),
    2: .standard(proto: "submit_signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SubmitIntentRequest.SubmitActions?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitActions(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignatures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignatures(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .submitActions?: try {
      guard case .submitActions(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignatures?: try {
      guard case .submitSignatures(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest, rhs: Code_Transaction_V2_SubmitIntentRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentRequest.SubmitActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentRequest.protoMessageName + ".SubmitActions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "owner"),
    3: .same(proto: "metadata"),
    4: .same(proto: "actions"),
    5: .same(proto: "signature"),
    6: .standard(proto: "device_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deviceToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deviceToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.SubmitActions, rhs: Code_Transaction_V2_SubmitIntentRequest.SubmitActions) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._deviceToken != rhs._deviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentRequest.protoMessageName + ".SubmitSignatures"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures, rhs: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse, rhs: Code_Transaction_V2_SubmitIntentResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serverParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverParameters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.ServerParameters, rhs: Code_Transaction_V2_SubmitIntentResponse.ServerParameters) -> Bool {
    if lhs.serverParameters != rhs.serverParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.Success, rhs: Code_Transaction_V2_SubmitIntentResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Code_Transaction_V2_SubmitIntentResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "error_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.Error, rhs: Code_Transaction_V2_SubmitIntentResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
    1: .same(proto: "INVALID_INTENT"),
    2: .same(proto: "SIGNATURE_ERROR"),
    3: .same(proto: "STALE_STATE"),
  ]
}

extension Code_Transaction_V2_GetIntentMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetIntentMetadataRequest, rhs: Code_Transaction_V2_GetIntentMetadataRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetIntentMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetIntentMetadataResponse, rhs: Code_Transaction_V2_GetIntentMetadataResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetIntentMetadataResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Transaction_V2_GetPrivacyUpgradeStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrivacyUpgradeStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .standard(proto: "action_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPrivacyUpgradeStatusRequest, rhs: Code_Transaction_V2_GetPrivacyUpgradeStatusRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrivacyUpgradeStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPrivacyUpgradeStatusResponse, rhs: Code_Transaction_V2_GetPrivacyUpgradeStatusResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INTENT_NOT_FOUND"),
    2: .same(proto: "ACTION_NOT_FOUND"),
    3: .same(proto: "INVALID_ACTION"),
  ]
}

extension Code_Transaction_V2_GetPrivacyUpgradeStatusResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TEMPORARY_TRANSACTION_FINALIZED"),
    2: .same(proto: "WAITING_FOR_NEXT_BLOCK"),
    3: .same(proto: "READY_FOR_UPGRADE"),
    4: .same(proto: "ALREADY_UPGRADED"),
  ]
}

extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrioritizedIntentsForPrivacyUpgradeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "limit"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeRequest, rhs: Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrioritizedIntentsForPrivacyUpgradeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse, rhs: Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPrioritizedIntentsForPrivacyUpgradeResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Transaction_V2_GetLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "consumed_since"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumedSince) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._consumedSince {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetLimitsRequest, rhs: Code_Transaction_V2_GetLimitsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._consumedSince != rhs._consumedSince {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "send_limits_by_currency"),
    3: .standard(proto: "deposit_limit"),
    4: .standard(proto: "micro_payment_limits_by_currency"),
    5: .standard(proto: "buy_module_limits_by_currency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_SendLimit>.self, value: &self.sendLimitsByCurrency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._depositLimit) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_MicroPaymentLimit>.self, value: &self.microPaymentLimitsByCurrency) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_BuyModuleLimit>.self, value: &self.buyModuleLimitsByCurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.sendLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_SendLimit>.self, value: self.sendLimitsByCurrency, fieldNumber: 2)
    }
    try { if let v = self._depositLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.microPaymentLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_MicroPaymentLimit>.self, value: self.microPaymentLimitsByCurrency, fieldNumber: 4)
    }
    if !self.buyModuleLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_BuyModuleLimit>.self, value: self.buyModuleLimitsByCurrency, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetLimitsResponse, rhs: Code_Transaction_V2_GetLimitsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.sendLimitsByCurrency != rhs.sendLimitsByCurrency {return false}
    if lhs._depositLimit != rhs._depositLimit {return false}
    if lhs.microPaymentLimitsByCurrency != rhs.microPaymentLimitsByCurrency {return false}
    if lhs.buyModuleLimitsByCurrency != rhs.buyModuleLimitsByCurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetLimitsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Code_Transaction_V2_GetPaymentHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPaymentHistoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "cursor"),
    3: .standard(proto: "page_size"),
    4: .same(proto: "direction"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPaymentHistoryRequest, rhs: Code_Transaction_V2_GetPaymentHistoryRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPaymentHistoryRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Transaction_V2_GetPaymentHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPaymentHistoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetPaymentHistoryResponse, rhs: Code_Transaction_V2_GetPaymentHistoryResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetPaymentHistoryResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Transaction_V2_CanWithdrawToAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CanWithdrawToAccountRequest, rhs: Code_Transaction_V2_CanWithdrawToAccountRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CanWithdrawToAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "account_type"),
    1: .standard(proto: "is_valid_payment_destination"),
    3: .standard(proto: "requires_initialization"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValidPaymentDestination) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requiresInitialization) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isValidPaymentDestination != false {
      try visitor.visitSingularBoolField(value: self.isValidPaymentDestination, fieldNumber: 1)
    }
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 2)
    }
    if self.requiresInitialization != false {
      try visitor.visitSingularBoolField(value: self.requiresInitialization, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CanWithdrawToAccountResponse, rhs: Code_Transaction_V2_CanWithdrawToAccountResponse) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs.isValidPaymentDestination != rhs.isValidPaymentDestination {return false}
    if lhs.requiresInitialization != rhs.requiresInitialization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "TokenAccount"),
    2: .same(proto: "OwnerAccount"),
  ]
}

extension Code_Transaction_V2_AirdropRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "airdrop_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.airdropType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.airdropType != .unknown {
      try visitor.visitSingularEnumField(value: self.airdropType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AirdropRequest, rhs: Code_Transaction_V2_AirdropRequest) -> Bool {
    if lhs.airdropType != rhs.airdropType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AirdropResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "exchange_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AirdropResponse, rhs: Code_Transaction_V2_AirdropResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AirdropResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "UNAVAILABLE"),
    2: .same(proto: "ALREADY_CLAIMED"),
  ]
}

extension Code_Transaction_V2_SwapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initiate"),
    2: .standard(proto: "submit_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SwapRequest.Initiate?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initiate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initiate(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SwapRequest.SubmitSignature?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initiate?: try {
      guard case .initiate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignature?: try {
      guard case .submitSignature(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest, rhs: Code_Transaction_V2_SwapRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapRequest.Initiate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapRequest.protoMessageName + ".Initiate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "swap_authority"),
    3: .same(proto: "limit"),
    4: .standard(proto: "wait_for_blockchain_status"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swapAuthority) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.waitForBlockchainStatus) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._swapAuthority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 3)
    }
    if self.waitForBlockchainStatus != false {
      try visitor.visitSingularBoolField(value: self.waitForBlockchainStatus, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest.Initiate, rhs: Code_Transaction_V2_SwapRequest.Initiate) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._swapAuthority != rhs._swapAuthority {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.waitForBlockchainStatus != rhs.waitForBlockchainStatus {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapRequest.SubmitSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapRequest.protoMessageName + ".SubmitSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest.SubmitSignature, rhs: Code_Transaction_V2_SwapRequest.SubmitSignature) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SwapResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SwapResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_SwapResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse, rhs: Code_Transaction_V2_SwapResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payer"),
    2: .standard(proto: "recent_blockhash"),
    3: .standard(proto: "compute_unit_limit"),
    4: .standard(proto: "compute_unit_price"),
    5: .standard(proto: "swap_program"),
    6: .standard(proto: "swap_ixn_accounts"),
    7: .standard(proto: "swap_ixn_data"),
    8: .standard(proto: "max_to_send"),
    9: .standard(proto: "min_to_receive"),
    10: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recentBlockhash) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.computeUnitLimit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.computeUnitPrice) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._swapProgram) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.swapIxnAccounts) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.swapIxnData) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.maxToSend) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.minToReceive) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recentBlockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.computeUnitLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.computeUnitLimit, fieldNumber: 3)
    }
    if self.computeUnitPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeUnitPrice, fieldNumber: 4)
    }
    try { if let v = self._swapProgram {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.swapIxnAccounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.swapIxnAccounts, fieldNumber: 6)
    }
    if !self.swapIxnData.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapIxnData, fieldNumber: 7)
    }
    if self.maxToSend != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxToSend, fieldNumber: 8)
    }
    if self.minToReceive != 0 {
      try visitor.visitSingularUInt64Field(value: self.minToReceive, fieldNumber: 9)
    }
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.ServerParameters, rhs: Code_Transaction_V2_SwapResponse.ServerParameters) -> Bool {
    if lhs._payer != rhs._payer {return false}
    if lhs._recentBlockhash != rhs._recentBlockhash {return false}
    if lhs.computeUnitLimit != rhs.computeUnitLimit {return false}
    if lhs.computeUnitPrice != rhs.computeUnitPrice {return false}
    if lhs._swapProgram != rhs._swapProgram {return false}
    if lhs.swapIxnAccounts != rhs.swapIxnAccounts {return false}
    if lhs.swapIxnData != rhs.swapIxnData {return false}
    if lhs.maxToSend != rhs.maxToSend {return false}
    if lhs.minToReceive != rhs.minToReceive {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .swapSubmitted {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.Success, rhs: Code_Transaction_V2_SwapResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SWAP_SUBMITTED"),
    1: .same(proto: "SWAP_FINALIZED"),
  ]
}

extension Code_Transaction_V2_SwapResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "error_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.Error, rhs: Code_Transaction_V2_SwapResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
    2: .same(proto: "SIGNATURE_ERROR"),
    3: .same(proto: "INVALID_SWAP"),
    4: .same(proto: "SWAP_FAILED"),
  ]
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareFiatOnrampPurchaseAttemptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "purchase_amount"),
    3: .same(proto: "nonce"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._purchaseAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._purchaseAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest, rhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._purchaseAmount != rhs._purchaseAmount {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareFiatOnrampPurchaseAttemptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse, rhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_OWNER"),
    2: .same(proto: "UNSUPPORTED_CURRENCY"),
    3: .same(proto: "AMOUNT_EXCEEDS_MAXIMUM"),
  ]
}

extension Code_Transaction_V2_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_accounts"),
    2: .standard(proto: "send_private_payment"),
    3: .standard(proto: "receive_payments_privately"),
    4: .standard(proto: "upgrade_privacy"),
    5: .standard(proto: "migrate_to_privacy_2022"),
    6: .standard(proto: "send_public_payment"),
    7: .standard(proto: "receive_payments_publicly"),
    8: .standard(proto: "establish_relationship"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_OpenAccountsMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccounts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccounts(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SendPrivatePaymentMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sendPrivatePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sendPrivatePayment(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .receivePaymentsPrivately(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .receivePaymentsPrivately(v)
        }
      }()
      case 4: try {
        var v: Code_Transaction_V2_UpgradePrivacyMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .upgradePrivacy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .upgradePrivacy(v)
        }
      }()
      case 5: try {
        var v: Code_Transaction_V2_MigrateToPrivacy2022Metadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .migrateToPrivacy2022(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .migrateToPrivacy2022(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_SendPublicPaymentMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sendPublicPayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sendPublicPayment(v)
        }
      }()
      case 7: try {
        var v: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .receivePaymentsPublicly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .receivePaymentsPublicly(v)
        }
      }()
      case 8: try {
        var v: Code_Transaction_V2_EstablishRelationshipMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .establishRelationship(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .establishRelationship(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .openAccounts?: try {
      guard case .openAccounts(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendPrivatePayment?: try {
      guard case .sendPrivatePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .receivePaymentsPrivately?: try {
      guard case .receivePaymentsPrivately(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .upgradePrivacy?: try {
      guard case .upgradePrivacy(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .migrateToPrivacy2022?: try {
      guard case .migrateToPrivacy2022(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sendPublicPayment?: try {
      guard case .sendPublicPayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .receivePaymentsPublicly?: try {
      guard case .receivePaymentsPublicly(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .establishRelationship?: try {
      guard case .establishRelationship(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Metadata, rhs: Code_Transaction_V2_Metadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountsMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountsMetadata, rhs: Code_Transaction_V2_OpenAccountsMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SendPrivatePaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPrivatePaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "exchange_data"),
    3: .standard(proto: "is_withdrawal"),
    4: .standard(proto: "is_remote_send"),
    5: .standard(proto: "is_tip"),
    6: .standard(proto: "tipped_user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isWithdrawal) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isTip) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._tippedUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isWithdrawal != false {
      try visitor.visitSingularBoolField(value: self.isWithdrawal, fieldNumber: 3)
    }
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 4)
    }
    if self.isTip != false {
      try visitor.visitSingularBoolField(value: self.isTip, fieldNumber: 5)
    }
    try { if let v = self._tippedUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SendPrivatePaymentMetadata, rhs: Code_Transaction_V2_SendPrivatePaymentMetadata) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.isWithdrawal != rhs.isWithdrawal {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs.isTip != rhs.isTip {return false}
    if lhs._tippedUser != rhs._tippedUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SendPublicPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPublicPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "source"),
    1: .same(proto: "destination"),
    2: .standard(proto: "exchange_data"),
    3: .standard(proto: "is_withdrawal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isWithdrawal) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isWithdrawal != false {
      try visitor.visitSingularBoolField(value: self.isWithdrawal, fieldNumber: 3)
    }
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SendPublicPaymentMetadata, rhs: Code_Transaction_V2_SendPublicPaymentMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.isWithdrawal != rhs.isWithdrawal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivePaymentsPrivatelyMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "quarks"),
    3: .standard(proto: "is_deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isDeposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 2)
    }
    if self.isDeposit != false {
      try visitor.visitSingularBoolField(value: self.isDeposit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata, rhs: Code_Transaction_V2_ReceivePaymentsPrivatelyMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.isDeposit != rhs.isDeposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ReceivePaymentsPubliclyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivePaymentsPubliclyMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "quarks"),
    3: .standard(proto: "is_remote_send"),
    4: .standard(proto: "is_issuer_voiding_gift_card"),
    5: .standard(proto: "exchange_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isIssuerVoidingGiftCard) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 2)
    }
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 3)
    }
    if self.isIssuerVoidingGiftCard != false {
      try visitor.visitSingularBoolField(value: self.isIssuerVoidingGiftCard, fieldNumber: 4)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata, rhs: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs.isIssuerVoidingGiftCard != rhs.isIssuerVoidingGiftCard {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_UpgradePrivacyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradePrivacyMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_UpgradePrivacyMetadata, rhs: Code_Transaction_V2_UpgradePrivacyMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_MigrateToPrivacy2022Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MigrateToPrivacy2022Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quarks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_MigrateToPrivacy2022Metadata, rhs: Code_Transaction_V2_MigrateToPrivacy2022Metadata) -> Bool {
    if lhs.quarks != rhs.quarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_EstablishRelationshipMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstablishRelationshipMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relationship"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._relationship) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._relationship {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_EstablishRelationshipMetadata, rhs: Code_Transaction_V2_EstablishRelationshipMetadata) -> Bool {
    if lhs._relationship != rhs._relationship {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "open_account"),
    3: .standard(proto: "close_empty_account"),
    4: .standard(proto: "close_dormant_account"),
    5: .standard(proto: "no_privacy_transfer"),
    6: .standard(proto: "no_privacy_withdraw"),
    7: .standard(proto: "temporary_privacy_transfer"),
    8: .standard(proto: "temporary_privacy_exchange"),
    9: .standard(proto: "permanent_privacy_upgrade"),
    10: .standard(proto: "fee_payment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Code_Transaction_V2_OpenAccountAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_CloseEmptyAccountAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .closeEmptyAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .closeEmptyAccount(v)
        }
      }()
      case 4: try {
        var v: Code_Transaction_V2_CloseDormantAccountAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .closeDormantAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .closeDormantAccount(v)
        }
      }()
      case 5: try {
        var v: Code_Transaction_V2_NoPrivacyTransferAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_NoPrivacyWithdrawAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 7: try {
        var v: Code_Transaction_V2_TemporaryPrivacyTransferAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .temporaryPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .temporaryPrivacyTransfer(v)
        }
      }()
      case 8: try {
        var v: Code_Transaction_V2_TemporaryPrivacyExchangeAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .temporaryPrivacyExchange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .temporaryPrivacyExchange(v)
        }
      }()
      case 9: try {
        var v: Code_Transaction_V2_PermanentPrivacyUpgradeAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .permanentPrivacyUpgrade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .permanentPrivacyUpgrade(v)
        }
      }()
      case 10: try {
        var v: Code_Transaction_V2_FeePaymentAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .closeEmptyAccount?: try {
      guard case .closeEmptyAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .closeDormantAccount?: try {
      guard case .closeDormantAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .temporaryPrivacyTransfer?: try {
      guard case .temporaryPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .temporaryPrivacyExchange?: try {
      guard case .temporaryPrivacyExchange(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .permanentPrivacyUpgrade?: try {
      guard case .permanentPrivacyUpgrade(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Action, rhs: Code_Transaction_V2_Action) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "index"),
    4: .same(proto: "authority"),
    5: .same(proto: "token"),
    6: .standard(proto: "authority_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._authoritySignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 3)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._authoritySignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountAction, rhs: Code_Transaction_V2_OpenAccountAction) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.index != rhs.index {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._token != rhs._token {return false}
    if lhs._authoritySignature != rhs._authoritySignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CloseEmptyAccountAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseEmptyAccountAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_type"),
    2: .same(proto: "authority"),
    3: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 1)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CloseEmptyAccountAction, rhs: Code_Transaction_V2_CloseEmptyAccountAction) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CloseDormantAccountAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseDormantAccountAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_type"),
    2: .same(proto: "authority"),
    3: .same(proto: "token"),
    4: .same(proto: "destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 1)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CloseDormantAccountAction, rhs: Code_Transaction_V2_CloseDormantAccountAction) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._token != rhs._token {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyTransferAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyTransferAction, rhs: Code_Transaction_V2_NoPrivacyTransferAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyWithdrawAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
    5: .standard(proto: "should_close"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.shouldClose) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if self.shouldClose != false {
      try visitor.visitSingularBoolField(value: self.shouldClose, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyWithdrawAction, rhs: Code_Transaction_V2_NoPrivacyWithdrawAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.shouldClose != rhs.shouldClose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TemporaryPrivacyTransferAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemporaryPrivacyTransferAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_TemporaryPrivacyTransferAction, rhs: Code_Transaction_V2_TemporaryPrivacyTransferAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TemporaryPrivacyExchangeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemporaryPrivacyExchangeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_TemporaryPrivacyExchangeAction, rhs: Code_Transaction_V2_TemporaryPrivacyExchangeAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_PermanentPrivacyUpgradeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermanentPrivacyUpgradeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_PermanentPrivacyUpgradeAction, rhs: Code_Transaction_V2_PermanentPrivacyUpgradeAction) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "type"),
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "amount"),
    5: .same(proto: "destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.type != .code {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_FeePaymentAction, rhs: Code_Transaction_V2_FeePaymentAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentAction.FeeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODE"),
    1: .same(proto: "THIRD_PARTY"),
  ]
}

extension Code_Transaction_V2_ServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_id"),
    2: .same(proto: "nonces"),
    3: .standard(proto: "open_account"),
    4: .standard(proto: "close_empty_account"),
    5: .standard(proto: "close_dormant_account"),
    6: .standard(proto: "no_privacy_transfer"),
    7: .standard(proto: "no_privacy_withdraw"),
    8: .standard(proto: "temporary_privacy_transfer"),
    9: .standard(proto: "temporary_privacy_exchange"),
    10: .standard(proto: "permanent_privacy_upgrade"),
    11: .standard(proto: "fee_payment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nonces) }()
      case 3: try {
        var v: Code_Transaction_V2_OpenAccountServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 4: try {
        var v: Code_Transaction_V2_CloseEmptyAccountServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .closeEmptyAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .closeEmptyAccount(v)
        }
      }()
      case 5: try {
        var v: Code_Transaction_V2_CloseDormantAccountServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .closeDormantAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .closeDormantAccount(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_NoPrivacyTransferServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 7: try {
        var v: Code_Transaction_V2_NoPrivacyWithdrawServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 8: try {
        var v: Code_Transaction_V2_TemporaryPrivacyTransferServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .temporaryPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .temporaryPrivacyTransfer(v)
        }
      }()
      case 9: try {
        var v: Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .temporaryPrivacyExchange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .temporaryPrivacyExchange(v)
        }
      }()
      case 10: try {
        var v: Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .permanentPrivacyUpgrade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .permanentPrivacyUpgrade(v)
        }
      }()
      case 11: try {
        var v: Code_Transaction_V2_FeePaymentServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    if !self.nonces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonces, fieldNumber: 2)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .closeEmptyAccount?: try {
      guard case .closeEmptyAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .closeDormantAccount?: try {
      guard case .closeDormantAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .temporaryPrivacyTransfer?: try {
      guard case .temporaryPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .temporaryPrivacyExchange?: try {
      guard case .temporaryPrivacyExchange(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .permanentPrivacyUpgrade?: try {
      guard case .permanentPrivacyUpgrade(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ServerParameter, rhs: Code_Transaction_V2_ServerParameter) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.nonces != rhs.nonces {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoncedTransactionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoncedTransactionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "blockhash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockhash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoncedTransactionMetadata, rhs: Code_Transaction_V2_NoncedTransactionMetadata) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._blockhash != rhs._blockhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountServerParameter, rhs: Code_Transaction_V2_OpenAccountServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CloseEmptyAccountServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseEmptyAccountServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CloseEmptyAccountServerParameter, rhs: Code_Transaction_V2_CloseEmptyAccountServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CloseDormantAccountServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseDormantAccountServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CloseDormantAccountServerParameter, rhs: Code_Transaction_V2_CloseDormantAccountServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyTransferServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyTransferServerParameter, rhs: Code_Transaction_V2_NoPrivacyTransferServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyWithdrawServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyWithdrawServerParameter, rhs: Code_Transaction_V2_NoPrivacyWithdrawServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TemporaryPrivacyTransferServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemporaryPrivacyTransferServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "treasury"),
    2: .standard(proto: "recent_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._treasury) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recentRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._treasury {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recentRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_TemporaryPrivacyTransferServerParameter, rhs: Code_Transaction_V2_TemporaryPrivacyTransferServerParameter) -> Bool {
    if lhs._treasury != rhs._treasury {return false}
    if lhs._recentRoot != rhs._recentRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemporaryPrivacyExchangeServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "treasury"),
    2: .standard(proto: "recent_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._treasury) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recentRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._treasury {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recentRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter, rhs: Code_Transaction_V2_TemporaryPrivacyExchangeServerParameter) -> Bool {
    if lhs._treasury != rhs._treasury {return false}
    if lhs._recentRoot != rhs._recentRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermanentPrivacyUpgradeServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_commitment"),
    2: .standard(proto: "new_commitment_transcript"),
    3: .standard(proto: "new_commitment_destination"),
    4: .standard(proto: "new_commitment_amount"),
    5: .standard(proto: "merkle_root"),
    6: .standard(proto: "merkle_proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newCommitment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newCommitmentTranscript) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newCommitmentDestination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.newCommitmentAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._merkleRoot) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.merkleProof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newCommitmentTranscript {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newCommitmentDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.newCommitmentAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.newCommitmentAmount, fieldNumber: 4)
    }
    try { if let v = self._merkleRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.merkleProof.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.merkleProof, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter, rhs: Code_Transaction_V2_PermanentPrivacyUpgradeServerParameter) -> Bool {
    if lhs._newCommitment != rhs._newCommitment {return false}
    if lhs._newCommitmentTranscript != rhs._newCommitmentTranscript {return false}
    if lhs._newCommitmentDestination != rhs._newCommitmentDestination {return false}
    if lhs.newCommitmentAmount != rhs.newCommitmentAmount {return false}
    if lhs._merkleRoot != rhs._merkleRoot {return false}
    if lhs.merkleProof != rhs.merkleProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._codeDestination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._codeDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_FeePaymentServerParameter, rhs: Code_Transaction_V2_FeePaymentServerParameter) -> Bool {
    if lhs._codeDestination != rhs._codeDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reason_string"),
    2: .standard(proto: "invalid_signature"),
    3: .same(proto: "denied"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_ReasonStringErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reasonString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reasonString(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_InvalidSignatureErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .invalidSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .invalidSignature(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_DeniedErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .denied(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .denied(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .reasonString?: try {
      guard case .reasonString(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .invalidSignature?: try {
      guard case .invalidSignature(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .denied?: try {
      guard case .denied(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ErrorDetails, rhs: Code_Transaction_V2_ErrorDetails) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ReasonStringErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReasonStringErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ReasonStringErrorDetails, rhs: Code_Transaction_V2_ReasonStringErrorDetails) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_InvalidSignatureErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvalidSignatureErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_id"),
    2: .standard(proto: "expected_transaction"),
    3: .standard(proto: "provided_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expectedTransaction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._providedSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    try { if let v = self._expectedTransaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._providedSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_InvalidSignatureErrorDetails, rhs: Code_Transaction_V2_InvalidSignatureErrorDetails) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs._expectedTransaction != rhs._expectedTransaction {return false}
    if lhs._providedSignature != rhs._providedSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeniedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeniedErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeniedErrorDetails, rhs: Code_Transaction_V2_DeniedErrorDetails) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeniedErrorDetails.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "TOO_MANY_FREE_ACCOUNTS_FOR_PHONE_NUMBER"),
    2: .same(proto: "TOO_MANY_FREE_ACCOUNTS_FOR_DEVICE"),
    3: .same(proto: "UNSUPPORTED_COUNTRY"),
    4: .same(proto: "UNSUPPORTED_DEVICE"),
  ]
}

extension Code_Transaction_V2_UpgradeableIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeableIntent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_UpgradeableIntent, rhs: Code_Transaction_V2_UpgradeableIntent) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_UpgradeableIntent.UpgradeablePrivateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_UpgradeableIntent.protoMessageName + ".UpgradeablePrivateAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_blob"),
    2: .standard(proto: "client_signature"),
    3: .standard(proto: "action_id"),
    4: .standard(proto: "source_account_type"),
    5: .standard(proto: "source_derivation_index"),
    6: .standard(proto: "original_destination"),
    7: .standard(proto: "original_amount"),
    8: .same(proto: "treasury"),
    9: .standard(proto: "recent_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionBlob) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._clientSignature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.sourceAccountType) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sourceDerivationIndex) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._originalDestination) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.originalAmount) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._treasury) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._recentRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionBlob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._clientSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 3)
    }
    if self.sourceAccountType != .unknown {
      try visitor.visitSingularEnumField(value: self.sourceAccountType, fieldNumber: 4)
    }
    if self.sourceDerivationIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.sourceDerivationIndex, fieldNumber: 5)
    }
    try { if let v = self._originalDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.originalAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.originalAmount, fieldNumber: 7)
    }
    try { if let v = self._treasury {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._recentRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_UpgradeableIntent.UpgradeablePrivateAction, rhs: Code_Transaction_V2_UpgradeableIntent.UpgradeablePrivateAction) -> Bool {
    if lhs._transactionBlob != rhs._transactionBlob {return false}
    if lhs._clientSignature != rhs._clientSignature {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.sourceAccountType != rhs.sourceAccountType {return false}
    if lhs.sourceDerivationIndex != rhs.sourceDerivationIndex {return false}
    if lhs._originalDestination != rhs._originalDestination {return false}
    if lhs.originalAmount != rhs.originalAmount {return false}
    if lhs._treasury != rhs._treasury {return false}
    if lhs._recentRoot != rhs._recentRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_PaymentHistoryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentHistoryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .standard(proto: "exchange_data"),
    3: .standard(proto: "payment_type"),
    4: .standard(proto: "is_withdraw"),
    5: .standard(proto: "is_deposit"),
    6: .same(proto: "timestamp"),
    7: .standard(proto: "is_remote_send"),
    8: .standard(proto: "is_returned"),
    9: .standard(proto: "is_airdrop"),
    10: .standard(proto: "airdrop_type"),
    11: .standard(proto: "is_micro_payment"),
    12: .standard(proto: "intent_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.paymentType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isWithdraw) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isDeposit) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isReturned) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isAirdrop) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.airdropType) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isMicroPayment) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.paymentType != .unknown {
      try visitor.visitSingularEnumField(value: self.paymentType, fieldNumber: 3)
    }
    if self.isWithdraw != false {
      try visitor.visitSingularBoolField(value: self.isWithdraw, fieldNumber: 4)
    }
    if self.isDeposit != false {
      try visitor.visitSingularBoolField(value: self.isDeposit, fieldNumber: 5)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 7)
    }
    if self.isReturned != false {
      try visitor.visitSingularBoolField(value: self.isReturned, fieldNumber: 8)
    }
    if self.isAirdrop != false {
      try visitor.visitSingularBoolField(value: self.isAirdrop, fieldNumber: 9)
    }
    if self.airdropType != .unknown {
      try visitor.visitSingularEnumField(value: self.airdropType, fieldNumber: 10)
    }
    if self.isMicroPayment != false {
      try visitor.visitSingularBoolField(value: self.isMicroPayment, fieldNumber: 11)
    }
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_PaymentHistoryItem, rhs: Code_Transaction_V2_PaymentHistoryItem) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.paymentType != rhs.paymentType {return false}
    if lhs.isWithdraw != rhs.isWithdraw {return false}
    if lhs.isDeposit != rhs.isDeposit {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs.isReturned != rhs.isReturned {return false}
    if lhs.isAirdrop != rhs.isAirdrop {return false}
    if lhs.airdropType != rhs.airdropType {return false}
    if lhs.isMicroPayment != rhs.isMicroPayment {return false}
    if lhs._intentID != rhs._intentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_PaymentHistoryItem.PaymentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SEND"),
    2: .same(proto: "RECEIVE"),
  ]
}

extension Code_Transaction_V2_ExchangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "exchange_rate"),
    3: .standard(proto: "native_amount"),
    4: .same(proto: "quarks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.exchangeRate) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.exchangeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.exchangeRate, fieldNumber: 2)
    }
    if self.nativeAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 3)
    }
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ExchangeData, rhs: Code_Transaction_V2_ExchangeData) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ExchangeDataWithoutRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataWithoutRate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "native_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.nativeAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ExchangeDataWithoutRate, rhs: Code_Transaction_V2_ExchangeDataWithoutRate) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AdditionalFeePayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdditionalFeePayment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "fee_bps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.feeBps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.feeBps != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeBps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AdditionalFeePayment, rhs: Code_Transaction_V2_AdditionalFeePayment) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.feeBps != rhs.feeBps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SendLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_transaction"),
    2: .standard(proto: "max_per_transaction"),
    3: .standard(proto: "max_per_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.nextTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxPerDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.nextTransaction, fieldNumber: 1)
    }
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 2)
    }
    if self.maxPerDay != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerDay, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SendLimit, rhs: Code_Transaction_V2_SendLimit) -> Bool {
    if lhs.nextTransaction != rhs.nextTransaction {return false}
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.maxPerDay != rhs.maxPerDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DepositLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_quarks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxQuarks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxQuarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxQuarks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DepositLimit, rhs: Code_Transaction_V2_DepositLimit) -> Bool {
    if lhs.maxQuarks != rhs.maxQuarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_MicroPaymentLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroPaymentLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_per_transaction"),
    2: .standard(proto: "min_per_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.minPerTransaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 1)
    }
    if self.minPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.minPerTransaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_MicroPaymentLimit, rhs: Code_Transaction_V2_MicroPaymentLimit) -> Bool {
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.minPerTransaction != rhs.minPerTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_BuyModuleLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyModuleLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_per_transaction"),
    2: .standard(proto: "max_per_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.minPerTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.minPerTransaction, fieldNumber: 1)
    }
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_BuyModuleLimit, rhs: Code_Transaction_V2_BuyModuleLimit) -> Bool {
    if lhs.minPerTransaction != rhs.minPerTransaction {return false}
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TippedUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TippedUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .unknown {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_TippedUser, rhs: Code_Transaction_V2_TippedUser) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_TippedUser.Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TWITTER"),
  ]
}

extension Code_Transaction_V2_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Cursor, rhs: Code_Transaction_V2_Cursor) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
