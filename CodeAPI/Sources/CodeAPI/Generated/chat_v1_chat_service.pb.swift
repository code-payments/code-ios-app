// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/chat_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Code_Chat_V1_GetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V1_Cursor {
    get {return _cursor ?? Code_Chat_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V1_GetChatsRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V1_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V1_GetChatsRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_GetChatsRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_GetChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V1_GetChatsResponse.Result = .ok

  public var chats: [Code_Chat_V1_ChatMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_GetChatsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_GetChatsResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_GetMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V1_ChatId {
    get {return _chatID ?? Code_Chat_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V1_Cursor {
    get {return _cursor ?? Code_Chat_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V1_GetMessagesRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chatID: Code_Chat_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V1_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V1_GetMessagesRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_GetMessagesRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_GetMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V1_GetMessagesResponse.Result = .ok

  public var messages: [Code_Chat_V1_ChatMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_GetMessagesResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_GetMessagesResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_AdvancePointerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V1_ChatId {
    get {return _chatID ?? Code_Chat_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var pointer: Code_Chat_V1_Pointer {
    get {return _pointer ?? Code_Chat_V1_Pointer()}
    set {_pointer = newValue}
  }
  /// Returns true if `pointer` has been explicitly set.
  public var hasPointer: Bool {return self._pointer != nil}
  /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
  public mutating func clearPointer() {self._pointer = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V1_ChatId? = nil
  fileprivate var _pointer: Code_Chat_V1_Pointer? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V1_AdvancePointerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V1_AdvancePointerResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case chatNotFound // = 1
    case messageNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .chatNotFound
      case 2: self = .messageNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .chatNotFound: return 1
      case .messageNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_AdvancePointerResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_AdvancePointerResponse.Result] = [
    .ok,
    .chatNotFound,
    .messageNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_SetMuteStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V1_ChatId {
    get {return _chatID ?? Code_Chat_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var isMuted: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V1_SetMuteStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V1_SetMuteStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case chatNotFound // = 1
    case cantMute // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .chatNotFound
      case 2: self = .cantMute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .chatNotFound: return 1
      case .cantMute: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_SetMuteStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_SetMuteStateResponse.Result] = [
    .ok,
    .chatNotFound,
    .cantMute,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_SetSubscriptionStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V1_ChatId {
    get {return _chatID ?? Code_Chat_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var isSubscribed: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V1_SetSubscriptionStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V1_SetSubscriptionStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case chatNotFound // = 1
    case cantUnsubscribe // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .chatNotFound
      case 2: self = .cantUnsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .chatNotFound: return 1
      case .cantUnsubscribe: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_SetSubscriptionStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_SetSubscriptionStateResponse.Result] = [
    .ok,
    .chatNotFound,
    .cantUnsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_ChatId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V1_ChatMessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V1_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Code_Chat_V1_Pointer.Kind = .unknown

  public var value: Code_Chat_V1_ChatMessageId {
    get {return _value ?? Code_Chat_V1_ChatMessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case read // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .read: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _value: Code_Chat_V1_ChatMessageId? = nil
}

#if swift(>=4.2)

extension Code_Chat_V1_Pointer.Kind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_Pointer.Kind] = [
    .unknown,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_ChatMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V1_ChatId {
    get {return _chatID ?? Code_Chat_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// Recommended chat title inferred by the type of chat
  public var title: Code_Chat_V1_ChatMetadata.OneOf_Title? = nil

  public var localized: Code_Chat_V1_LocalizedContent {
    get {
      if case .localized(let v)? = title {return v}
      return Code_Chat_V1_LocalizedContent()
    }
    set {title = .localized(newValue)}
  }

  public var domain: Code_Common_V1_Domain {
    get {
      if case .domain(let v)? = title {return v}
      return Code_Common_V1_Domain()
    }
    set {title = .domain(newValue)}
  }

  /// Pointer in the chat indicating the most recently read message by the user
  public var readPointer: Code_Chat_V1_Pointer {
    get {return _readPointer ?? Code_Chat_V1_Pointer()}
    set {_readPointer = newValue}
  }
  /// Returns true if `readPointer` has been explicitly set.
  public var hasReadPointer: Bool {return self._readPointer != nil}
  /// Clears the value of `readPointer`. Subsequent reads from it will return its default value.
  public mutating func clearReadPointer() {self._readPointer = nil}

  /// Estimated number of unread messages in this chat
  public var numUnread: UInt32 = 0

  /// Has the user muted this chat?
  public var isMuted: Bool = false

  /// Is the user subscribed to this chat?
  public var isSubscribed: Bool = false

  /// Can the user mute this chat?
  public var canMute: Bool = false

  /// Can the user unsubscribe from this chat?
  public var canUnsubscribe: Bool = false

  /// Cursor value for this chat for reference in subsequent GetChatsRequest 
  public var cursor: Code_Chat_V1_Cursor {
    get {return _cursor ?? Code_Chat_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  /// Is this a verified chat?
  ///
  /// Note: It's possible to have two chats with the same title, but with
  /// different verification statuses. They should be treated separately.
  public var isVerified: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Recommended chat title inferred by the type of chat
  public enum OneOf_Title: Equatable {
    case localized(Code_Chat_V1_LocalizedContent)
    case domain(Code_Common_V1_Domain)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V1_ChatMetadata.OneOf_Title, rhs: Code_Chat_V1_ChatMetadata.OneOf_Title) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.localized, .localized): return {
        guard case .localized(let l) = lhs, case .localized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.domain, .domain): return {
        guard case .domain(let l) = lhs, case .domain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _chatID: Code_Chat_V1_ChatId? = nil
  fileprivate var _readPointer: Code_Chat_V1_Pointer? = nil
  fileprivate var _cursor: Code_Chat_V1_Cursor? = nil
}

public struct Code_Chat_V1_ChatMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for this message
  public var messageID: Code_Chat_V1_ChatMessageId {
    get {return _messageID ?? Code_Chat_V1_ChatMessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// Timestamp this message was generated at
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// Ordered message content. A message may have more than one piece of content.
  public var content: [Code_Chat_V1_Content] = []

  /// Cursor value for this message for reference in subsequent GetMessagesRequest 
  public var cursor: Code_Chat_V1_Cursor {
    get {return _cursor ?? Code_Chat_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Code_Chat_V1_ChatMessageId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cursor: Code_Chat_V1_Cursor? = nil
}

public struct Code_Chat_V1_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V1_Content.OneOf_Type? = nil

  public var localized: Code_Chat_V1_LocalizedContent {
    get {
      if case .localized(let v)? = type {return v}
      return Code_Chat_V1_LocalizedContent()
    }
    set {type = .localized(newValue)}
  }

  public var exchangeData: Code_Chat_V1_ExchangeDataContent {
    get {
      if case .exchangeData(let v)? = type {return v}
      return Code_Chat_V1_ExchangeDataContent()
    }
    set {type = .exchangeData(newValue)}
  }

  public var naclBox: Code_Chat_V1_NaclBoxEncryptedContent {
    get {
      if case .naclBox(let v)? = type {return v}
      return Code_Chat_V1_NaclBoxEncryptedContent()
    }
    set {type = .naclBox(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case localized(Code_Chat_V1_LocalizedContent)
    case exchangeData(Code_Chat_V1_ExchangeDataContent)
    case naclBox(Code_Chat_V1_NaclBoxEncryptedContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V1_Content.OneOf_Type, rhs: Code_Chat_V1_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.localized, .localized): return {
        guard case .localized(let l) = lhs, case .localized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exchangeData, .exchangeData): return {
        guard case .exchangeData(let l) = lhs, case .exchangeData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.naclBox, .naclBox): return {
        guard case .naclBox(let l) = lhs, case .naclBox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V1_LocalizedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When server-side localization is in place, clients will always see the
  /// localized text.
  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V1_ExchangeDataContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verb: Code_Chat_V1_ExchangeDataContent.Verb = .unknown

  public var exchangeData: Code_Chat_V1_ExchangeDataContent.OneOf_ExchangeData? = nil

  public var exact: Code_Transaction_V2_ExchangeData {
    get {
      if case .exact(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeData()
    }
    set {exchangeData = .exact(newValue)}
  }

  public var partial: Code_Transaction_V2_ExchangeDataWithoutRate {
    get {
      if case .partial(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeDataWithoutRate()
    }
    set {exchangeData = .partial(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ExchangeData: Equatable {
    case exact(Code_Transaction_V2_ExchangeData)
    case partial(Code_Transaction_V2_ExchangeDataWithoutRate)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V1_ExchangeDataContent.OneOf_ExchangeData, rhs: Code_Chat_V1_ExchangeDataContent.OneOf_ExchangeData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exact, .exact): return {
        guard case .exact(let l) = lhs, case .exact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.partial, .partial): return {
        guard case .partial(let l) = lhs, case .partial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Verb: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case gave // = 1
    case received // = 2
    case withdrew // = 3
    case deposited // = 4
    case sent // = 5
    case returned // = 6
    case spent // = 7
    case paid // = 8
    case purchased // = 9
    case receivedTip // = 10
    case sentTip // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .gave
      case 2: self = .received
      case 3: self = .withdrew
      case 4: self = .deposited
      case 5: self = .sent
      case 6: self = .returned
      case 7: self = .spent
      case 8: self = .paid
      case 9: self = .purchased
      case 10: self = .receivedTip
      case 11: self = .sentTip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .gave: return 1
      case .received: return 2
      case .withdrew: return 3
      case .deposited: return 4
      case .sent: return 5
      case .returned: return 6
      case .spent: return 7
      case .paid: return 8
      case .purchased: return 9
      case .receivedTip: return 10
      case .sentTip: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V1_ExchangeDataContent.Verb: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Code_Chat_V1_ExchangeDataContent.Verb] = [
    .unknown,
    .gave,
    .received,
    .withdrew,
    .deposited,
    .sent,
    .returned,
    .spent,
    .paid,
    .purchased,
    .receivedTip,
    .sentTip,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V1_NaclBoxEncryptedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerPublicKey: Code_Common_V1_SolanaAccountId {
    get {return _peerPublicKey ?? Code_Common_V1_SolanaAccountId()}
    set {_peerPublicKey = newValue}
  }
  /// Returns true if `peerPublicKey` has been explicitly set.
  public var hasPeerPublicKey: Bool {return self._peerPublicKey != nil}
  /// Clears the value of `peerPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPeerPublicKey() {self._peerPublicKey = nil}

  public var nonce: Data = Data()

  public var encryptedPayload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerPublicKey: Code_Common_V1_SolanaAccountId? = nil
}

/// Opaque cursor used across paged APIs. Underlying bytes may change as paging
/// strategies evolve.
public struct Code_Chat_V1_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Chat_V1_GetChatsRequest: @unchecked Sendable {}
extension Code_Chat_V1_GetChatsRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V1_GetChatsResponse: @unchecked Sendable {}
extension Code_Chat_V1_GetChatsResponse.Result: @unchecked Sendable {}
extension Code_Chat_V1_GetMessagesRequest: @unchecked Sendable {}
extension Code_Chat_V1_GetMessagesRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V1_GetMessagesResponse: @unchecked Sendable {}
extension Code_Chat_V1_GetMessagesResponse.Result: @unchecked Sendable {}
extension Code_Chat_V1_AdvancePointerRequest: @unchecked Sendable {}
extension Code_Chat_V1_AdvancePointerResponse: @unchecked Sendable {}
extension Code_Chat_V1_AdvancePointerResponse.Result: @unchecked Sendable {}
extension Code_Chat_V1_SetMuteStateRequest: @unchecked Sendable {}
extension Code_Chat_V1_SetMuteStateResponse: @unchecked Sendable {}
extension Code_Chat_V1_SetMuteStateResponse.Result: @unchecked Sendable {}
extension Code_Chat_V1_SetSubscriptionStateRequest: @unchecked Sendable {}
extension Code_Chat_V1_SetSubscriptionStateResponse: @unchecked Sendable {}
extension Code_Chat_V1_SetSubscriptionStateResponse.Result: @unchecked Sendable {}
extension Code_Chat_V1_ChatId: @unchecked Sendable {}
extension Code_Chat_V1_ChatMessageId: @unchecked Sendable {}
extension Code_Chat_V1_Pointer: @unchecked Sendable {}
extension Code_Chat_V1_Pointer.Kind: @unchecked Sendable {}
extension Code_Chat_V1_ChatMetadata: @unchecked Sendable {}
extension Code_Chat_V1_ChatMetadata.OneOf_Title: @unchecked Sendable {}
extension Code_Chat_V1_ChatMessage: @unchecked Sendable {}
extension Code_Chat_V1_Content: @unchecked Sendable {}
extension Code_Chat_V1_Content.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V1_LocalizedContent: @unchecked Sendable {}
extension Code_Chat_V1_ExchangeDataContent: @unchecked Sendable {}
extension Code_Chat_V1_ExchangeDataContent.OneOf_ExchangeData: @unchecked Sendable {}
extension Code_Chat_V1_ExchangeDataContent.Verb: @unchecked Sendable {}
extension Code_Chat_V1_NaclBoxEncryptedContent: @unchecked Sendable {}
extension Code_Chat_V1_Cursor: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.chat.v1"

extension Code_Chat_V1_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "page_size"),
    4: .same(proto: "cursor"),
    5: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_GetChatsRequest, rhs: Code_Chat_V1_GetChatsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_GetChatsRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V1_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_GetChatsResponse, rhs: Code_Chat_V1_GetChatsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_GetChatsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Chat_V1_GetMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
    4: .standard(proto: "page_size"),
    5: .same(proto: "cursor"),
    6: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_GetMessagesRequest, rhs: Code_Chat_V1_GetMessagesRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_GetMessagesRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V1_GetMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_GetMessagesResponse, rhs: Code_Chat_V1_GetMessagesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_GetMessagesResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Chat_V1_AdvancePointerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "pointer"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_AdvancePointerRequest, rhs: Code_Chat_V1_AdvancePointerRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_AdvancePointerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_AdvancePointerResponse, rhs: Code_Chat_V1_AdvancePointerResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_AdvancePointerResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CHAT_NOT_FOUND"),
    2: .same(proto: "MESSAGE_NOT_FOUND"),
  ]
}

extension Code_Chat_V1_SetMuteStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "is_muted"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_SetMuteStateRequest, rhs: Code_Chat_V1_SetMuteStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_SetMuteStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_SetMuteStateResponse, rhs: Code_Chat_V1_SetMuteStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_SetMuteStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CHAT_NOT_FOUND"),
    2: .same(proto: "CANT_MUTE"),
  ]
}

extension Code_Chat_V1_SetSubscriptionStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "is_subscribed"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isSubscribed) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isSubscribed != false {
      try visitor.visitSingularBoolField(value: self.isSubscribed, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_SetSubscriptionStateRequest, rhs: Code_Chat_V1_SetSubscriptionStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.isSubscribed != rhs.isSubscribed {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_SetSubscriptionStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_SetSubscriptionStateResponse, rhs: Code_Chat_V1_SetSubscriptionStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_SetSubscriptionStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CHAT_NOT_FOUND"),
    2: .same(proto: "CANT_UNSUBSCRIBE"),
  ]
}

extension Code_Chat_V1_ChatId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_ChatId, rhs: Code_Chat_V1_ChatId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_ChatMessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_ChatMessageId, rhs: Code_Chat_V1_ChatMessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unknown {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_Pointer, rhs: Code_Chat_V1_Pointer) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_Pointer.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "READ"),
  ]
}

extension Code_Chat_V1_ChatMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "localized"),
    3: .same(proto: "domain"),
    4: .standard(proto: "read_pointer"),
    5: .standard(proto: "num_unread"),
    6: .standard(proto: "is_muted"),
    7: .standard(proto: "is_subscribed"),
    8: .standard(proto: "can_mute"),
    9: .standard(proto: "can_unsubscribe"),
    10: .same(proto: "cursor"),
    11: .standard(proto: "is_verified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try {
        var v: Code_Chat_V1_LocalizedContent?
        var hadOneofValue = false
        if let current = self.title {
          hadOneofValue = true
          if case .localized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.title = .localized(v)
        }
      }()
      case 3: try {
        var v: Code_Common_V1_Domain?
        var hadOneofValue = false
        if let current = self.title {
          hadOneofValue = true
          if case .domain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.title = .domain(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readPointer) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isSubscribed) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.canMute) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.canUnsubscribe) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isVerified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.title {
    case .localized?: try {
      guard case .localized(let v)? = self.title else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .domain?: try {
      guard case .domain(let v)? = self.title else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._readPointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 5)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 6)
    }
    if self.isSubscribed != false {
      try visitor.visitSingularBoolField(value: self.isSubscribed, fieldNumber: 7)
    }
    if self.canMute != false {
      try visitor.visitSingularBoolField(value: self.canMute, fieldNumber: 8)
    }
    if self.canUnsubscribe != false {
      try visitor.visitSingularBoolField(value: self.canUnsubscribe, fieldNumber: 9)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.isVerified != false {
      try visitor.visitSingularBoolField(value: self.isVerified, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_ChatMetadata, rhs: Code_Chat_V1_ChatMetadata) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._readPointer != rhs._readPointer {return false}
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.isSubscribed != rhs.isSubscribed {return false}
    if lhs.canMute != rhs.canMute {return false}
    if lhs.canUnsubscribe != rhs.canUnsubscribe {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.isVerified != rhs.isVerified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_ChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "ts"),
    3: .same(proto: "content"),
    4: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_ChatMessage, rhs: Code_Chat_V1_ChatMessage) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.content != rhs.content {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localized"),
    2: .standard(proto: "exchange_data"),
    3: .standard(proto: "nacl_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V1_LocalizedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localized(v)
        }
      }()
      case 2: try {
        var v: Code_Chat_V1_ExchangeDataContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .exchangeData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .exchangeData(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V1_NaclBoxEncryptedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .naclBox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .naclBox(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .localized?: try {
      guard case .localized(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .exchangeData?: try {
      guard case .exchangeData(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .naclBox?: try {
      guard case .naclBox(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_Content, rhs: Code_Chat_V1_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_LocalizedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_LocalizedContent, rhs: Code_Chat_V1_LocalizedContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_ExchangeDataContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verb"),
    2: .same(proto: "exact"),
    3: .same(proto: "partial"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.verb) }()
      case 2: try {
        var v: Code_Transaction_V2_ExchangeData?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .exact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .exact(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_ExchangeDataWithoutRate?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .partial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .partial(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.verb != .unknown {
      try visitor.visitSingularEnumField(value: self.verb, fieldNumber: 1)
    }
    switch self.exchangeData {
    case .exact?: try {
      guard case .exact(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .partial?: try {
      guard case .partial(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_ExchangeDataContent, rhs: Code_Chat_V1_ExchangeDataContent) -> Bool {
    if lhs.verb != rhs.verb {return false}
    if lhs.exchangeData != rhs.exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_ExchangeDataContent.Verb: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GAVE"),
    2: .same(proto: "RECEIVED"),
    3: .same(proto: "WITHDREW"),
    4: .same(proto: "DEPOSITED"),
    5: .same(proto: "SENT"),
    6: .same(proto: "RETURNED"),
    7: .same(proto: "SPENT"),
    8: .same(proto: "PAID"),
    9: .same(proto: "PURCHASED"),
    10: .same(proto: "RECEIVED_TIP"),
    11: .same(proto: "SENT_TIP"),
  ]
}

extension Code_Chat_V1_NaclBoxEncryptedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NaclBoxEncryptedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_public_key"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "encrypted_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerPublicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedPayload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.encryptedPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedPayload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_NaclBoxEncryptedContent, rhs: Code_Chat_V1_NaclBoxEncryptedContent) -> Bool {
    if lhs._peerPublicKey != rhs._peerPublicKey {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.encryptedPayload != rhs.encryptedPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V1_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V1_Cursor, rhs: Code_Chat_V1_Cursor) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
