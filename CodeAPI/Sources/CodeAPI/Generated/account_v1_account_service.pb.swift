// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: account/v1/account_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Code_Account_V1_IsCodeAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to check against.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(IsCodeAccountRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Account_V1_IsCodeAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Account_V1_IsCodeAccountResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The account is a Code account.
    case ok // = 0

    /// The account is not a Code account.
    case notFound // = 1

    /// The account exists, but at least one timelock account is unlocked.
    case unlockedTimelockAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .unlockedTimelockAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .unlockedTimelockAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Account_V1_IsCodeAccountResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_IsCodeAccountResponse.Result] = [
    .ok,
    .notFound,
    .unlockedTimelockAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Account_V1_GetTokenAccountInfosRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account, which can also be thought of as a parent account for this
  /// RPC that links to one or more token accounts.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetTokenAccountInfosRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Account_V1_GetTokenAccountInfosResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Account_V1_GetTokenAccountInfosResponse.Result = .ok

  public var tokenAccountInfos: Dictionary<String,Code_Account_V1_TokenAccountInfo> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Account_V1_GetTokenAccountInfosResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_GetTokenAccountInfosResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Account_V1_LinkAdditionalAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to link to
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The authority account derived off the user's 12 words, which contains
  /// the USDC ATA (and potentially others in the future) that will be used
  /// in swaps.
  public var swapAuthority: Code_Common_V1_SolanaAccountId {
    get {return _swapAuthority ?? Code_Common_V1_SolanaAccountId()}
    set {_swapAuthority = newValue}
  }
  /// Returns true if `swapAuthority` has been explicitly set.
  public var hasSwapAuthority: Bool {return self._swapAuthority != nil}
  /// Clears the value of `swapAuthority`. Subsequent reads from it will return its default value.
  public mutating func clearSwapAuthority() {self._swapAuthority = nil}

  /// Signature values for each account provided in this request. Each signature
  /// must be generated without this array set. The expected ordering of signatures:
  ///  1. owner
  ///  2. swap_authority
  public var signatures: [Code_Common_V1_Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _swapAuthority: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Account_V1_LinkAdditionalAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Account_V1_LinkAdditionalAccountsResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Supports idempotency, and will be returned as long as the request exactly
    /// matches a previous execution.
    case ok // = 0

    /// The action has been denied (eg. owner account not phone verified)
    case denied // = 1

    /// An account being linked is not valid
    case invalidAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .invalidAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .invalidAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Account_V1_LinkAdditionalAccountsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_LinkAdditionalAccountsResponse.Result] = [
    .ok,
    .denied,
    .invalidAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Account_V1_TokenAccountInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token account's address
  public var address: Code_Common_V1_SolanaAccountId {
    get {return _storage._address ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// The owner of the token account, which can also be thought of as a parent
  /// account that links to one or more token accounts. This is provided when
  /// available.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _storage._owner ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// The token account's authority, which has access to moving funds for the
  /// account. This can be the owner account under certain circumstances (eg.
  /// ATA, primary account). This is provided when available.
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _storage._authority ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return _storage._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {_uniqueStorage()._authority = nil}

  /// The type of token account, which infers its intended use.
  public var accountType: Code_Common_V1_AccountType {
    get {return _storage._accountType}
    set {_uniqueStorage()._accountType = newValue}
  }

  /// The account's derivation index for applicable account types. When this field
  /// doesn't apply, a zero value is provided.
  public var index: UInt64 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  /// The source of truth for the balance calculation.
  public var balanceSource: Code_Account_V1_TokenAccountInfo.BalanceSource {
    get {return _storage._balanceSource}
    set {_uniqueStorage()._balanceSource = newValue}
  }

  /// The balance in quarks, as observed by Code. This may not reflect the value
  /// on the blockchain and could be non-zero even if the account hasn't been created.
  /// Use balance_source to determine how this value was calculated.
  public var balance: UInt64 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// The state of the account as it pertains to Code's ability to manage funds.
  public var managementState: Code_Account_V1_TokenAccountInfo.ManagementState {
    get {return _storage._managementState}
    set {_uniqueStorage()._managementState = newValue}
  }

  /// The state of the account on the blockchain.
  public var blockchainState: Code_Account_V1_TokenAccountInfo.BlockchainState {
    get {return _storage._blockchainState}
    set {_uniqueStorage()._blockchainState = newValue}
  }

  /// For temporary incoming accounts only. Flag indicates whether client must
  /// actively try rotating it by issuing a ReceivePaymentsPrivately intent. In
  /// general, clients should wait as long as possible until this flag is true
  /// or requiring the funds to send their next payment.
  public var mustRotate: Bool {
    get {return _storage._mustRotate}
    set {_uniqueStorage()._mustRotate = newValue}
  }

  /// Whether an account is claimed. This only applies to relevant account types
  /// (eg. REMOTE_SEND_GIFT_CARD).
  public var claimState: Code_Account_V1_TokenAccountInfo.ClaimState {
    get {return _storage._claimState}
    set {_uniqueStorage()._claimState = newValue}
  }

  /// For account types used as an intermediary for sending money between two
  /// users (eg. REMOTE_SEND_GIFT_CARD), this represents the original exchange
  /// data used to fund the account. Over time, this value will become stale:
  ///  1. Exchange rates will fluctuate, so the total fiat amount will differ.
  ///  2. External entities can deposit additional funds into the account, so
  ///     the balance, in quarks, may be greater than the original quark value.
  ///  3. The balance could have been received, so the total balance can show
  ///     as zero.
  public var originalExchangeData: Code_Transaction_V2_ExchangeData {
    get {return _storage._originalExchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_uniqueStorage()._originalExchangeData = newValue}
  }
  /// Returns true if `originalExchangeData` has been explicitly set.
  public var hasOriginalExchangeData: Bool {return _storage._originalExchangeData != nil}
  /// Clears the value of `originalExchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalExchangeData() {_uniqueStorage()._originalExchangeData = nil}

  /// The token account's mint
  public var mint: Code_Common_V1_SolanaAccountId {
    get {return _storage._mint ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return _storage._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {_uniqueStorage()._mint = nil}

  /// The relationship with a third party that this account has established with.
  /// This only applies to relevant account types (eg. RELATIONSHIP).
  public var relationship: Code_Common_V1_Relationship {
    get {return _storage._relationship ?? Code_Common_V1_Relationship()}
    set {_uniqueStorage()._relationship = newValue}
  }
  /// Returns true if `relationship` has been explicitly set.
  public var hasRelationship: Bool {return _storage._relationship != nil}
  /// Clears the value of `relationship`. Subsequent reads from it will return its default value.
  public mutating func clearRelationship() {_uniqueStorage()._relationship = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum BalanceSource: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The account's balance could not be determined. This may be returned when
    /// the data source is unstable and a reliable balance cannot be determined.
    case unknown // = 0

    /// The account's balance was fetched directly from a finalized state on the
    /// blockchain.
    case blockchain // = 1

    /// The account's balance was calculated using cached values in Code. Accuracy
    /// is only guaranteed when management_state is LOCKED.
    case cache // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .blockchain
      case 2: self = .cache
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .blockchain: return 1
      case .cache: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ManagementState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the account is unknown. This may be returned when the
    /// data source is unstable and a reliable state cannot be determined.
    case unknown // = 0

    /// Code does not maintain a management state and won't move funds for this
    /// account.
    case none // = 1

    /// The account is in the process of transitioning to the LOCKED state.
    case locking // = 2

    /// The account's funds are locked and Code has co-signing authority.
    case locked // = 3

    /// The account is in the process of transitioning to the UNLOCKED state.
    case unlocking // = 4

    /// The account's funds are unlocked and Code no longer has co-signing
    /// authority. The account must transition to the LOCKED state to have
    /// management capabilities.
    case unlocked // = 5

    /// The account is in the process of transitioning to the CLOSED state.
    case closing // = 6

    /// The account has been closed and doesn't exist on the blockchain.
    /// Subsequently, it also has a zero balance.
    case closed // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .locking
      case 3: self = .locked
      case 4: self = .unlocking
      case 5: self = .unlocked
      case 6: self = .closing
      case 7: self = .closed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .locking: return 2
      case .locked: return 3
      case .unlocking: return 4
      case .unlocked: return 5
      case .closing: return 6
      case .closed: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum BlockchainState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the account is unknown. This may be returned when the
    /// data source is unstable and a reliable state cannot be determined.
    case unknown // = 0

    /// The account does not exist on the blockchain.
    case doesNotExist // = 1

    /// The account is created and exists on the blockchain.
    case exists // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .doesNotExist
      case 2: self = .exists
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .doesNotExist: return 1
      case .exists: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ClaimState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The account doesn't have a concept of being claimed, or the state
    /// could not be fetched by server.
    case unknown // = 0

    /// The account has not yet been claimed.
    case notClaimed // = 1

    /// The account is claimed. Attempting to claim it will fail.
    case claimed // = 2

    /// The account hasn't been claimed, but is expired. Funds will move
    /// back to the issuer. Attempting to claim it will fail.
    case expired // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .notClaimed
      case 2: self = .claimed
      case 3: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .notClaimed: return 1
      case .claimed: return 2
      case .expired: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Code_Account_V1_TokenAccountInfo.BalanceSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_TokenAccountInfo.BalanceSource] = [
    .unknown,
    .blockchain,
    .cache,
  ]
}

extension Code_Account_V1_TokenAccountInfo.ManagementState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_TokenAccountInfo.ManagementState] = [
    .unknown,
    .none,
    .locking,
    .locked,
    .unlocking,
    .unlocked,
    .closing,
    .closed,
  ]
}

extension Code_Account_V1_TokenAccountInfo.BlockchainState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_TokenAccountInfo.BlockchainState] = [
    .unknown,
    .doesNotExist,
    .exists,
  ]
}

extension Code_Account_V1_TokenAccountInfo.ClaimState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Account_V1_TokenAccountInfo.ClaimState] = [
    .unknown,
    .notClaimed,
    .claimed,
    .expired,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Account_V1_IsCodeAccountRequest: @unchecked Sendable {}
extension Code_Account_V1_IsCodeAccountResponse: @unchecked Sendable {}
extension Code_Account_V1_IsCodeAccountResponse.Result: @unchecked Sendable {}
extension Code_Account_V1_GetTokenAccountInfosRequest: @unchecked Sendable {}
extension Code_Account_V1_GetTokenAccountInfosResponse: @unchecked Sendable {}
extension Code_Account_V1_GetTokenAccountInfosResponse.Result: @unchecked Sendable {}
extension Code_Account_V1_LinkAdditionalAccountsRequest: @unchecked Sendable {}
extension Code_Account_V1_LinkAdditionalAccountsResponse: @unchecked Sendable {}
extension Code_Account_V1_LinkAdditionalAccountsResponse.Result: @unchecked Sendable {}
extension Code_Account_V1_TokenAccountInfo: @unchecked Sendable {}
extension Code_Account_V1_TokenAccountInfo.BalanceSource: @unchecked Sendable {}
extension Code_Account_V1_TokenAccountInfo.ManagementState: @unchecked Sendable {}
extension Code_Account_V1_TokenAccountInfo.BlockchainState: @unchecked Sendable {}
extension Code_Account_V1_TokenAccountInfo.ClaimState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.account.v1"

extension Code_Account_V1_IsCodeAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsCodeAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_IsCodeAccountRequest, rhs: Code_Account_V1_IsCodeAccountRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_IsCodeAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsCodeAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_IsCodeAccountResponse, rhs: Code_Account_V1_IsCodeAccountResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_IsCodeAccountResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
    2: .same(proto: "UNLOCKED_TIMELOCK_ACCOUNT"),
  ]
}

extension Code_Account_V1_GetTokenAccountInfosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTokenAccountInfosRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_GetTokenAccountInfosRequest, rhs: Code_Account_V1_GetTokenAccountInfosRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_GetTokenAccountInfosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTokenAccountInfosResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "token_account_infos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Account_V1_TokenAccountInfo>.self, value: &self.tokenAccountInfos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.tokenAccountInfos.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Account_V1_TokenAccountInfo>.self, value: self.tokenAccountInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_GetTokenAccountInfosResponse, rhs: Code_Account_V1_GetTokenAccountInfosResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.tokenAccountInfos != rhs.tokenAccountInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_GetTokenAccountInfosResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Account_V1_LinkAdditionalAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkAdditionalAccountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "swap_authority"),
    3: .same(proto: "signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swapAuthority) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._swapAuthority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_LinkAdditionalAccountsRequest, rhs: Code_Account_V1_LinkAdditionalAccountsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._swapAuthority != rhs._swapAuthority {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_LinkAdditionalAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkAdditionalAccountsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_LinkAdditionalAccountsResponse, rhs: Code_Account_V1_LinkAdditionalAccountsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_LinkAdditionalAccountsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "INVALID_ACCOUNT"),
  ]
}

extension Code_Account_V1_TokenAccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenAccountInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "authority"),
    4: .standard(proto: "account_type"),
    5: .same(proto: "index"),
    6: .standard(proto: "balance_source"),
    7: .same(proto: "balance"),
    8: .standard(proto: "management_state"),
    9: .standard(proto: "blockchain_state"),
    10: .standard(proto: "must_rotate"),
    11: .standard(proto: "claim_state"),
    12: .standard(proto: "original_exchange_data"),
    13: .same(proto: "mint"),
    16: .same(proto: "relationship"),
  ]

  fileprivate class _StorageClass {
    var _address: Code_Common_V1_SolanaAccountId? = nil
    var _owner: Code_Common_V1_SolanaAccountId? = nil
    var _authority: Code_Common_V1_SolanaAccountId? = nil
    var _accountType: Code_Common_V1_AccountType = .unknown
    var _index: UInt64 = 0
    var _balanceSource: Code_Account_V1_TokenAccountInfo.BalanceSource = .unknown
    var _balance: UInt64 = 0
    var _managementState: Code_Account_V1_TokenAccountInfo.ManagementState = .unknown
    var _blockchainState: Code_Account_V1_TokenAccountInfo.BlockchainState = .unknown
    var _mustRotate: Bool = false
    var _claimState: Code_Account_V1_TokenAccountInfo.ClaimState = .unknown
    var _originalExchangeData: Code_Transaction_V2_ExchangeData? = nil
    var _mint: Code_Common_V1_SolanaAccountId? = nil
    var _relationship: Code_Common_V1_Relationship? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _authority = source._authority
      _accountType = source._accountType
      _index = source._index
      _balanceSource = source._balanceSource
      _balance = source._balance
      _managementState = source._managementState
      _blockchainState = source._blockchainState
      _mustRotate = source._mustRotate
      _claimState = source._claimState
      _originalExchangeData = source._originalExchangeData
      _mint = source._mint
      _relationship = source._relationship
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._authority) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._accountType) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._index) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._balanceSource) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._balance) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._managementState) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._blockchainState) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._mustRotate) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._claimState) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._originalExchangeData) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._mint) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._relationship) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._authority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._accountType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._accountType, fieldNumber: 4)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._index, fieldNumber: 5)
      }
      if _storage._balanceSource != .unknown {
        try visitor.visitSingularEnumField(value: _storage._balanceSource, fieldNumber: 6)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._balance, fieldNumber: 7)
      }
      if _storage._managementState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._managementState, fieldNumber: 8)
      }
      if _storage._blockchainState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._blockchainState, fieldNumber: 9)
      }
      if _storage._mustRotate != false {
        try visitor.visitSingularBoolField(value: _storage._mustRotate, fieldNumber: 10)
      }
      if _storage._claimState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._claimState, fieldNumber: 11)
      }
      try { if let v = _storage._originalExchangeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._mint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._relationship {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_TokenAccountInfo, rhs: Code_Account_V1_TokenAccountInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._authority != rhs_storage._authority {return false}
        if _storage._accountType != rhs_storage._accountType {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._balanceSource != rhs_storage._balanceSource {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._managementState != rhs_storage._managementState {return false}
        if _storage._blockchainState != rhs_storage._blockchainState {return false}
        if _storage._mustRotate != rhs_storage._mustRotate {return false}
        if _storage._claimState != rhs_storage._claimState {return false}
        if _storage._originalExchangeData != rhs_storage._originalExchangeData {return false}
        if _storage._mint != rhs_storage._mint {return false}
        if _storage._relationship != rhs_storage._relationship {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_TokenAccountInfo.BalanceSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BALANCE_SOURCE_UNKNOWN"),
    1: .same(proto: "BALANCE_SOURCE_BLOCKCHAIN"),
    2: .same(proto: "BALANCE_SOURCE_CACHE"),
  ]
}

extension Code_Account_V1_TokenAccountInfo.ManagementState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANAGEMENT_STATE_UNKNOWN"),
    1: .same(proto: "MANAGEMENT_STATE_NONE"),
    2: .same(proto: "MANAGEMENT_STATE_LOCKING"),
    3: .same(proto: "MANAGEMENT_STATE_LOCKED"),
    4: .same(proto: "MANAGEMENT_STATE_UNLOCKING"),
    5: .same(proto: "MANAGEMENT_STATE_UNLOCKED"),
    6: .same(proto: "MANAGEMENT_STATE_CLOSING"),
    7: .same(proto: "MANAGEMENT_STATE_CLOSED"),
  ]
}

extension Code_Account_V1_TokenAccountInfo.BlockchainState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLOCKCHAIN_STATE_UNKNOWN"),
    1: .same(proto: "BLOCKCHAIN_STATE_DOES_NOT_EXIST"),
    2: .same(proto: "BLOCKCHAIN_STATE_EXISTS"),
  ]
}

extension Code_Account_V1_TokenAccountInfo.ClaimState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLAIM_STATE_UNKNOWN"),
    1: .same(proto: "CLAIM_STATE_NOT_CLAIMED"),
    2: .same(proto: "CLAIM_STATE_CLAIMED"),
    3: .same(proto: "CLAIM_STATE_EXPIRED"),
  ]
}
