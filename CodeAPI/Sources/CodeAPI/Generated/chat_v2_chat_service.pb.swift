// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v2/chat_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Code_Chat_V2_ChatType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownChatType // = 0

  /// GROUP             = 3;
  case twoWay // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownChatType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownChatType
    case 1: self = .twoWay
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownChatType: return 0
    case .twoWay: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ChatType] = [
    .unknownChatType,
    .twoWay,
  ]
}

#endif  // swift(>=4.2)

public enum Code_Chat_V2_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPlatform // = 0
  case twitter // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPlatform
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPlatform
    case 1: self = .twitter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPlatform: return 0
    case .twitter: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_Platform] = [
    .unknownPlatform,
    .twitter,
  ]
}

#endif  // swift(>=4.2)

public enum Code_Chat_V2_PointerType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPointerType // = 0

  /// Always inferred by OK result in SendMessageResponse or message presence in a chat
  case sent // = 1
  case delivered // = 2
  case read // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPointerType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPointerType
    case 1: self = .sent
    case 2: self = .delivered
    case 3: self = .read
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPointerType: return 0
    case .sent: return 1
    case .delivered: return 2
    case .read: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_PointerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_PointerType] = [
    .unknownPointerType,
    .sent,
    .delivered,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V2_GetChatsRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_GetChatsRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetChatsRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_GetChatsResponse.Result = .ok

  public var chats: [Code_Chat_V2_Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_GetChatsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetChatsResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V2_GetMessagesRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_GetMessagesRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetMessagesRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_GetMessagesResponse.Result = .ok

  public var messages: [Code_Chat_V2_Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_GetMessagesResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetMessagesResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_OpenChatEventStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_ChatStreamEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_ChatStreamEvent.OneOf_Type? = nil

  public var message: Code_Chat_V2_Message {
    get {
      if case .message(let v)? = type {return v}
      return Code_Chat_V2_Message()
    }
    set {type = .message(newValue)}
  }

  public var pointer: Code_Chat_V2_Pointer {
    get {
      if case .pointer(let v)? = type {return v}
      return Code_Chat_V2_Pointer()
    }
    set {type = .pointer(newValue)}
  }

  public var isTyping: Code_Chat_V2_IsTyping {
    get {
      if case .isTyping(let v)? = type {return v}
      return Code_Chat_V2_IsTyping()
    }
    set {type = .isTyping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case message(Code_Chat_V2_Message)
    case pointer(Code_Chat_V2_Pointer)
    case isTyping(Code_Chat_V2_IsTyping)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ChatStreamEvent.OneOf_Type, rhs: Code_Chat_V2_ChatStreamEvent.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.message, .message): return {
        guard case .message(let l) = lhs, case .message(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pointer, .pointer): return {
        guard case .pointer(let l) = lhs, case .pointer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isTyping, .isTyping): return {
        guard case .isTyping(let l) = lhs, case .isTyping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_ChatStreamEventBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Code_Chat_V2_ChatStreamEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_ChatStreamEventError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Code_Chat_V2_ChatStreamEventError.Code = .denied

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case denied // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .denied
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .denied: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_ChatStreamEventError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ChatStreamEventError.Code] = [
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_StreamChatEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type? = nil

  public var openStream: Code_Chat_V2_OpenChatEventStream {
    get {
      if case .openStream(let v)? = type {return v}
      return Code_Chat_V2_OpenChatEventStream()
    }
    set {type = .openStream(newValue)}
  }

  public var pong: Code_Common_V1_ClientPong {
    get {
      if case .pong(let v)? = type {return v}
      return Code_Common_V1_ClientPong()
    }
    set {type = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case openStream(Code_Chat_V2_OpenChatEventStream)
    case pong(Code_Common_V1_ClientPong)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type, rhs: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openStream, .openStream): return {
        guard case .openStream(let l) = lhs, case .openStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_StreamChatEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type? = nil

  public var events: Code_Chat_V2_ChatStreamEventBatch {
    get {
      if case .events(let v)? = type {return v}
      return Code_Chat_V2_ChatStreamEventBatch()
    }
    set {type = .events(newValue)}
  }

  public var ping: Code_Common_V1_ServerPing {
    get {
      if case .ping(let v)? = type {return v}
      return Code_Common_V1_ServerPing()
    }
    set {type = .ping(newValue)}
  }

  public var error: Code_Chat_V2_ChatStreamEventError {
    get {
      if case .error(let v)? = type {return v}
      return Code_Chat_V2_ChatStreamEventError()
    }
    set {type = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case events(Code_Chat_V2_ChatStreamEventBatch)
    case ping(Code_Common_V1_ServerPing)
    case error(Code_Chat_V2_ChatStreamEventError)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type, rhs: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.events, .events): return {
        guard case .events(let l) = lhs, case .events(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_StartChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var parameters: Code_Chat_V2_StartChatRequest.OneOf_Parameters? = nil

  public var twoWayChat: Code_Chat_V2_StartTwoWayChatParameters {
    get {
      if case .twoWayChat(let v)? = parameters {return v}
      return Code_Chat_V2_StartTwoWayChatParameters()
    }
    set {parameters = .twoWayChat(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parameters: Equatable {
    case twoWayChat(Code_Chat_V2_StartTwoWayChatParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StartChatRequest.OneOf_Parameters, rhs: Code_Chat_V2_StartChatRequest.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.twoWayChat, .twoWayChat): return {
        guard case .twoWayChat(let l) = lhs, case .twoWayChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

/// StartTwoWayChatParameters contains the parameters required to start
/// or recover a two way chat between the caller and the specified 'other_user'.
///
/// The 'other_user' is currently the 'tip_address', normally retrieved from
/// user.Identity.GetTwitterUser(username).
public struct Code_Chat_V2_StartTwoWayChatParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of the user the caller wishes to chat with.
  ///
  /// This will be the `tip` (or equivalent) address.
  public var otherUser: Code_Common_V1_SolanaAccountId {
    get {return _otherUser ?? Code_Common_V1_SolanaAccountId()}
    set {_otherUser = newValue}
  }
  /// Returns true if `otherUser` has been explicitly set.
  public var hasOtherUser: Bool {return self._otherUser != nil}
  /// Clears the value of `otherUser`. Subsequent reads from it will return its default value.
  public mutating func clearOtherUser() {self._otherUser = nil}

  /// The intent_id of the payment that initiated the chat/friendship.
  ///
  /// This field is optional. It is used as an optimization when the server has not
  /// yet observed the establishment of a friendship. In this case, the server will
  /// use the provided intent_id to verify the friendship.
  ///
  /// This is most likely to occur when initiating a chat with a user for the first
  /// time.
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _otherUser: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
}

public struct Code_Chat_V2_StartChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_StartChatResponse.Result = .ok

  /// The chat to use if the RPC was successful.
  public var chat: Code_Chat_V2_Metadata {
    get {return _chat ?? Code_Chat_V2_Metadata()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// DENIED indicates the caller is not allowed to start/join the chat.
    case denied // = 1

    /// INVALID_PRAMETER indicates one of the parameters is invalid.
    case invalidParameter // = 2

    /// PENDING indicates that the payment (for chat) intent is pending confirmation
    /// before the service will permit the creation of the chat. This can happen in
    /// cases where the block chain is particularly slow (beyond our RPC timeouts).
    case pending // = 3

    /// MISSING_IDENTITY indicates that there is no identity for the user (creator).
    case missingIdentity // = 4

    /// USER_NOT_FOUND indicates that (one of) the target user's was not found.
    case userNotFound // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .invalidParameter
      case 3: self = .pending
      case 4: self = .missingIdentity
      case 5: self = .userNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .invalidParameter: return 2
      case .pending: return 3
      case .missingIdentity: return 4
      case .userNotFound: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chat: Code_Chat_V2_Metadata? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_StartChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_StartChatResponse.Result] = [
    .ok,
    .denied,
    .invalidParameter,
    .pending,
    .missingIdentity,
    .userNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// Allowed content types that can be sent by client:
  ///  - TextContent
  ///  - ThankYouContent
  public var content: [Code_Chat_V2_Content] = []

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_SendMessageResponse.Result = .ok

  /// The chat message that was sent if the RPC was succesful, which includes
  /// server-side metadata like the generated message ID and official timestamp
  public var message: Code_Chat_V2_Message {
    get {return _message ?? Code_Chat_V2_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case invalidContentType // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .invalidContentType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .invalidContentType: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _message: Code_Chat_V2_Message? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_SendMessageResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_SendMessageResponse.Result] = [
    .ok,
    .denied,
    .invalidContentType,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_AdvancePointerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var pointer: Code_Chat_V2_Pointer {
    get {return _pointer ?? Code_Chat_V2_Pointer()}
    set {_pointer = newValue}
  }
  /// Returns true if `pointer` has been explicitly set.
  public var hasPointer: Bool {return self._pointer != nil}
  /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
  public mutating func clearPointer() {self._pointer = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _pointer: Code_Chat_V2_Pointer? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_AdvancePointerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_AdvancePointerResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case messageNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .messageNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .messageNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_AdvancePointerResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_AdvancePointerResponse.Result] = [
    .ok,
    .denied,
    .messageNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_SetMuteStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var isMuted: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_SetMuteStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_SetMuteStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case cantMute // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .cantMute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .cantMute: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_SetMuteStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_SetMuteStateResponse.Result] = [
    .ok,
    .denied,
    .cantMute,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_NotifyIsTypingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var isTyping: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_NotifyIsTypingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_NotifyIsTypingResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_NotifyIsTypingResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_NotifyIsTypingResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_MessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A lexicographically sortable ID that can be used to sort source of
  /// chat history.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_MemberId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The publically available 'deposit' address of the user.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A chat
///
/// todo: Support is_verified in a clean way
public struct Code_Chat_V2_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Common_V1_ChatId {
    get {return _chatID ?? Code_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// The type of chat
  public var type: Code_Chat_V2_ChatType = .unknownChatType

  /// Cursor value for this chat for reference in subsequent GetChatsRequest
  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  /// The chat title, which is _only_ set by server if an explicit title
  /// was set. Otherwise, clients should fill in an appropriate chat title.
  public var title: String = String()

  /// The members in this chat.
  public var members: [Code_Chat_V2_Member] = []

  /// Whether or not the chat is muted (from the perspective of the caller).
  public var isMuted: Bool = false

  /// Whether or not the chat is mutable (from the persective of the caller).
  public var muteable: Bool = false

  /// Number of (estimated) unread message (from the perspective of the caller).
  public var numUnread: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Common_V1_ChatId? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

/// A message in a chat
public struct Code_Chat_V2_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this message
  public var messageID: Code_Chat_V2_MessageId {
    get {return _messageID ?? Code_Chat_V2_MessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// The chat member that sent the message. For NOTIFICATION chats, this field
  /// is omitted since the chat has exactly 1 member.
  public var senderID: Code_Chat_V2_MemberId {
    get {return _senderID ?? Code_Chat_V2_MemberId()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  /// Ordered message content. A message may have more than one piece of content.
  public var content: [Code_Chat_V2_Content] = []

  /// Timestamp this message was generated at. This value is also encoded in
  /// any time-based UUID message IDs.
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// Cursor value for this message for reference in a paged GetMessagesRequest
  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Code_Chat_V2_MessageId? = nil
  fileprivate var _senderID: Code_Chat_V2_MemberId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

/// A user in a chat
public struct Code_Chat_V2_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public AccountId (for is self...is derived via deposit address)
  public var memberID: Code_Chat_V2_MemberId {
    get {return _memberID ?? Code_Chat_V2_MemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// The chat member's identity if it has been revealed.
  ///
  /// Multiple identities here? Well really only needs twitter/other handles
  /// Repeated PlatformHandles (where code doesn't matter)?
  public var identity: Code_Chat_V2_MemberIdentity {
    get {return _identity ?? Code_Chat_V2_MemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  /// Chat message state for this member.
  ///
  /// If set, the list may contain DELIVERED and READ pointers. SENT pointers
  /// are only shared between the sender and server, to indicate persistence.
  ///
  /// The server may wish to omit all pointers in various types of group chats
  /// or as relief valves.
  public var pointers: [Code_Chat_V2_Pointer] = []

  /// If the member is the caller (where applicable), will be set to true.
  public var isSelf: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberID: Code_Chat_V2_MemberId? = nil
  fileprivate var _identity: Code_Chat_V2_MemberIdentity? = nil
}

/// Identity to an external social platform that can be linked to a Code account
public struct Code_Chat_V2_MemberIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The external social platform linked to this chat member
  public var platform: Code_Chat_V2_Platform = .unknownPlatform

  /// The chat member's username on the external social platform.
  public var username: String = String()

  /// If present, the display name of the user.
  public var displayName: String = String()

  /// If present, the URL of the users profile pic.
  public var profilePicURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Pointer in a chat indicating a user's message history state in a chat.
public struct Code_Chat_V2_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of pointer indicates which user's message history state can be
  /// inferred from the pointer value. It is also possible to infer cross-pointer
  /// state. For example, if a chat member has a READ pointer for a message with
  /// ID N, then the DELIVERED pointer must be at least N.
  public var type: Code_Chat_V2_PointerType = .unknownPointerType

  /// Everything at or before this message ID is considered to have the state
  /// inferred by the type of pointer.
  public var value: Code_Chat_V2_MessageId {
    get {return _value ?? Code_Chat_V2_MessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// The chat member associated with this pointer state
  public var memberID: Code_Chat_V2_MemberId {
    get {return _memberID ?? Code_Chat_V2_MemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Code_Chat_V2_MessageId? = nil
  fileprivate var _memberID: Code_Chat_V2_MemberId? = nil
}

/// Content for a chat message
public struct Code_Chat_V2_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_Content.OneOf_Type? = nil

  public var text: Code_Chat_V2_TextContent {
    get {
      if case .text(let v)? = type {return v}
      return Code_Chat_V2_TextContent()
    }
    set {type = .text(newValue)}
  }

  public var localized: Code_Chat_V2_LocalizedContent {
    get {
      if case .localized(let v)? = type {return v}
      return Code_Chat_V2_LocalizedContent()
    }
    set {type = .localized(newValue)}
  }

  public var exchangeData: Code_Chat_V2_ExchangeDataContent {
    get {
      if case .exchangeData(let v)? = type {return v}
      return Code_Chat_V2_ExchangeDataContent()
    }
    set {type = .exchangeData(newValue)}
  }

  public var naclBox: Code_Chat_V2_NaclBoxEncryptedContent {
    get {
      if case .naclBox(let v)? = type {return v}
      return Code_Chat_V2_NaclBoxEncryptedContent()
    }
    set {type = .naclBox(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Code_Chat_V2_TextContent)
    case localized(Code_Chat_V2_LocalizedContent)
    case exchangeData(Code_Chat_V2_ExchangeDataContent)
    case naclBox(Code_Chat_V2_NaclBoxEncryptedContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_Content.OneOf_Type, rhs: Code_Chat_V2_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localized, .localized): return {
        guard case .localized(let l) = lhs, case .localized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exchangeData, .exchangeData): return {
        guard case .exchangeData(let l) = lhs, case .exchangeData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.naclBox, .naclBox): return {
        guard case .naclBox(let l) = lhs, case .naclBox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Raw text content
public struct Code_Chat_V2_TextContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Text content that is either a localization key that should be translated on
/// client, or a server-side translated piece of text.
public struct Code_Chat_V2_LocalizedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Exchange data content for movement of a value of Kin
public struct Code_Chat_V2_ExchangeDataContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Verb describing how the amount of Kin was exchanged
  ///
  /// Note: The current definition is not suitable outside a NOTIFICATION chat
  ///       as not enough context is provided as to which member this verb is
  ///       associated with.
  public var verb: Code_Chat_V2_ExchangeDataContent.Verb = .unknown

  /// An amount of Kin being exchanged
  public var exchangeData: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData? = nil

  public var exact: Code_Transaction_V2_ExchangeData {
    get {
      if case .exact(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeData()
    }
    set {exchangeData = .exact(newValue)}
  }

  public var partial: Code_Transaction_V2_ExchangeDataWithoutRate {
    get {
      if case .partial(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeDataWithoutRate()
    }
    set {exchangeData = .partial(newValue)}
  }

  /// An ID that can be referenced to the source of the exchange of Kin
  public var reference: Code_Chat_V2_ExchangeDataContent.OneOf_Reference? = nil

  public var intent: Code_Common_V1_IntentId {
    get {
      if case .intent(let v)? = reference {return v}
      return Code_Common_V1_IntentId()
    }
    set {reference = .intent(newValue)}
  }

  public var signature: Code_Common_V1_Signature {
    get {
      if case .signature(let v)? = reference {return v}
      return Code_Common_V1_Signature()
    }
    set {reference = .signature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An amount of Kin being exchanged
  public enum OneOf_ExchangeData: Equatable {
    case exact(Code_Transaction_V2_ExchangeData)
    case partial(Code_Transaction_V2_ExchangeDataWithoutRate)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData, rhs: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exact, .exact): return {
        guard case .exact(let l) = lhs, case .exact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.partial, .partial): return {
        guard case .partial(let l) = lhs, case .partial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// An ID that can be referenced to the source of the exchange of Kin
  public enum OneOf_Reference: Equatable {
    case intent(Code_Common_V1_IntentId)
    case signature(Code_Common_V1_Signature)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ExchangeDataContent.OneOf_Reference, rhs: Code_Chat_V2_ExchangeDataContent.OneOf_Reference) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.intent, .intent): return {
        guard case .intent(let l) = lhs, case .intent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signature, .signature): return {
        guard case .signature(let l) = lhs, case .signature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Verb: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case gave // = 1
    case received // = 2
    case withdrew // = 3
    case deposited // = 4
    case sent // = 5
    case returned // = 6
    case spent // = 7
    case paid // = 8
    case purchased // = 9
    case receivedTip // = 10
    case sentTip // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .gave
      case 2: self = .received
      case 3: self = .withdrew
      case 4: self = .deposited
      case 5: self = .sent
      case 6: self = .returned
      case 7: self = .spent
      case 8: self = .paid
      case 9: self = .purchased
      case 10: self = .receivedTip
      case 11: self = .sentTip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .gave: return 1
      case .received: return 2
      case .withdrew: return 3
      case .deposited: return 4
      case .sent: return 5
      case .returned: return 6
      case .spent: return 7
      case .paid: return 8
      case .purchased: return 9
      case .receivedTip: return 10
      case .sentTip: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_ExchangeDataContent.Verb: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ExchangeDataContent.Verb] = [
    .unknown,
    .gave,
    .received,
    .withdrew,
    .deposited,
    .sent,
    .returned,
    .spent,
    .paid,
    .purchased,
    .receivedTip,
    .sentTip,
  ]
}

#endif  // swift(>=4.2)

/// Encrypted piece of content using NaCl box encryption
public struct Code_Chat_V2_NaclBoxEncryptedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sender's public key that is used to derive the shared private key for
  /// decryption for message content.
  public var peerPublicKey: Code_Common_V1_SolanaAccountId {
    get {return _peerPublicKey ?? Code_Common_V1_SolanaAccountId()}
    set {_peerPublicKey = newValue}
  }
  /// Returns true if `peerPublicKey` has been explicitly set.
  public var hasPeerPublicKey: Bool {return self._peerPublicKey != nil}
  /// Clears the value of `peerPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPeerPublicKey() {self._peerPublicKey = nil}

  /// Globally random nonce that is unique to this encrypted piece of content
  public var nonce: Data = Data()

  /// The encrypted piece of message content
  public var encryptedPayload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerPublicKey: Code_Common_V1_SolanaAccountId? = nil
}

/// Opaque cursor used across paged APIs. Underlying bytes may change as paging
/// strategies evolve. Expected length value will vary based on the RPC being
/// executed.
public struct Code_Chat_V2_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_IsTyping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memberID: Code_Chat_V2_MemberId {
    get {return _memberID ?? Code_Chat_V2_MemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// is_typing indicates whether or not the user is typing.
  /// If false, the user has explicitly stopped typing.
  public var isTyping: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberID: Code_Chat_V2_MemberId? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Chat_V2_ChatType: @unchecked Sendable {}
extension Code_Chat_V2_Platform: @unchecked Sendable {}
extension Code_Chat_V2_PointerType: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsRequest: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsResponse: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesRequest: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesResponse: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_OpenChatEventStream: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEvent: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEvent.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventBatch: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventError: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventError.Code: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsRequest: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsRequest.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsResponse: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsResponse.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_StartChatRequest: @unchecked Sendable {}
extension Code_Chat_V2_StartChatRequest.OneOf_Parameters: @unchecked Sendable {}
extension Code_Chat_V2_StartTwoWayChatParameters: @unchecked Sendable {}
extension Code_Chat_V2_StartChatResponse: @unchecked Sendable {}
extension Code_Chat_V2_StartChatResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageRequest: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageResponse: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerRequest: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerResponse: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateRequest: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateResponse: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingRequest: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingResponse: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_MessageId: @unchecked Sendable {}
extension Code_Chat_V2_MemberId: @unchecked Sendable {}
extension Code_Chat_V2_Metadata: @unchecked Sendable {}
extension Code_Chat_V2_Message: @unchecked Sendable {}
extension Code_Chat_V2_Member: @unchecked Sendable {}
extension Code_Chat_V2_MemberIdentity: @unchecked Sendable {}
extension Code_Chat_V2_Pointer: @unchecked Sendable {}
extension Code_Chat_V2_Content: @unchecked Sendable {}
extension Code_Chat_V2_Content.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_TextContent: @unchecked Sendable {}
extension Code_Chat_V2_LocalizedContent: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.OneOf_Reference: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.Verb: @unchecked Sendable {}
extension Code_Chat_V2_NaclBoxEncryptedContent: @unchecked Sendable {}
extension Code_Chat_V2_Cursor: @unchecked Sendable {}
extension Code_Chat_V2_IsTyping: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.chat.v2"

extension Code_Chat_V2_ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CHAT_TYPE"),
    1: .same(proto: "TWO_WAY"),
  ]
}

extension Code_Chat_V2_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PLATFORM"),
    1: .same(proto: "TWITTER"),
  ]
}

extension Code_Chat_V2_PointerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_POINTER_TYPE"),
    1: .same(proto: "SENT"),
    2: .same(proto: "DELIVERED"),
    3: .same(proto: "READ"),
  ]
}

extension Code_Chat_V2_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "page_size"),
    4: .same(proto: "cursor"),
    5: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetChatsRequest, rhs: Code_Chat_V2_GetChatsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetChatsRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V2_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetChatsResponse, rhs: Code_Chat_V2_GetChatsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetChatsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Code_Chat_V2_GetMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
    4: .standard(proto: "page_size"),
    5: .same(proto: "cursor"),
    6: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetMessagesRequest, rhs: Code_Chat_V2_GetMessagesRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetMessagesRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V2_GetMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetMessagesResponse, rhs: Code_Chat_V2_GetMessagesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetMessagesResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Code_Chat_V2_OpenChatEventStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenChatEventStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_OpenChatEventStream, rhs: Code_Chat_V2_OpenChatEventStream) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "pointer"),
    3: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_Message?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .message(v)
        }
      }()
      case 2: try {
        var v: Code_Chat_V2_Pointer?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pointer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pointer(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_IsTyping?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .isTyping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .isTyping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .message?: try {
      guard case .message(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pointer?: try {
      guard case .pointer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .isTyping?: try {
      guard case .isTyping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEvent, rhs: Code_Chat_V2_ChatStreamEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEventBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEventBatch, rhs: Code_Chat_V2_ChatStreamEventBatch) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEventError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEventError, rhs: Code_Chat_V2_ChatStreamEventError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
  ]
}

extension Code_Chat_V2_StreamChatEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_stream"),
    2: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_OpenChatEventStream?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openStream(v)
        }
      }()
      case 2: try {
        var v: Code_Common_V1_ClientPong?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .openStream?: try {
      guard case .openStream(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StreamChatEventsRequest, rhs: Code_Chat_V2_StreamChatEventsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StreamChatEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .same(proto: "ping"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_ChatStreamEventBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .events(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .events(v)
        }
      }()
      case 2: try {
        var v: Code_Common_V1_ServerPing?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_ChatStreamEventError?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .events?: try {
      guard case .events(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StreamChatEventsResponse, rhs: Code_Chat_V2_StreamChatEventsResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "two_way_chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try {
        var v: Code_Chat_V2_StartTwoWayChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .twoWayChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .twoWayChat(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .twoWayChat(let v)? = self.parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartChatRequest, rhs: Code_Chat_V2_StartChatRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartTwoWayChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartTwoWayChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_user"),
    2: .standard(proto: "intent_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherUser) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartTwoWayChatParameters, rhs: Code_Chat_V2_StartTwoWayChatParameters) -> Bool {
    if lhs._otherUser != rhs._otherUser {return false}
    if lhs._intentID != rhs._intentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartChatResponse, rhs: Code_Chat_V2_StartChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "INVALID_PARAMETER"),
    3: .same(proto: "PENDING"),
    4: .same(proto: "MISSING_IDENTITY"),
    5: .same(proto: "USER_NOT_FOUND"),
  ]
}

extension Code_Chat_V2_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "content"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SendMessageRequest, rhs: Code_Chat_V2_SendMessageRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SendMessageResponse, rhs: Code_Chat_V2_SendMessageResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SendMessageResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "INVALID_CONTENT_TYPE"),
  ]
}

extension Code_Chat_V2_AdvancePointerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "pointer"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_AdvancePointerRequest, rhs: Code_Chat_V2_AdvancePointerRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_AdvancePointerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_AdvancePointerResponse, rhs: Code_Chat_V2_AdvancePointerResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_AdvancePointerResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "MESSAGE_NOT_FOUND"),
  ]
}

extension Code_Chat_V2_SetMuteStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "is_muted"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetMuteStateRequest, rhs: Code_Chat_V2_SetMuteStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetMuteStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetMuteStateResponse, rhs: Code_Chat_V2_SetMuteStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetMuteStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CANT_MUTE"),
  ]
}

extension Code_Chat_V2_NotifyIsTypingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyIsTypingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "is_typing"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NotifyIsTypingRequest, rhs: Code_Chat_V2_NotifyIsTypingRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_NotifyIsTypingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyIsTypingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NotifyIsTypingResponse, rhs: Code_Chat_V2_NotifyIsTypingResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_NotifyIsTypingResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Code_Chat_V2_MessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_MessageId, rhs: Code_Chat_V2_MessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_MemberId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_MemberId, rhs: Code_Chat_V2_MemberId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "type"),
    3: .same(proto: "cursor"),
    4: .same(proto: "title"),
    5: .same(proto: "members"),
    6: .standard(proto: "is_muted"),
    7: .same(proto: "muteable"),
    8: .standard(proto: "num_unread"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.muteable) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknownChatType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 5)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 6)
    }
    if self.muteable != false {
      try visitor.visitSingularBoolField(value: self.muteable, fieldNumber: 7)
    }
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Metadata, rhs: Code_Chat_V2_Metadata) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.title != rhs.title {return false}
    if lhs.members != rhs.members {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.muteable != rhs.muteable {return false}
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
    5: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Message, rhs: Code_Chat_V2_Message) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._senderID != rhs._senderID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .same(proto: "identity"),
    3: .same(proto: "pointers"),
    4: .standard(proto: "is_self"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pointers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSelf) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pointers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointers, fieldNumber: 3)
    }
    if self.isSelf != false {
      try visitor.visitSingularBoolField(value: self.isSelf, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Member, rhs: Code_Chat_V2_Member) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.pointers != rhs.pointers {return false}
    if lhs.isSelf != rhs.isSelf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_MemberIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "username"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "profile_pic_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.profilePicURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .unknownPlatform {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.profilePicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePicURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_MemberIdentity, rhs: Code_Chat_V2_MemberIdentity) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.username != rhs.username {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.profilePicURL != rhs.profilePicURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "member_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownPointerType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Pointer, rhs: Code_Chat_V2_Pointer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "localized"),
    3: .standard(proto: "exchange_data"),
    4: .standard(proto: "nacl_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_TextContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Code_Chat_V2_LocalizedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localized(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_ExchangeDataContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .exchangeData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .exchangeData(v)
        }
      }()
      case 4: try {
        var v: Code_Chat_V2_NaclBoxEncryptedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .naclBox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .naclBox(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localized?: try {
      guard case .localized(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .exchangeData?: try {
      guard case .exchangeData(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .naclBox?: try {
      guard case .naclBox(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Content, rhs: Code_Chat_V2_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_TextContent, rhs: Code_Chat_V2_TextContent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_LocalizedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_LocalizedContent, rhs: Code_Chat_V2_LocalizedContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ExchangeDataContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verb"),
    2: .same(proto: "exact"),
    3: .same(proto: "partial"),
    4: .same(proto: "intent"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.verb) }()
      case 2: try {
        var v: Code_Transaction_V2_ExchangeData?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .exact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .exact(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_ExchangeDataWithoutRate?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .partial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .partial(v)
        }
      }()
      case 4: try {
        var v: Code_Common_V1_IntentId?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .intent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .intent(v)
        }
      }()
      case 5: try {
        var v: Code_Common_V1_Signature?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .signature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .signature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.verb != .unknown {
      try visitor.visitSingularEnumField(value: self.verb, fieldNumber: 1)
    }
    switch self.exchangeData {
    case .exact?: try {
      guard case .exact(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .partial?: try {
      guard case .partial(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.reference {
    case .intent?: try {
      guard case .intent(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .signature?: try {
      guard case .signature(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ExchangeDataContent, rhs: Code_Chat_V2_ExchangeDataContent) -> Bool {
    if lhs.verb != rhs.verb {return false}
    if lhs.exchangeData != rhs.exchangeData {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ExchangeDataContent.Verb: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GAVE"),
    2: .same(proto: "RECEIVED"),
    3: .same(proto: "WITHDREW"),
    4: .same(proto: "DEPOSITED"),
    5: .same(proto: "SENT"),
    6: .same(proto: "RETURNED"),
    7: .same(proto: "SPENT"),
    8: .same(proto: "PAID"),
    9: .same(proto: "PURCHASED"),
    10: .same(proto: "RECEIVED_TIP"),
    11: .same(proto: "SENT_TIP"),
  ]
}

extension Code_Chat_V2_NaclBoxEncryptedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NaclBoxEncryptedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_public_key"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "encrypted_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerPublicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedPayload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.encryptedPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedPayload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NaclBoxEncryptedContent, rhs: Code_Chat_V2_NaclBoxEncryptedContent) -> Bool {
    if lhs._peerPublicKey != rhs._peerPublicKey {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.encryptedPayload != rhs.encryptedPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Cursor, rhs: Code_Chat_V2_Cursor) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_IsTyping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTyping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_IsTyping, rhs: Code_Chat_V2_IsTyping) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
