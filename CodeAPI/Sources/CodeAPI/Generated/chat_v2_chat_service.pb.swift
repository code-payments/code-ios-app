// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v2/chat_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Code_Chat_V2_ChatType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownChatType // = 0
  case notification // = 1

  /// GROUP             = 3;
  case twoWay // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownChatType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownChatType
    case 1: self = .notification
    case 2: self = .twoWay
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownChatType: return 0
    case .notification: return 1
    case .twoWay: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ChatType] = [
    .unknownChatType,
    .notification,
    .twoWay,
  ]
}

#endif  // swift(>=4.2)

public enum Code_Chat_V2_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPlatform // = 0
  case twitter // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPlatform
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPlatform
    case 1: self = .twitter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPlatform: return 0
    case .twitter: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_Platform] = [
    .unknownPlatform,
    .twitter,
  ]
}

#endif  // swift(>=4.2)

public enum Code_Chat_V2_PointerType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPointerType // = 0

  /// Always inferred by OK result in SendMessageResponse or message presence in a chat
  case sent // = 1
  case delivered // = 2
  case read // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPointerType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPointerType
    case 1: self = .sent
    case 2: self = .delivered
    case 3: self = .read
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPointerType: return 0
    case .sent: return 1
    case .delivered: return 2
    case .read: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Chat_V2_PointerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_PointerType] = [
    .unknownPointerType,
    .sent,
    .delivered,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V2_GetChatsRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_GetChatsRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetChatsRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_GetChatsResponse.Result = .ok

  public var chats: [Code_Chat_V2_ChatMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_GetChatsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetChatsResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var pageSize: UInt32 = 0

  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var direction: Code_Chat_V2_GetMessagesRequest.Direction = .asc

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case asc // = 0
    case desc // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .asc
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .asc
      case 1: self = .desc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .asc: return 0
      case .desc: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_GetMessagesRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetMessagesRequest.Direction] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_GetMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_GetMessagesResponse.Result = .ok

  public var messages: [Code_Chat_V2_ChatMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case messageNotFound // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .messageNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .messageNotFound: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_GetMessagesResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_GetMessagesResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .messageNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_OpenChatEventStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_ChatStreamEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_ChatStreamEvent.OneOf_Type? = nil

  public var message: Code_Chat_V2_ChatMessage {
    get {
      if case .message(let v)? = type {return v}
      return Code_Chat_V2_ChatMessage()
    }
    set {type = .message(newValue)}
  }

  public var pointer: Code_Chat_V2_Pointer {
    get {
      if case .pointer(let v)? = type {return v}
      return Code_Chat_V2_Pointer()
    }
    set {type = .pointer(newValue)}
  }

  public var isTyping: Code_Chat_V2_IsTyping {
    get {
      if case .isTyping(let v)? = type {return v}
      return Code_Chat_V2_IsTyping()
    }
    set {type = .isTyping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case message(Code_Chat_V2_ChatMessage)
    case pointer(Code_Chat_V2_Pointer)
    case isTyping(Code_Chat_V2_IsTyping)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ChatStreamEvent.OneOf_Type, rhs: Code_Chat_V2_ChatStreamEvent.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.message, .message): return {
        guard case .message(let l) = lhs, case .message(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pointer, .pointer): return {
        guard case .pointer(let l) = lhs, case .pointer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isTyping, .isTyping): return {
        guard case .isTyping(let l) = lhs, case .isTyping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_ChatStreamEventBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Code_Chat_V2_ChatStreamEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_ChatStreamEventError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Code_Chat_V2_ChatStreamEventError.Code = .denied

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case denied // = 0
    case chatNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .denied
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .denied
      case 1: self = .chatNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .denied: return 0
      case .chatNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_ChatStreamEventError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ChatStreamEventError.Code] = [
    .denied,
    .chatNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_StreamChatEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type? = nil

  public var openStream: Code_Chat_V2_OpenChatEventStream {
    get {
      if case .openStream(let v)? = type {return v}
      return Code_Chat_V2_OpenChatEventStream()
    }
    set {type = .openStream(newValue)}
  }

  public var pong: Code_Common_V1_ClientPong {
    get {
      if case .pong(let v)? = type {return v}
      return Code_Common_V1_ClientPong()
    }
    set {type = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case openStream(Code_Chat_V2_OpenChatEventStream)
    case pong(Code_Common_V1_ClientPong)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type, rhs: Code_Chat_V2_StreamChatEventsRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openStream, .openStream): return {
        guard case .openStream(let l) = lhs, case .openStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_StreamChatEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type? = nil

  public var events: Code_Chat_V2_ChatStreamEventBatch {
    get {
      if case .events(let v)? = type {return v}
      return Code_Chat_V2_ChatStreamEventBatch()
    }
    set {type = .events(newValue)}
  }

  public var ping: Code_Common_V1_ServerPing {
    get {
      if case .ping(let v)? = type {return v}
      return Code_Common_V1_ServerPing()
    }
    set {type = .ping(newValue)}
  }

  public var error: Code_Chat_V2_ChatStreamEventError {
    get {
      if case .error(let v)? = type {return v}
      return Code_Chat_V2_ChatStreamEventError()
    }
    set {type = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case events(Code_Chat_V2_ChatStreamEventBatch)
    case ping(Code_Common_V1_ServerPing)
    case error(Code_Chat_V2_ChatStreamEventError)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type, rhs: Code_Chat_V2_StreamChatEventsResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.events, .events): return {
        guard case .events(let l) = lhs, case .events(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Chat_V2_StartChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var self_p: Code_Chat_V2_ChatMemberIdentity {
    get {return _self_p ?? Code_Chat_V2_ChatMemberIdentity()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  public var parameters: Code_Chat_V2_StartChatRequest.OneOf_Parameters? = nil

  /// GroupChatParameters group_chat  = 4;
  public var twoWayChat: Code_Chat_V2_StartTwoWayChatParameters {
    get {
      if case .twoWayChat(let v)? = parameters {return v}
      return Code_Chat_V2_StartTwoWayChatParameters()
    }
    set {parameters = .twoWayChat(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parameters: Equatable {
    /// GroupChatParameters group_chat  = 4;
    case twoWayChat(Code_Chat_V2_StartTwoWayChatParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_StartChatRequest.OneOf_Parameters, rhs: Code_Chat_V2_StartChatRequest.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.twoWayChat, .twoWayChat): return {
        guard case .twoWayChat(let l) = lhs, case .twoWayChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _self_p: Code_Chat_V2_ChatMemberIdentity? = nil
}

/// StartTwoWayChatParameters contains the parameters required to start
/// or recover a two way chat between the caller and the specified 'other_user'.
///
/// The 'other_user' is currently the 'tip_address', normally retrieved from
/// user.Identity.GetTwitterUser(username).
public struct Code_Chat_V2_StartTwoWayChatParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of the user the caller wishes to chat with.
  ///
  /// This will be the `tip` (or equivalent) address.
  public var otherUser: Code_Common_V1_SolanaAccountId {
    get {return _otherUser ?? Code_Common_V1_SolanaAccountId()}
    set {_otherUser = newValue}
  }
  /// Returns true if `otherUser` has been explicitly set.
  public var hasOtherUser: Bool {return self._otherUser != nil}
  /// Clears the value of `otherUser`. Subsequent reads from it will return its default value.
  public mutating func clearOtherUser() {self._otherUser = nil}

  /// The intent_id of the payment that initiated the chat/friendship.
  ///
  /// This field is optional. It is used as an optimization when the server has not
  /// yet observed the establishment of a friendship. In this case, the server will
  /// use the provided intent_id to verify the friendship.
  ///
  /// This is most likely to occur when initiating a chat with a user for the first
  /// time.
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The identity of the other user.
  ///
  /// Note: This can/should be removed with proper intent plumbing.
  public var identity: Code_Chat_V2_ChatMemberIdentity {
    get {return _identity ?? Code_Chat_V2_ChatMemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _otherUser: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
  fileprivate var _identity: Code_Chat_V2_ChatMemberIdentity? = nil
}

public struct Code_Chat_V2_StartChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_StartChatResponse.Result = .ok

  /// The chat to use if the RPC was successful.
  public var chat: Code_Chat_V2_ChatMetadata {
    get {return _chat ?? Code_Chat_V2_ChatMetadata()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// DENIED indicates the caller is not allowed to start/join the chat.
    case denied // = 1

    /// INVALID_PRAMETER indicates one of the parameters is invalid.
    case invalidParameter // = 2

    /// PENDING indicates that the payment (for chat) intent is pending confirmation
    /// before the service will permit the creation of the chat. This can happen in
    /// cases where the block chain is particularly slow (beyond our RPC timeouts).
    case pending // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .invalidParameter
      case 3: self = .pending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .invalidParameter: return 2
      case .pending: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chat: Code_Chat_V2_ChatMetadata? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_StartChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_StartChatResponse.Result] = [
    .ok,
    .denied,
    .invalidParameter,
    .pending,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// Allowed content types that can be sent by client:
  ///  - TextContent
  ///  - ThankYouContent
  public var content: [Code_Chat_V2_Content] = []

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_SendMessageResponse.Result = .ok

  /// The chat message that was sent if the RPC was succesful, which includes
  /// server-side metadata like the generated message ID and official timestamp
  public var message: Code_Chat_V2_ChatMessage {
    get {return _message ?? Code_Chat_V2_ChatMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case invalidChatType // = 3
    case invalidContentType // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .invalidChatType
      case 4: self = .invalidContentType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .invalidChatType: return 3
      case .invalidContentType: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _message: Code_Chat_V2_ChatMessage? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_SendMessageResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_SendMessageResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .invalidChatType,
    .invalidContentType,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_AdvancePointerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var pointer: Code_Chat_V2_Pointer {
    get {return _pointer ?? Code_Chat_V2_Pointer()}
    set {_pointer = newValue}
  }
  /// Returns true if `pointer` has been explicitly set.
  public var hasPointer: Bool {return self._pointer != nil}
  /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
  public mutating func clearPointer() {self._pointer = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _pointer: Code_Chat_V2_Pointer? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_AdvancePointerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_AdvancePointerResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case messageNotFound // = 3
    case invalidPointerType // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .messageNotFound
      case 4: self = .invalidPointerType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .messageNotFound: return 3
      case .invalidPointerType: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_AdvancePointerResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_AdvancePointerResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .messageNotFound,
    .invalidPointerType,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_RevealIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var identity: Code_Chat_V2_ChatMemberIdentity {
    get {return _identity ?? Code_Chat_V2_ChatMemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _identity: Code_Chat_V2_ChatMemberIdentity? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_RevealIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_RevealIdentityResponse.Result = .ok

  /// The chat message that was sent if the RPC was successful
  public var message: Code_Chat_V2_ChatMessage {
    get {return _message ?? Code_Chat_V2_ChatMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case differentIdentityRevealed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .differentIdentityRevealed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .differentIdentityRevealed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _message: Code_Chat_V2_ChatMessage? = nil
}

#if swift(>=4.2)

extension Code_Chat_V2_RevealIdentityResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_RevealIdentityResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .differentIdentityRevealed,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_SetMuteStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var isMuted: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_SetMuteStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_SetMuteStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case cantMute // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .cantMute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .cantMute: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_SetMuteStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_SetMuteStateResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .cantMute,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_SetSubscriptionStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var isSubscribed: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_SetSubscriptionStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_SetSubscriptionStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case cantUnsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      case 3: self = .cantUnsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .cantUnsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_SetSubscriptionStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_SetSubscriptionStateResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
    .cantUnsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_NotifyIsTypingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var isTyping: Bool = false

  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Chat_V2_NotifyIsTypingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Chat_V2_NotifyIsTypingResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case chatNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .chatNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .chatNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_NotifyIsTypingResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_NotifyIsTypingResponse.Result] = [
    .ok,
    .denied,
    .chatNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Chat_V2_ChatId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sufficient space is left for a consistent hash value, though other types
  /// of values may be used.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_ChatMessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guaranteed to be a time-based UUID. This should be used to construct a
  /// consistently ordered message history based on time using a simple byte
  /// comparison.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_ChatMemberId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally random UUID
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A chat
///
/// todo: Support is_verified in a clean way
public struct Code_Chat_V2_ChatMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this chat
  public var chatID: Code_Chat_V2_ChatId {
    get {return _chatID ?? Code_Chat_V2_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// The type of chat
  public var type: Code_Chat_V2_ChatType = .unknownChatType

  /// The chat title, which will be localized by server when applicable
  public var title: String = String()

  /// The members in this chat
  ///
  /// For NOTIFICATION chats, this list has exactly 1 item
  /// For TWO_WAY chats, this list has exactly 2 items
  ///
  /// todo: If we support group chats, then we'll likely return the first page
  ///       or a prioritized list. The remaining members would be fetched via
  ///       a new RPC.
  public var members: [Code_Chat_V2_ChatMember] = []

  /// Can the user mute this chat?
  public var canMute: Bool = false

  /// Can the user unsubscribe from this chat?
  public var canUnsubscribe: Bool = false

  /// Cursor value for this chat for reference in subsequent GetChatsRequest
  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Code_Chat_V2_ChatId? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

/// A message in a chat
public struct Code_Chat_V2_ChatMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this message
  public var messageID: Code_Chat_V2_ChatMessageId {
    get {return _messageID ?? Code_Chat_V2_ChatMessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// The chat member that sent the message. For NOTIFICATION chats, this field
  /// is omitted since the chat has exactly 1 member.
  public var senderID: Code_Chat_V2_ChatMemberId {
    get {return _senderID ?? Code_Chat_V2_ChatMemberId()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  /// Ordered message content. A message may have more than one piece of content.
  public var content: [Code_Chat_V2_Content] = []

  /// Timestamp this message was generated at. This value is also encoded in
  /// any time-based UUID message IDs.
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// Cursor value for this message for reference in a paged GetMessagesRequest
  public var cursor: Code_Chat_V2_Cursor {
    get {return _cursor ?? Code_Chat_V2_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Code_Chat_V2_ChatMessageId? = nil
  fileprivate var _senderID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cursor: Code_Chat_V2_Cursor? = nil
}

/// A user in a chat
public struct Code_Chat_V2_ChatMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this chat member
  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// Is this chat member yourself? This enables client to identify which member_id
  /// is themselves.
  public var isSelf: Bool = false

  /// The chat member's identity if it has been revealed.
  public var identity: Code_Chat_V2_ChatMemberIdentity {
    get {return _identity ?? Code_Chat_V2_ChatMemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  /// Chat message state for this member. This list will have DELIVERED and READ
  /// pointers, if they exist. SENT pointers should be inferred by persistence
  /// on server.
  public var pointers: [Code_Chat_V2_Pointer] = []

  /// Estimated number of unread messages for the chat member in this chat
  ///
  /// Only valid when is_self = true
  public var numUnread: UInt32 = 0

  /// Has the chat member muted this chat?
  ///
  /// Only valid when is_self = true
  public var isMuted: Bool = false

  /// Is the chat member subscribed to this chat?
  ///
  /// Only valid when is_self = true
  public var isSubscribed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _identity: Code_Chat_V2_ChatMemberIdentity? = nil
}

/// Identity to an external social platform that can be linked to a Code account
public struct Code_Chat_V2_ChatMemberIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The external social platform linked to this chat member
  public var platform: Code_Chat_V2_Platform = .unknownPlatform

  /// The chat member's username on the external social platform
  public var username: String = String()

  /// If present, the URL of the users profile pic.
  public var profilePicURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Pointer in a chat indicating a user's message history state in a chat.
public struct Code_Chat_V2_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of pointer indicates which user's message history state can be
  /// inferred from the pointer value. It is also possible to infer cross-pointer
  /// state. For example, if a chat member has a READ pointer for a message with
  /// ID N, then the DELIVERED pointer must be at least N.
  public var type: Code_Chat_V2_PointerType = .unknownPointerType

  /// Everything at or before this message ID is considered to have the state
  /// inferred by the type of pointer.
  public var value: Code_Chat_V2_ChatMessageId {
    get {return _value ?? Code_Chat_V2_ChatMessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// The chat member associated with this pointer state
  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Code_Chat_V2_ChatMessageId? = nil
  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
}

/// Content for a chat message
public struct Code_Chat_V2_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Chat_V2_Content.OneOf_Type? = nil

  public var text: Code_Chat_V2_TextContent {
    get {
      if case .text(let v)? = type {return v}
      return Code_Chat_V2_TextContent()
    }
    set {type = .text(newValue)}
  }

  public var localized: Code_Chat_V2_LocalizedContent {
    get {
      if case .localized(let v)? = type {return v}
      return Code_Chat_V2_LocalizedContent()
    }
    set {type = .localized(newValue)}
  }

  public var exchangeData: Code_Chat_V2_ExchangeDataContent {
    get {
      if case .exchangeData(let v)? = type {return v}
      return Code_Chat_V2_ExchangeDataContent()
    }
    set {type = .exchangeData(newValue)}
  }

  public var naclBox: Code_Chat_V2_NaclBoxEncryptedContent {
    get {
      if case .naclBox(let v)? = type {return v}
      return Code_Chat_V2_NaclBoxEncryptedContent()
    }
    set {type = .naclBox(newValue)}
  }

  public var thankYou: Code_Chat_V2_ThankYouContent {
    get {
      if case .thankYou(let v)? = type {return v}
      return Code_Chat_V2_ThankYouContent()
    }
    set {type = .thankYou(newValue)}
  }

  public var identityRevealed: Code_Chat_V2_IdentityRevealedContent {
    get {
      if case .identityRevealed(let v)? = type {return v}
      return Code_Chat_V2_IdentityRevealedContent()
    }
    set {type = .identityRevealed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Code_Chat_V2_TextContent)
    case localized(Code_Chat_V2_LocalizedContent)
    case exchangeData(Code_Chat_V2_ExchangeDataContent)
    case naclBox(Code_Chat_V2_NaclBoxEncryptedContent)
    case thankYou(Code_Chat_V2_ThankYouContent)
    case identityRevealed(Code_Chat_V2_IdentityRevealedContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_Content.OneOf_Type, rhs: Code_Chat_V2_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localized, .localized): return {
        guard case .localized(let l) = lhs, case .localized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exchangeData, .exchangeData): return {
        guard case .exchangeData(let l) = lhs, case .exchangeData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.naclBox, .naclBox): return {
        guard case .naclBox(let l) = lhs, case .naclBox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thankYou, .thankYou): return {
        guard case .thankYou(let l) = lhs, case .thankYou(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.identityRevealed, .identityRevealed): return {
        guard case .identityRevealed(let l) = lhs, case .identityRevealed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Raw text content
public struct Code_Chat_V2_TextContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Text content that is either a localization key that should be translated on
/// client, or a server-side translated piece of text.
public struct Code_Chat_V2_LocalizedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Exchange data content for movement of a value of Kin
public struct Code_Chat_V2_ExchangeDataContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Verb describing how the amount of Kin was exchanged
  ///
  /// Note: The current definition is not suitable outside a NOTIFICATION chat
  ///       as not enough context is provided as to which member this verb is
  ///       associated with.
  public var verb: Code_Chat_V2_ExchangeDataContent.Verb = .unknown

  /// An amount of Kin being exchanged
  public var exchangeData: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData? = nil

  public var exact: Code_Transaction_V2_ExchangeData {
    get {
      if case .exact(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeData()
    }
    set {exchangeData = .exact(newValue)}
  }

  public var partial: Code_Transaction_V2_ExchangeDataWithoutRate {
    get {
      if case .partial(let v)? = exchangeData {return v}
      return Code_Transaction_V2_ExchangeDataWithoutRate()
    }
    set {exchangeData = .partial(newValue)}
  }

  /// An ID that can be referenced to the source of the exchange of Kin
  public var reference: Code_Chat_V2_ExchangeDataContent.OneOf_Reference? = nil

  public var intent: Code_Common_V1_IntentId {
    get {
      if case .intent(let v)? = reference {return v}
      return Code_Common_V1_IntentId()
    }
    set {reference = .intent(newValue)}
  }

  public var signature: Code_Common_V1_Signature {
    get {
      if case .signature(let v)? = reference {return v}
      return Code_Common_V1_Signature()
    }
    set {reference = .signature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An amount of Kin being exchanged
  public enum OneOf_ExchangeData: Equatable {
    case exact(Code_Transaction_V2_ExchangeData)
    case partial(Code_Transaction_V2_ExchangeDataWithoutRate)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData, rhs: Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exact, .exact): return {
        guard case .exact(let l) = lhs, case .exact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.partial, .partial): return {
        guard case .partial(let l) = lhs, case .partial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// An ID that can be referenced to the source of the exchange of Kin
  public enum OneOf_Reference: Equatable {
    case intent(Code_Common_V1_IntentId)
    case signature(Code_Common_V1_Signature)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Chat_V2_ExchangeDataContent.OneOf_Reference, rhs: Code_Chat_V2_ExchangeDataContent.OneOf_Reference) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.intent, .intent): return {
        guard case .intent(let l) = lhs, case .intent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signature, .signature): return {
        guard case .signature(let l) = lhs, case .signature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Verb: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case gave // = 1
    case received // = 2
    case withdrew // = 3
    case deposited // = 4
    case sent // = 5
    case returned // = 6
    case spent // = 7
    case paid // = 8
    case purchased // = 9
    case receivedTip // = 10
    case sentTip // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .gave
      case 2: self = .received
      case 3: self = .withdrew
      case 4: self = .deposited
      case 5: self = .sent
      case 6: self = .returned
      case 7: self = .spent
      case 8: self = .paid
      case 9: self = .purchased
      case 10: self = .receivedTip
      case 11: self = .sentTip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .gave: return 1
      case .received: return 2
      case .withdrew: return 3
      case .deposited: return 4
      case .sent: return 5
      case .returned: return 6
      case .spent: return 7
      case .paid: return 8
      case .purchased: return 9
      case .receivedTip: return 10
      case .sentTip: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Chat_V2_ExchangeDataContent.Verb: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Chat_V2_ExchangeDataContent.Verb] = [
    .unknown,
    .gave,
    .received,
    .withdrew,
    .deposited,
    .sent,
    .returned,
    .spent,
    .paid,
    .purchased,
    .receivedTip,
    .sentTip,
  ]
}

#endif  // swift(>=4.2)

/// Encrypted piece of content using NaCl box encryption
public struct Code_Chat_V2_NaclBoxEncryptedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sender's public key that is used to derive the shared private key for
  /// decryption for message content.
  public var peerPublicKey: Code_Common_V1_SolanaAccountId {
    get {return _peerPublicKey ?? Code_Common_V1_SolanaAccountId()}
    set {_peerPublicKey = newValue}
  }
  /// Returns true if `peerPublicKey` has been explicitly set.
  public var hasPeerPublicKey: Bool {return self._peerPublicKey != nil}
  /// Clears the value of `peerPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPeerPublicKey() {self._peerPublicKey = nil}

  /// Globally random nonce that is unique to this encrypted piece of content
  public var nonce: Data = Data()

  /// The encrypted piece of message content
  public var encryptedPayload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerPublicKey: Code_Common_V1_SolanaAccountId? = nil
}

/// Thank you content that is used to thank Code users for tips
public struct Code_Chat_V2_ThankYouContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tip intent that is being thanked.
  public var tipIntent: Code_Common_V1_IntentId {
    get {return _tipIntent ?? Code_Common_V1_IntentId()}
    set {_tipIntent = newValue}
  }
  /// Returns true if `tipIntent` has been explicitly set.
  public var hasTipIntent: Bool {return self._tipIntent != nil}
  /// Clears the value of `tipIntent`. Subsequent reads from it will return its default value.
  public mutating func clearTipIntent() {self._tipIntent = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tipIntent: Code_Common_V1_IntentId? = nil
}

/// Identity revealed content that is inserted into chat whenever a chat member
/// reveals their identity
public struct Code_Chat_V2_IdentityRevealedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The chat member who revealed their identity
  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// The identity that was revealed
  public var identity: Code_Chat_V2_ChatMemberIdentity {
    get {return _identity ?? Code_Chat_V2_ChatMemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
  fileprivate var _identity: Code_Chat_V2_ChatMemberIdentity? = nil
}

/// Opaque cursor used across paged APIs. Underlying bytes may change as paging
/// strategies evolve. Expected length value will vary based on the RPC being
/// executed.
public struct Code_Chat_V2_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Chat_V2_IsTyping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memberID: Code_Chat_V2_ChatMemberId {
    get {return _memberID ?? Code_Chat_V2_ChatMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  public var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  public mutating func clearMemberID() {self._memberID = nil}

  /// is_typing indicates whether or not the user is typing.
  /// If false, the user has explicitly stopped typing.
  public var isTyping: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberID: Code_Chat_V2_ChatMemberId? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Chat_V2_ChatType: @unchecked Sendable {}
extension Code_Chat_V2_Platform: @unchecked Sendable {}
extension Code_Chat_V2_PointerType: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsRequest: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsResponse: @unchecked Sendable {}
extension Code_Chat_V2_GetChatsResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesRequest: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesRequest.Direction: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesResponse: @unchecked Sendable {}
extension Code_Chat_V2_GetMessagesResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_OpenChatEventStream: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEvent: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEvent.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventBatch: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventError: @unchecked Sendable {}
extension Code_Chat_V2_ChatStreamEventError.Code: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsRequest: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsRequest.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsResponse: @unchecked Sendable {}
extension Code_Chat_V2_StreamChatEventsResponse.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_StartChatRequest: @unchecked Sendable {}
extension Code_Chat_V2_StartChatRequest.OneOf_Parameters: @unchecked Sendable {}
extension Code_Chat_V2_StartTwoWayChatParameters: @unchecked Sendable {}
extension Code_Chat_V2_StartChatResponse: @unchecked Sendable {}
extension Code_Chat_V2_StartChatResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageRequest: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageResponse: @unchecked Sendable {}
extension Code_Chat_V2_SendMessageResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerRequest: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerResponse: @unchecked Sendable {}
extension Code_Chat_V2_AdvancePointerResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_RevealIdentityRequest: @unchecked Sendable {}
extension Code_Chat_V2_RevealIdentityResponse: @unchecked Sendable {}
extension Code_Chat_V2_RevealIdentityResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateRequest: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateResponse: @unchecked Sendable {}
extension Code_Chat_V2_SetMuteStateResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_SetSubscriptionStateRequest: @unchecked Sendable {}
extension Code_Chat_V2_SetSubscriptionStateResponse: @unchecked Sendable {}
extension Code_Chat_V2_SetSubscriptionStateResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingRequest: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingResponse: @unchecked Sendable {}
extension Code_Chat_V2_NotifyIsTypingResponse.Result: @unchecked Sendable {}
extension Code_Chat_V2_ChatId: @unchecked Sendable {}
extension Code_Chat_V2_ChatMessageId: @unchecked Sendable {}
extension Code_Chat_V2_ChatMemberId: @unchecked Sendable {}
extension Code_Chat_V2_ChatMetadata: @unchecked Sendable {}
extension Code_Chat_V2_ChatMessage: @unchecked Sendable {}
extension Code_Chat_V2_ChatMember: @unchecked Sendable {}
extension Code_Chat_V2_ChatMemberIdentity: @unchecked Sendable {}
extension Code_Chat_V2_Pointer: @unchecked Sendable {}
extension Code_Chat_V2_Content: @unchecked Sendable {}
extension Code_Chat_V2_Content.OneOf_Type: @unchecked Sendable {}
extension Code_Chat_V2_TextContent: @unchecked Sendable {}
extension Code_Chat_V2_LocalizedContent: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.OneOf_ExchangeData: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.OneOf_Reference: @unchecked Sendable {}
extension Code_Chat_V2_ExchangeDataContent.Verb: @unchecked Sendable {}
extension Code_Chat_V2_NaclBoxEncryptedContent: @unchecked Sendable {}
extension Code_Chat_V2_ThankYouContent: @unchecked Sendable {}
extension Code_Chat_V2_IdentityRevealedContent: @unchecked Sendable {}
extension Code_Chat_V2_Cursor: @unchecked Sendable {}
extension Code_Chat_V2_IsTyping: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.chat.v2"

extension Code_Chat_V2_ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CHAT_TYPE"),
    1: .same(proto: "NOTIFICATION"),
    2: .same(proto: "TWO_WAY"),
  ]
}

extension Code_Chat_V2_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PLATFORM"),
    1: .same(proto: "TWITTER"),
  ]
}

extension Code_Chat_V2_PointerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_POINTER_TYPE"),
    1: .same(proto: "SENT"),
    2: .same(proto: "DELIVERED"),
    3: .same(proto: "READ"),
  ]
}

extension Code_Chat_V2_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "page_size"),
    4: .same(proto: "cursor"),
    5: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetChatsRequest, rhs: Code_Chat_V2_GetChatsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetChatsRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V2_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetChatsResponse, rhs: Code_Chat_V2_GetChatsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetChatsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Chat_V2_GetMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
    5: .standard(proto: "page_size"),
    6: .same(proto: "cursor"),
    7: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.direction != .asc {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetMessagesRequest, rhs: Code_Chat_V2_GetMessagesRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetMessagesRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Code_Chat_V2_GetMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_GetMessagesResponse, rhs: Code_Chat_V2_GetMessagesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_GetMessagesResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "MESSAGE_NOT_FOUND"),
  ]
}

extension Code_Chat_V2_OpenChatEventStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenChatEventStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_OpenChatEventStream, rhs: Code_Chat_V2_OpenChatEventStream) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "pointer"),
    3: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_ChatMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .message(v)
        }
      }()
      case 2: try {
        var v: Code_Chat_V2_Pointer?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pointer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pointer(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_IsTyping?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .isTyping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .isTyping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .message?: try {
      guard case .message(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pointer?: try {
      guard case .pointer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .isTyping?: try {
      guard case .isTyping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEvent, rhs: Code_Chat_V2_ChatStreamEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEventBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEventBatch, rhs: Code_Chat_V2_ChatStreamEventBatch) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamEventError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatStreamEventError, rhs: Code_Chat_V2_ChatStreamEventError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatStreamEventError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
    1: .same(proto: "CHAT_NOT_FOUND"),
  ]
}

extension Code_Chat_V2_StreamChatEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_stream"),
    2: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_OpenChatEventStream?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openStream(v)
        }
      }()
      case 2: try {
        var v: Code_Common_V1_ClientPong?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .openStream?: try {
      guard case .openStream(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StreamChatEventsRequest, rhs: Code_Chat_V2_StreamChatEventsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StreamChatEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .same(proto: "ping"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_ChatStreamEventBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .events(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .events(v)
        }
      }()
      case 2: try {
        var v: Code_Common_V1_ServerPing?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_ChatStreamEventError?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .events?: try {
      guard case .events(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StreamChatEventsResponse, rhs: Code_Chat_V2_StreamChatEventsResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .same(proto: "self"),
    4: .standard(proto: "two_way_chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      case 4: try {
        var v: Code_Chat_V2_StartTwoWayChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .twoWayChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .twoWayChat(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .twoWayChat(let v)? = self.parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartChatRequest, rhs: Code_Chat_V2_StartChatRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._self_p != rhs._self_p {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartTwoWayChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartTwoWayChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_user"),
    2: .standard(proto: "intent_id"),
    3: .same(proto: "identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherUser) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartTwoWayChatParameters, rhs: Code_Chat_V2_StartTwoWayChatParameters) -> Bool {
    if lhs._otherUser != rhs._otherUser {return false}
    if lhs._intentID != rhs._intentID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_StartChatResponse, rhs: Code_Chat_V2_StartChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_StartChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "INVALID_PARAMETER"),
    3: .same(proto: "PENDING"),
  ]
}

extension Code_Chat_V2_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .same(proto: "content"),
    4: .same(proto: "owner"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SendMessageRequest, rhs: Code_Chat_V2_SendMessageRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SendMessageResponse, rhs: Code_Chat_V2_SendMessageResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SendMessageResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "INVALID_CHAT_TYPE"),
    4: .same(proto: "INVALID_CONTENT_TYPE"),
  ]
}

extension Code_Chat_V2_AdvancePointerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "pointer"),
    3: .same(proto: "owner"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_AdvancePointerRequest, rhs: Code_Chat_V2_AdvancePointerRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_AdvancePointerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancePointerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_AdvancePointerResponse, rhs: Code_Chat_V2_AdvancePointerResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_AdvancePointerResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "MESSAGE_NOT_FOUND"),
    4: .same(proto: "INVALID_POINTER_TYPE"),
  ]
}

extension Code_Chat_V2_RevealIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevealIdentityRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .same(proto: "identity"),
    4: .same(proto: "owner"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_RevealIdentityRequest, rhs: Code_Chat_V2_RevealIdentityRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_RevealIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevealIdentityResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_RevealIdentityResponse, rhs: Code_Chat_V2_RevealIdentityResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_RevealIdentityResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "DIFFERENT_IDENTITY_REVEALED"),
  ]
}

extension Code_Chat_V2_SetMuteStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .standard(proto: "is_muted"),
    4: .same(proto: "owner"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetMuteStateRequest, rhs: Code_Chat_V2_SetMuteStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetMuteStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetMuteStateResponse, rhs: Code_Chat_V2_SetMuteStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetMuteStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "CANT_MUTE"),
  ]
}

extension Code_Chat_V2_SetSubscriptionStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .standard(proto: "is_subscribed"),
    4: .same(proto: "owner"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isSubscribed) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isSubscribed != false {
      try visitor.visitSingularBoolField(value: self.isSubscribed, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetSubscriptionStateRequest, rhs: Code_Chat_V2_SetSubscriptionStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isSubscribed != rhs.isSubscribed {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetSubscriptionStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSubscriptionStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_SetSubscriptionStateResponse, rhs: Code_Chat_V2_SetSubscriptionStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_SetSubscriptionStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
    3: .same(proto: "CANT_UNSUBSCRIBE"),
  ]
}

extension Code_Chat_V2_NotifyIsTypingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyIsTypingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "member_id"),
    3: .standard(proto: "is_typing"),
    4: .same(proto: "owner"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NotifyIsTypingRequest, rhs: Code_Chat_V2_NotifyIsTypingRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_NotifyIsTypingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyIsTypingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NotifyIsTypingResponse, rhs: Code_Chat_V2_NotifyIsTypingResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_NotifyIsTypingResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CHAT_NOT_FOUND"),
  ]
}

extension Code_Chat_V2_ChatId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatId, rhs: Code_Chat_V2_ChatId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMessageId, rhs: Code_Chat_V2_ChatMessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMemberId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMemberId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMemberId, rhs: Code_Chat_V2_ChatMemberId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "members"),
    5: .standard(proto: "can_mute"),
    6: .standard(proto: "can_unsubscribe"),
    7: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canMute) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.canUnsubscribe) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknownChatType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    if self.canMute != false {
      try visitor.visitSingularBoolField(value: self.canMute, fieldNumber: 5)
    }
    if self.canUnsubscribe != false {
      try visitor.visitSingularBoolField(value: self.canUnsubscribe, fieldNumber: 6)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMetadata, rhs: Code_Chat_V2_ChatMetadata) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.members != rhs.members {return false}
    if lhs.canMute != rhs.canMute {return false}
    if lhs.canUnsubscribe != rhs.canUnsubscribe {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
    5: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMessage, rhs: Code_Chat_V2_ChatMessage) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._senderID != rhs._senderID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "is_self"),
    3: .same(proto: "identity"),
    4: .same(proto: "pointers"),
    5: .standard(proto: "num_unread"),
    6: .standard(proto: "is_muted"),
    7: .standard(proto: "is_subscribed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isSelf) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pointers) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isSubscribed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isSelf != false {
      try visitor.visitSingularBoolField(value: self.isSelf, fieldNumber: 2)
    }
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.pointers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointers, fieldNumber: 4)
    }
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 5)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 6)
    }
    if self.isSubscribed != false {
      try visitor.visitSingularBoolField(value: self.isSubscribed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMember, rhs: Code_Chat_V2_ChatMember) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isSelf != rhs.isSelf {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.pointers != rhs.pointers {return false}
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.isSubscribed != rhs.isSubscribed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ChatMemberIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMemberIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "username"),
    3: .standard(proto: "profile_pic_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.profilePicURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .unknownPlatform {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.profilePicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePicURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ChatMemberIdentity, rhs: Code_Chat_V2_ChatMemberIdentity) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.username != rhs.username {return false}
    if lhs.profilePicURL != rhs.profilePicURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "member_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownPointerType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Pointer, rhs: Code_Chat_V2_Pointer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "localized"),
    3: .standard(proto: "exchange_data"),
    4: .standard(proto: "nacl_box"),
    5: .standard(proto: "thank_you"),
    6: .standard(proto: "identity_revealed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Chat_V2_TextContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Code_Chat_V2_LocalizedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localized(v)
        }
      }()
      case 3: try {
        var v: Code_Chat_V2_ExchangeDataContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .exchangeData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .exchangeData(v)
        }
      }()
      case 4: try {
        var v: Code_Chat_V2_NaclBoxEncryptedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .naclBox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .naclBox(v)
        }
      }()
      case 5: try {
        var v: Code_Chat_V2_ThankYouContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .thankYou(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .thankYou(v)
        }
      }()
      case 6: try {
        var v: Code_Chat_V2_IdentityRevealedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .identityRevealed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .identityRevealed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localized?: try {
      guard case .localized(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .exchangeData?: try {
      guard case .exchangeData(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .naclBox?: try {
      guard case .naclBox(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .thankYou?: try {
      guard case .thankYou(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .identityRevealed?: try {
      guard case .identityRevealed(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Content, rhs: Code_Chat_V2_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_TextContent, rhs: Code_Chat_V2_TextContent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_LocalizedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_LocalizedContent, rhs: Code_Chat_V2_LocalizedContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ExchangeDataContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verb"),
    2: .same(proto: "exact"),
    3: .same(proto: "partial"),
    4: .same(proto: "intent"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.verb) }()
      case 2: try {
        var v: Code_Transaction_V2_ExchangeData?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .exact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .exact(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_ExchangeDataWithoutRate?
        var hadOneofValue = false
        if let current = self.exchangeData {
          hadOneofValue = true
          if case .partial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exchangeData = .partial(v)
        }
      }()
      case 4: try {
        var v: Code_Common_V1_IntentId?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .intent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .intent(v)
        }
      }()
      case 5: try {
        var v: Code_Common_V1_Signature?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .signature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .signature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.verb != .unknown {
      try visitor.visitSingularEnumField(value: self.verb, fieldNumber: 1)
    }
    switch self.exchangeData {
    case .exact?: try {
      guard case .exact(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .partial?: try {
      guard case .partial(let v)? = self.exchangeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.reference {
    case .intent?: try {
      guard case .intent(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .signature?: try {
      guard case .signature(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ExchangeDataContent, rhs: Code_Chat_V2_ExchangeDataContent) -> Bool {
    if lhs.verb != rhs.verb {return false}
    if lhs.exchangeData != rhs.exchangeData {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ExchangeDataContent.Verb: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GAVE"),
    2: .same(proto: "RECEIVED"),
    3: .same(proto: "WITHDREW"),
    4: .same(proto: "DEPOSITED"),
    5: .same(proto: "SENT"),
    6: .same(proto: "RETURNED"),
    7: .same(proto: "SPENT"),
    8: .same(proto: "PAID"),
    9: .same(proto: "PURCHASED"),
    10: .same(proto: "RECEIVED_TIP"),
    11: .same(proto: "SENT_TIP"),
  ]
}

extension Code_Chat_V2_NaclBoxEncryptedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NaclBoxEncryptedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_public_key"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "encrypted_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerPublicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedPayload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.encryptedPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedPayload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_NaclBoxEncryptedContent, rhs: Code_Chat_V2_NaclBoxEncryptedContent) -> Bool {
    if lhs._peerPublicKey != rhs._peerPublicKey {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.encryptedPayload != rhs.encryptedPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_ThankYouContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThankYouContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tip_intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tipIntent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tipIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_ThankYouContent, rhs: Code_Chat_V2_ThankYouContent) -> Bool {
    if lhs._tipIntent != rhs._tipIntent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_IdentityRevealedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityRevealedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .same(proto: "identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_IdentityRevealedContent, rhs: Code_Chat_V2_IdentityRevealedContent) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_Cursor, rhs: Code_Chat_V2_Cursor) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Chat_V2_IsTyping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTyping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Chat_V2_IsTyping, rhs: Code_Chat_V2_IsTyping) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
