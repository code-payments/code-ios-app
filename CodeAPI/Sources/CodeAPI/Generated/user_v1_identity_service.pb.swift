// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: user/v1/identity_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Code_User_V1_LinkAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the owner account that will be linked to a user.
  public var ownerAccountID: Code_Common_V1_SolanaAccountId {
    get {return _ownerAccountID ?? Code_Common_V1_SolanaAccountId()}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  public var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  /// The signature is of serialize(LinkAccountRequest) without this field set
  /// using the private key of owner_account_id. This validates that the client
  /// actually owns the account.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// A one-time use token that identifies and authenticates the user.
  public var token: Code_User_V1_LinkAccountRequest.OneOf_Token? = nil

  /// A token received after successfully verifying a phone number via a
  /// SMS code using the phone verification service.
  public var phone: Code_Phone_V1_PhoneLinkingToken {
    get {
      if case .phone(let v)? = token {return v}
      return Code_Phone_V1_PhoneLinkingToken()
    }
    set {token = .phone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A one-time use token that identifies and authenticates the user.
  public enum OneOf_Token: Equatable {
    /// A token received after successfully verifying a phone number via a
    /// SMS code using the phone verification service.
    case phone(Code_Phone_V1_PhoneLinkingToken)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_LinkAccountRequest.OneOf_Token, rhs: Code_User_V1_LinkAccountRequest.OneOf_Token) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _ownerAccountID: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_User_V1_LinkAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_LinkAccountResponse.Result = .ok

  /// The user that was linked to the owner account
  public var user: Code_User_V1_User {
    get {return _user ?? Code_User_V1_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// The data container where the user can store a copy of their data
  public var dataContainerID: Code_Common_V1_DataContainerId {
    get {return _dataContainerID ?? Code_Common_V1_DataContainerId()}
    set {_dataContainerID = newValue}
  }
  /// Returns true if `dataContainerID` has been explicitly set.
  public var hasDataContainerID: Bool {return self._dataContainerID != nil}
  /// Clears the value of `dataContainerID`. Subsequent reads from it will return its default value.
  public mutating func clearDataContainerID() {self._dataContainerID = nil}

  /// Metadata about the user based for the instance of their view
  public var metadata: Code_User_V1_LinkAccountResponse.OneOf_Metadata? = nil

  /// Metadata that corresponds to a phone-based identifying feature.
  public var phone: Code_User_V1_PhoneMetadata {
    get {
      if case .phone(let v)? = metadata {return v}
      return Code_User_V1_PhoneMetadata()
    }
    set {metadata = .phone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Metadata about the user based for the instance of their view
  public enum OneOf_Metadata: Equatable {
    /// Metadata that corresponds to a phone-based identifying feature.
    case phone(Code_User_V1_PhoneMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_LinkAccountResponse.OneOf_Metadata, rhs: Code_User_V1_LinkAccountResponse.OneOf_Metadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The provided token is invalid. A token may be invalid for a number of
    /// reasons including: it's already been used, has been modified by the
    /// client or has expired.
    case invalidToken // = 1

    /// The client is rate limited (eg. by IP, user ID, etc). The client should
    /// retry at a later time.
    case rateLimited // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidToken
      case 2: self = .rateLimited
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidToken: return 1
      case .rateLimited: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _user: Code_User_V1_User? = nil
  fileprivate var _dataContainerID: Code_Common_V1_DataContainerId? = nil
}

#if swift(>=4.2)

extension Code_User_V1_LinkAccountResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_LinkAccountResponse.Result] = [
    .ok,
    .invalidToken,
    .rateLimited,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_UnlinkAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the owner account that will be unliked.
  public var ownerAccountID: Code_Common_V1_SolanaAccountId {
    get {return _ownerAccountID ?? Code_Common_V1_SolanaAccountId()}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  public var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  /// The signature is of serialize(UnlinkAccountRequest) without this field set
  /// using the private key of owner_account_id. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var identifyingFeature: Code_User_V1_UnlinkAccountRequest.OneOf_IdentifyingFeature? = nil

  /// The phone number associated with the owner account.
  public var phoneNumber: Code_Common_V1_PhoneNumber {
    get {
      if case .phoneNumber(let v)? = identifyingFeature {return v}
      return Code_Common_V1_PhoneNumber()
    }
    set {identifyingFeature = .phoneNumber(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_IdentifyingFeature: Equatable {
    /// The phone number associated with the owner account.
    case phoneNumber(Code_Common_V1_PhoneNumber)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_UnlinkAccountRequest.OneOf_IdentifyingFeature, rhs: Code_User_V1_UnlinkAccountRequest.OneOf_IdentifyingFeature) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phoneNumber, .phoneNumber): return {
        guard case .phoneNumber(let l) = lhs, case .phoneNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _ownerAccountID: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_User_V1_UnlinkAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_UnlinkAccountResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The client attempted to unlink an owner account or identifying feature
    /// that never had a valid association.
    case neverAssociated // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .neverAssociated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .neverAssociated: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_User_V1_UnlinkAccountResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_UnlinkAccountResponse.Result] = [
    .ok,
    .neverAssociated,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_GetUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the owner account that signed this request message.
  public var ownerAccountID: Code_Common_V1_SolanaAccountId {
    get {return _ownerAccountID ?? Code_Common_V1_SolanaAccountId()}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  public var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  /// The signature is of serialize(GetUserRequest) without this field set
  /// using the private key of owner_account_id. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// The user's indentifying feature, which maps to an instance of a view.
  public var identifyingFeature: Code_User_V1_GetUserRequest.OneOf_IdentifyingFeature? = nil

  public var phoneNumber: Code_Common_V1_PhoneNumber {
    get {
      if case .phoneNumber(let v)? = identifyingFeature {return v}
      return Code_Common_V1_PhoneNumber()
    }
    set {identifyingFeature = .phoneNumber(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The user's indentifying feature, which maps to an instance of a view.
  public enum OneOf_IdentifyingFeature: Equatable {
    case phoneNumber(Code_Common_V1_PhoneNumber)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_GetUserRequest.OneOf_IdentifyingFeature, rhs: Code_User_V1_GetUserRequest.OneOf_IdentifyingFeature) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phoneNumber, .phoneNumber): return {
        guard case .phoneNumber(let l) = lhs, case .phoneNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _ownerAccountID: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_User_V1_GetUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_GetUserResponse.Result = .ok

  /// The user associated with the identifier
  public var user: Code_User_V1_User {
    get {return _user ?? Code_User_V1_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// The data container where the user can store a copy of their data
  public var dataContainerID: Code_Common_V1_DataContainerId {
    get {return _dataContainerID ?? Code_Common_V1_DataContainerId()}
    set {_dataContainerID = newValue}
  }
  /// Returns true if `dataContainerID` has been explicitly set.
  public var hasDataContainerID: Bool {return self._dataContainerID != nil}
  /// Clears the value of `dataContainerID`. Subsequent reads from it will return its default value.
  public mutating func clearDataContainerID() {self._dataContainerID = nil}

  /// Metadata about the user based for the instance of their view
  public var metadata: Code_User_V1_GetUserResponse.OneOf_Metadata? = nil

  /// Metadata that corresponds to a phone-based identifying feature.
  public var phone: Code_User_V1_PhoneMetadata {
    get {
      if case .phone(let v)? = metadata {return v}
      return Code_User_V1_PhoneMetadata()
    }
    set {metadata = .phone(newValue)}
  }

  /// Whether client internal flags are enabled for this user
  public var enableInternalFlags: Bool = false

  /// Set of which airdrops the user is eligible to receive
  public var eligibleAirdrops: [Code_Transaction_V2_AirdropType] = []

  /// Wether the buy module is enabled for this user
  public var enableBuyModule: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Metadata about the user based for the instance of their view
  public enum OneOf_Metadata: Equatable {
    /// Metadata that corresponds to a phone-based identifying feature.
    case phone(Code_User_V1_PhoneMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_GetUserResponse.OneOf_Metadata, rhs: Code_User_V1_GetUserResponse.OneOf_Metadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The user doesn't exist
    case notFound // = 1

    /// The user is no longer invited
    case notInvited // = 2

    /// The user exists, but at least one of their timelock accounts is unlocked
    case unlockedTimelockAccount // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .notInvited
      case 3: self = .unlockedTimelockAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .notInvited: return 2
      case .unlockedTimelockAccount: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _user: Code_User_V1_User? = nil
  fileprivate var _dataContainerID: Code_Common_V1_DataContainerId? = nil
}

#if swift(>=4.2)

extension Code_User_V1_GetUserResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_GetUserResponse.Result] = [
    .ok,
    .notFound,
    .notInvited,
    .unlockedTimelockAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_UpdatePreferencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the owner account that signed this request message.
  public var ownerAccountID: Code_Common_V1_SolanaAccountId {
    get {return _ownerAccountID ?? Code_Common_V1_SolanaAccountId()}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  public var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  /// The data container for the copy of the contact list being added to.
  public var containerID: Code_Common_V1_DataContainerId {
    get {return _containerID ?? Code_Common_V1_DataContainerId()}
    set {_containerID = newValue}
  }
  /// Returns true if `containerID` has been explicitly set.
  public var hasContainerID: Bool {return self._containerID != nil}
  /// Clears the value of `containerID`. Subsequent reads from it will return its default value.
  public mutating func clearContainerID() {self._containerID = nil}

  /// The signature is of serialize(UpdatePreferencesRequest) without this field set
  /// using the private key of owner_account_id.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// The user's locale, which is used for server-side localization of things like
  /// chat messages, pushes, etc. If no locale is set, or the provided locale isn't
  /// supported, then English is used as the default fallback.
  ///
  /// Note: This is required since it's the only preference. In the future, we'll add
  ///       optional fields, where the subset of fields provided will be the ones that
  ///       are updated.
  public var locale: Code_Common_V1_Locale {
    get {return _locale ?? Code_Common_V1_Locale()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {self._locale = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ownerAccountID: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _containerID: Code_Common_V1_DataContainerId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _locale: Code_Common_V1_Locale? = nil
}

public struct Code_User_V1_UpdatePreferencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_UpdatePreferencesResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The provided locale couldn't be parsed or recognized and is invalid.
    case invalidLocale // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidLocale
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidLocale: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_User_V1_UpdatePreferencesResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_UpdatePreferencesResponse.Result] = [
    .ok,
    .invalidLocale,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_LoginToThirdPartyAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID identifying the instance of the login flow.
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The relationship authority account logging in.
  public var userID: Code_Common_V1_SolanaAccountId {
    get {return _userID ?? Code_Common_V1_SolanaAccountId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// Signature of this message using the user private key, which authenticates
  /// the user.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
  fileprivate var _userID: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_User_V1_LoginToThirdPartyAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_LoginToThirdPartyAppResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// This supports idempotency. The same login with the same user will result
    /// in OK.
    case ok // = 0

    /// There is no request for the provided intent ID.
    case requestNotFound // = 1

    /// The request requires a payment. Call SubmitIntent instead.
    case paymentRequired // = 2

    /// The request exists, but doesn't support login.
    case loginNotSupported // = 3

    /// A login with a different user already exists
    case differentLoginExists // = 4

    /// The provided account is not valid for login. It must be a relationship
    /// account with the correct identifier specified in the original request.
    case invalidAccount // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .requestNotFound
      case 2: self = .paymentRequired
      case 3: self = .loginNotSupported
      case 4: self = .differentLoginExists
      case 5: self = .invalidAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .requestNotFound: return 1
      case .paymentRequired: return 2
      case .loginNotSupported: return 3
      case .differentLoginExists: return 4
      case .invalidAccount: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_User_V1_LoginToThirdPartyAppResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_LoginToThirdPartyAppResponse.Result] = [
    .ok,
    .requestNotFound,
    .paymentRequired,
    .loginNotSupported,
    .differentLoginExists,
    .invalidAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_GetLoginForThirdPartyAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID identifying the instance of the login flow.
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// Owner account owned by the third party used in domain verification.
  public var verifier: Code_Common_V1_SolanaAccountId {
    get {return _verifier ?? Code_Common_V1_SolanaAccountId()}
    set {_verifier = newValue}
  }
  /// Returns true if `verifier` has been explicitly set.
  public var hasVerifier: Bool {return self._verifier != nil}
  /// Clears the value of `verifier`. Subsequent reads from it will return its default value.
  public mutating func clearVerifier() {self._verifier = nil}

  /// Signature of this message using the verifier private key, which in addition
  /// to domain verification, authenticates the third party.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
  fileprivate var _verifier: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_User_V1_GetLoginForThirdPartyAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_GetLoginForThirdPartyAppResponse.Result = .ok

  /// The relationship authority account that logged in.
  public var userID: Code_Common_V1_SolanaAccountId {
    get {return _userID ?? Code_Common_V1_SolanaAccountId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// There is no request for the provided intent ID.
    case requestNotFound // = 1

    /// The request exists, but doesn't support login.
    case loginNotSupported // = 2

    /// The intent supports login, but it hasn't been submitted. There is no
    /// logged in user yet.
    case noUserLoggedIn // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .requestNotFound
      case 2: self = .loginNotSupported
      case 3: self = .noUserLoggedIn
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .requestNotFound: return 1
      case .loginNotSupported: return 2
      case .noUserLoggedIn: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _userID: Code_Common_V1_SolanaAccountId? = nil
}

#if swift(>=4.2)

extension Code_User_V1_GetLoginForThirdPartyAppResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_GetLoginForThirdPartyAppResponse.Result] = [
    .ok,
    .requestNotFound,
    .loginNotSupported,
    .noUserLoggedIn,
  ]
}

#endif  // swift(>=4.2)

public struct Code_User_V1_GetTwitterUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: Code_User_V1_GetTwitterUserRequest.OneOf_Query? = nil

  /// The Twitter username to query against
  public var username: String {
    get {
      if case .username(let v)? = query {return v}
      return String()
    }
    set {query = .username(newValue)}
  }

  /// The tip address to query against
  public var tipAddress: Code_Common_V1_SolanaAccountId {
    get {
      if case .tipAddress(let v)? = query {return v}
      return Code_Common_V1_SolanaAccountId()
    }
    set {query = .tipAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Query: Equatable {
    /// The Twitter username to query against
    case username(String)
    /// The tip address to query against
    case tipAddress(Code_Common_V1_SolanaAccountId)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_User_V1_GetTwitterUserRequest.OneOf_Query, rhs: Code_User_V1_GetTwitterUserRequest.OneOf_Query) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.username, .username): return {
        guard case .username(let l) = lhs, case .username(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tipAddress, .tipAddress): return {
        guard case .tipAddress(let l) = lhs, case .tipAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_User_V1_GetTwitterUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_User_V1_GetTwitterUserResponse.Result = .ok

  public var twitterUser: Code_User_V1_TwitterUser {
    get {return _twitterUser ?? Code_User_V1_TwitterUser()}
    set {_twitterUser = newValue}
  }
  /// Returns true if `twitterUser` has been explicitly set.
  public var hasTwitterUser: Bool {return self._twitterUser != nil}
  /// Clears the value of `twitterUser`. Subsequent reads from it will return its default value.
  public mutating func clearTwitterUser() {self._twitterUser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The Twitter user doesn't exist or isn't linked with a Code account
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _twitterUser: Code_User_V1_TwitterUser? = nil
}

#if swift(>=4.2)

extension Code_User_V1_GetTwitterUserResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_GetTwitterUserResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

/// User is the highest order of a form of identity within Code.
///
/// Note: Users outside Code are modelled as relationship accounts
public struct Code_User_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's ID
  public var id: Code_Common_V1_UserId {
    get {return _id ?? Code_Common_V1_UserId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The identifying features that are associated with the user
  public var view: Code_User_V1_View {
    get {return _view ?? Code_User_V1_View()}
    set {_view = newValue}
  }
  /// Returns true if `view` has been explicitly set.
  public var hasView: Bool {return self._view != nil}
  /// Clears the value of `view`. Subsequent reads from it will return its default value.
  public mutating func clearView() {self._view = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Code_Common_V1_UserId? = nil
  fileprivate var _view: Code_User_V1_View? = nil
}

/// View is a well-defined set of identifying features. It is contrained to having
/// exactly one feature set at a time, for now.
public struct Code_User_V1_View {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The phone number associated with a user.
  ///
  /// Note: This field is mandatory as of right now, since it's the only one
  ///       supported to date.
  public var phoneNumber: Code_Common_V1_PhoneNumber {
    get {return _phoneNumber ?? Code_Common_V1_PhoneNumber()}
    set {_phoneNumber = newValue}
  }
  /// Returns true if `phoneNumber` has been explicitly set.
  public var hasPhoneNumber: Bool {return self._phoneNumber != nil}
  /// Clears the value of `phoneNumber`. Subsequent reads from it will return its default value.
  public mutating func clearPhoneNumber() {self._phoneNumber = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _phoneNumber: Code_Common_V1_PhoneNumber? = nil
}

public struct Code_User_V1_PhoneMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// State that determines whether a phone number is linked to the owner
  /// account. A phone number is linked if we can treat it as an alias.
  /// This is notably different from association, which answers the question
  /// of whether the number was linked at any point in time.
  public var isLinked: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_User_V1_TwitterUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key for a token account where tips are routed
  public var tipAddress: Code_Common_V1_SolanaAccountId {
    get {return _tipAddress ?? Code_Common_V1_SolanaAccountId()}
    set {_tipAddress = newValue}
  }
  /// Returns true if `tipAddress` has been explicitly set.
  public var hasTipAddress: Bool {return self._tipAddress != nil}
  /// Clears the value of `tipAddress`. Subsequent reads from it will return its default value.
  public mutating func clearTipAddress() {self._tipAddress = nil}

  /// The user's username on Twitter
  public var username: String = String()

  /// The user's friendly name on Twitter
  public var name: String = String()

  /// URL to the user's Twitter profile picture
  public var profilePicURL: String = String()

  /// The type of Twitter verification associated with the user
  public var verifiedType: Code_User_V1_TwitterUser.VerifiedType = .none

  /// The number of followers the user has on Twitter
  public var followerCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum VerifiedType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0
    case blue // = 1
    case business // = 2
    case government // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .blue
      case 2: self = .business
      case 3: self = .government
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .blue: return 1
      case .business: return 2
      case .government: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _tipAddress: Code_Common_V1_SolanaAccountId? = nil
}

#if swift(>=4.2)

extension Code_User_V1_TwitterUser.VerifiedType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_User_V1_TwitterUser.VerifiedType] = [
    .none,
    .blue,
    .business,
    .government,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_User_V1_LinkAccountRequest: @unchecked Sendable {}
extension Code_User_V1_LinkAccountRequest.OneOf_Token: @unchecked Sendable {}
extension Code_User_V1_LinkAccountResponse: @unchecked Sendable {}
extension Code_User_V1_LinkAccountResponse.OneOf_Metadata: @unchecked Sendable {}
extension Code_User_V1_LinkAccountResponse.Result: @unchecked Sendable {}
extension Code_User_V1_UnlinkAccountRequest: @unchecked Sendable {}
extension Code_User_V1_UnlinkAccountRequest.OneOf_IdentifyingFeature: @unchecked Sendable {}
extension Code_User_V1_UnlinkAccountResponse: @unchecked Sendable {}
extension Code_User_V1_UnlinkAccountResponse.Result: @unchecked Sendable {}
extension Code_User_V1_GetUserRequest: @unchecked Sendable {}
extension Code_User_V1_GetUserRequest.OneOf_IdentifyingFeature: @unchecked Sendable {}
extension Code_User_V1_GetUserResponse: @unchecked Sendable {}
extension Code_User_V1_GetUserResponse.OneOf_Metadata: @unchecked Sendable {}
extension Code_User_V1_GetUserResponse.Result: @unchecked Sendable {}
extension Code_User_V1_UpdatePreferencesRequest: @unchecked Sendable {}
extension Code_User_V1_UpdatePreferencesResponse: @unchecked Sendable {}
extension Code_User_V1_UpdatePreferencesResponse.Result: @unchecked Sendable {}
extension Code_User_V1_LoginToThirdPartyAppRequest: @unchecked Sendable {}
extension Code_User_V1_LoginToThirdPartyAppResponse: @unchecked Sendable {}
extension Code_User_V1_LoginToThirdPartyAppResponse.Result: @unchecked Sendable {}
extension Code_User_V1_GetLoginForThirdPartyAppRequest: @unchecked Sendable {}
extension Code_User_V1_GetLoginForThirdPartyAppResponse: @unchecked Sendable {}
extension Code_User_V1_GetLoginForThirdPartyAppResponse.Result: @unchecked Sendable {}
extension Code_User_V1_GetTwitterUserRequest: @unchecked Sendable {}
extension Code_User_V1_GetTwitterUserRequest.OneOf_Query: @unchecked Sendable {}
extension Code_User_V1_GetTwitterUserResponse: @unchecked Sendable {}
extension Code_User_V1_GetTwitterUserResponse.Result: @unchecked Sendable {}
extension Code_User_V1_User: @unchecked Sendable {}
extension Code_User_V1_View: @unchecked Sendable {}
extension Code_User_V1_PhoneMetadata: @unchecked Sendable {}
extension Code_User_V1_TwitterUser: @unchecked Sendable {}
extension Code_User_V1_TwitterUser.VerifiedType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.user.v1"

extension Code_User_V1_LinkAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_account_id"),
    2: .same(proto: "signature"),
    3: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try {
        var v: Code_Phone_V1_PhoneLinkingToken?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .phone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .phone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .phone(let v)? = self.token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_LinkAccountRequest, rhs: Code_User_V1_LinkAccountRequest) -> Bool {
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_LinkAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "user"),
    3: .standard(proto: "data_container_id"),
    5: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dataContainerID) }()
      case 5: try {
        var v: Code_User_V1_PhoneMetadata?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .phone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .phone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dataContainerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .phone(let v)? = self.metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_LinkAccountResponse, rhs: Code_User_V1_LinkAccountResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._user != rhs._user {return false}
    if lhs._dataContainerID != rhs._dataContainerID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_LinkAccountResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "RATE_LIMITED"),
  ]
}

extension Code_User_V1_UnlinkAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnlinkAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_account_id"),
    2: .same(proto: "signature"),
    4: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 4: try {
        var v: Code_Common_V1_PhoneNumber?
        var hadOneofValue = false
        if let current = self.identifyingFeature {
          hadOneofValue = true
          if case .phoneNumber(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifyingFeature = .phoneNumber(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .phoneNumber(let v)? = self.identifyingFeature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_UnlinkAccountRequest, rhs: Code_User_V1_UnlinkAccountRequest) -> Bool {
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.identifyingFeature != rhs.identifyingFeature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_UnlinkAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnlinkAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_UnlinkAccountResponse, rhs: Code_User_V1_UnlinkAccountResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_UnlinkAccountResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NEVER_ASSOCIATED"),
  ]
}

extension Code_User_V1_GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_account_id"),
    2: .same(proto: "signature"),
    3: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try {
        var v: Code_Common_V1_PhoneNumber?
        var hadOneofValue = false
        if let current = self.identifyingFeature {
          hadOneofValue = true
          if case .phoneNumber(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifyingFeature = .phoneNumber(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .phoneNumber(let v)? = self.identifyingFeature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetUserRequest, rhs: Code_User_V1_GetUserRequest) -> Bool {
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.identifyingFeature != rhs.identifyingFeature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "user"),
    3: .standard(proto: "data_container_id"),
    5: .same(proto: "phone"),
    6: .standard(proto: "enable_internal_flags"),
    7: .standard(proto: "eligible_airdrops"),
    8: .standard(proto: "enable_buy_module"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dataContainerID) }()
      case 5: try {
        var v: Code_User_V1_PhoneMetadata?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .phone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .phone(v)
        }
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableInternalFlags) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.eligibleAirdrops) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enableBuyModule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dataContainerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .phone(let v)? = self.metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.enableInternalFlags != false {
      try visitor.visitSingularBoolField(value: self.enableInternalFlags, fieldNumber: 6)
    }
    if !self.eligibleAirdrops.isEmpty {
      try visitor.visitPackedEnumField(value: self.eligibleAirdrops, fieldNumber: 7)
    }
    if self.enableBuyModule != false {
      try visitor.visitSingularBoolField(value: self.enableBuyModule, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetUserResponse, rhs: Code_User_V1_GetUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._user != rhs._user {return false}
    if lhs._dataContainerID != rhs._dataContainerID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.enableInternalFlags != rhs.enableInternalFlags {return false}
    if lhs.eligibleAirdrops != rhs.eligibleAirdrops {return false}
    if lhs.enableBuyModule != rhs.enableBuyModule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetUserResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
    2: .same(proto: "NOT_INVITED"),
    3: .same(proto: "UNLOCKED_TIMELOCK_ACCOUNT"),
  ]
}

extension Code_User_V1_UpdatePreferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePreferencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_account_id"),
    2: .standard(proto: "container_id"),
    3: .same(proto: "signature"),
    4: .same(proto: "locale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._containerID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._containerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_UpdatePreferencesRequest, rhs: Code_User_V1_UpdatePreferencesRequest) -> Bool {
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._containerID != rhs._containerID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_UpdatePreferencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePreferencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_UpdatePreferencesResponse, rhs: Code_User_V1_UpdatePreferencesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_UpdatePreferencesResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_LOCALE"),
  ]
}

extension Code_User_V1_LoginToThirdPartyAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginToThirdPartyAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_LoginToThirdPartyAppRequest, rhs: Code_User_V1_LoginToThirdPartyAppRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_LoginToThirdPartyAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginToThirdPartyAppResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_LoginToThirdPartyAppResponse, rhs: Code_User_V1_LoginToThirdPartyAppResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_LoginToThirdPartyAppResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "REQUEST_NOT_FOUND"),
    2: .same(proto: "PAYMENT_REQUIRED"),
    3: .same(proto: "LOGIN_NOT_SUPPORTED"),
    4: .same(proto: "DIFFERENT_LOGIN_EXISTS"),
    5: .same(proto: "INVALID_ACCOUNT"),
  ]
}

extension Code_User_V1_GetLoginForThirdPartyAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLoginForThirdPartyAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .same(proto: "verifier"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._verifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._verifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetLoginForThirdPartyAppRequest, rhs: Code_User_V1_GetLoginForThirdPartyAppRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs._verifier != rhs._verifier {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetLoginForThirdPartyAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLoginForThirdPartyAppResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetLoginForThirdPartyAppResponse, rhs: Code_User_V1_GetLoginForThirdPartyAppResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetLoginForThirdPartyAppResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "REQUEST_NOT_FOUND"),
    2: .same(proto: "LOGIN_NOT_SUPPORTED"),
    3: .same(proto: "NO_USER_LOGGED_IN"),
  ]
}

extension Code_User_V1_GetTwitterUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTwitterUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "tip_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.query != nil {try decoder.handleConflictingOneOf()}
          self.query = .username(v)
        }
      }()
      case 2: try {
        var v: Code_Common_V1_SolanaAccountId?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .tipAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .tipAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.query {
    case .username?: try {
      guard case .username(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .tipAddress?: try {
      guard case .tipAddress(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetTwitterUserRequest, rhs: Code_User_V1_GetTwitterUserRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetTwitterUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTwitterUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "twitter_user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._twitterUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._twitterUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_GetTwitterUserResponse, rhs: Code_User_V1_GetTwitterUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._twitterUser != rhs._twitterUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_GetTwitterUserResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_User_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "view"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._view) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._view {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_User, rhs: Code_User_V1_User) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._view != rhs._view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._phoneNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._phoneNumber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_View, rhs: Code_User_V1_View) -> Bool {
    if lhs._phoneNumber != rhs._phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_PhoneMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhoneMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_linked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLinked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLinked != false {
      try visitor.visitSingularBoolField(value: self.isLinked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_PhoneMetadata, rhs: Code_User_V1_PhoneMetadata) -> Bool {
    if lhs.isLinked != rhs.isLinked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_TwitterUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TwitterUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tip_address"),
    2: .same(proto: "username"),
    3: .same(proto: "name"),
    4: .standard(proto: "profile_pic_url"),
    5: .standard(proto: "verified_type"),
    6: .standard(proto: "follower_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tipAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.profilePicURL) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.verifiedType) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.followerCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tipAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.profilePicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePicURL, fieldNumber: 4)
    }
    if self.verifiedType != .none {
      try visitor.visitSingularEnumField(value: self.verifiedType, fieldNumber: 5)
    }
    if self.followerCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.followerCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_User_V1_TwitterUser, rhs: Code_User_V1_TwitterUser) -> Bool {
    if lhs._tipAddress != rhs._tipAddress {return false}
    if lhs.username != rhs.username {return false}
    if lhs.name != rhs.name {return false}
    if lhs.profilePicURL != rhs.profilePicURL {return false}
    if lhs.verifiedType != rhs.verifiedType {return false}
    if lhs.followerCount != rhs.followerCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_User_V1_TwitterUser.VerifiedType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "BUSINESS"),
    3: .same(proto: "GOVERNMENT"),
  ]
}
