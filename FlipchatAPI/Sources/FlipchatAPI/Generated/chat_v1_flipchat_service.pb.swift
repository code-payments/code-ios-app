// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/flipchat_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Flipchat_Chat_V1_StreamChatEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type? = nil

  public var params: Flipchat_Chat_V1_StreamChatEventsRequest.Params {
    get {
      if case .params(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsRequest.Params()
    }
    set {type = .params(newValue)}
  }

  public var pong: Flipchat_Common_V1_ClientPong {
    get {
      if case .pong(let v)? = type {return v}
      return Flipchat_Common_V1_ClientPong()
    }
    set {type = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case params(Flipchat_Chat_V1_StreamChatEventsRequest.Params)
    case pong(Flipchat_Common_V1_ClientPong)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type, rhs: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.params, .params): return {
        guard case .params(let l) = lhs, case .params(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Params {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var auth: Flipchat_Common_V1_Auth {
      get {return _auth ?? Flipchat_Common_V1_Auth()}
      set {_auth = newValue}
    }
    /// Returns true if `auth` has been explicitly set.
    public var hasAuth: Bool {return self._auth != nil}
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    public mutating func clearAuth() {self._auth = nil}

    /// ts contains the time for stream open.
    ///
    /// It is used primarily as a nonce for auth. Server may reject
    /// timestamps that are too far in the future or past.
    public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_ts = newValue}
    }
    /// Returns true if `ts` has been explicitly set.
    public var hasTs: Bool {return self._ts != nil}
    /// Clears the value of `ts`. Subsequent reads from it will return its default value.
    public mutating func clearTs() {self._ts = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
    fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}
}

public struct Flipchat_Chat_V1_StreamChatEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type? = nil

  public var ping: Flipchat_Common_V1_ServerPing {
    get {
      if case .ping(let v)? = type {return v}
      return Flipchat_Common_V1_ServerPing()
    }
    set {type = .ping(newValue)}
  }

  public var error: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError {
    get {
      if case .error(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsResponse.StreamError()
    }
    set {type = .error(newValue)}
  }

  public var events: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch {
    get {
      if case .events(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch()
    }
    set {type = .events(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case ping(Flipchat_Common_V1_ServerPing)
    case error(Flipchat_Chat_V1_StreamChatEventsResponse.StreamError)
    case events(Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.events, .events): return {
        guard case .events(let l) = lhs, case .events(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct StreamError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code = .denied

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case denied // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct EventBatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var updates: [Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// ChatUpdate contains a set of updates for a given chat id.
  ///
  /// Only the relevant fields will be set on update. On initial
  /// stream open, all fields will be set, however.
  public struct ChatUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var chatID: Flipchat_Common_V1_ChatId {
      get {return _storage._chatID ?? Flipchat_Common_V1_ChatId()}
      set {_uniqueStorage()._chatID = newValue}
    }
    /// Returns true if `chatID` has been explicitly set.
    public var hasChatID: Bool {return _storage._chatID != nil}
    /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
    public mutating func clearChatID() {_uniqueStorage()._chatID = nil}

    /// metadata contains the latest (full) metadata of the chat.
    public var metadata: Flipchat_Chat_V1_Metadata {
      get {return _storage._metadata ?? Flipchat_Chat_V1_Metadata()}
      set {_uniqueStorage()._metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return _storage._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

    /// MemberUpdate contains an update to the membership set.
    public var memberUpdate: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate {
      get {return _storage._memberUpdate ?? Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate()}
      set {_uniqueStorage()._memberUpdate = newValue}
    }
    /// Returns true if `memberUpdate` has been explicitly set.
    public var hasMemberUpdate: Bool {return _storage._memberUpdate != nil}
    /// Clears the value of `memberUpdate`. Subsequent reads from it will return its default value.
    public mutating func clearMemberUpdate() {_uniqueStorage()._memberUpdate = nil}

    /// Message contains the last known message of the chat.
    public var lastMessage: Flipchat_Messaging_V1_Message {
      get {return _storage._lastMessage ?? Flipchat_Messaging_V1_Message()}
      set {_uniqueStorage()._lastMessage = newValue}
    }
    /// Returns true if `lastMessage` has been explicitly set.
    public var hasLastMessage: Bool {return _storage._lastMessage != nil}
    /// Clears the value of `lastMessage`. Subsequent reads from it will return its default value.
    public mutating func clearLastMessage() {_uniqueStorage()._lastMessage = nil}

    /// where 'relevant' means "relevant to UI updates". For example,
    /// when a user has read the latest message.
    public var pointer: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate {
      get {return _storage._pointer ?? Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate()}
      set {_uniqueStorage()._pointer = newValue}
    }
    /// Returns true if `pointer` has been explicitly set.
    public var hasPointer: Bool {return _storage._pointer != nil}
    /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
    public mutating func clearPointer() {_uniqueStorage()._pointer = nil}

    /// IsTyping indicates whether or not someone is typing in the group.
    public var isTyping: Flipchat_Messaging_V1_IsTyping {
      get {return _storage._isTyping ?? Flipchat_Messaging_V1_IsTyping()}
      set {_uniqueStorage()._isTyping = newValue}
    }
    /// Returns true if `isTyping` has been explicitly set.
    public var hasIsTyping: Bool {return _storage._isTyping != nil}
    /// Clears the value of `isTyping`. Subsequent reads from it will return its default value.
    public mutating func clearIsTyping() {_uniqueStorage()._isTyping = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct PointerUpdate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Common_V1_UserId {
        get {return _member ?? Flipchat_Common_V1_UserId()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var pointer: Flipchat_Messaging_V1_Pointer {
        get {return _pointer ?? Flipchat_Messaging_V1_Pointer()}
        set {_pointer = newValue}
      }
      /// Returns true if `pointer` has been explicitly set.
      public var hasPointer: Bool {return self._pointer != nil}
      /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
      public mutating func clearPointer() {self._pointer = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Common_V1_UserId? = nil
      fileprivate var _pointer: Flipchat_Messaging_V1_Pointer? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct MemberUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind? = nil

    public var refresh: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh {
      get {
        if case .refresh(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh()
      }
      set {kind = .refresh(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case refresh(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh)

    #if !swift(>=4.1)
      public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.refresh, .refresh): return {
          guard case .refresh(let l) = lhs, case .refresh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public struct Refresh {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var members: [Flipchat_Chat_V1_Member] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code] = [
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_GetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var queryOptions: Flipchat_Common_V1_QueryOptions {
    get {return _queryOptions ?? Flipchat_Common_V1_QueryOptions()}
    set {_queryOptions = newValue}
  }
  /// Returns true if `queryOptions` has been explicitly set.
  public var hasQueryOptions: Bool {return self._queryOptions != nil}
  /// Clears the value of `queryOptions`. Subsequent reads from it will return its default value.
  public mutating func clearQueryOptions() {self._queryOptions = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queryOptions: Flipchat_Common_V1_QueryOptions? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_GetChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_GetChatsResponse.Result = .ok

  public var chats: [Flipchat_Chat_V1_Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_GetChatsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_GetChatsResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_GetChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier? = nil

  public var chatID: Flipchat_Common_V1_ChatId {
    get {
      if case .chatID(let v)? = identifier {return v}
      return Flipchat_Common_V1_ChatId()
    }
    set {identifier = .chatID(newValue)}
  }

  public var roomNumber: UInt64 {
    get {
      if case .roomNumber(let v)? = identifier {return v}
      return 0
    }
    set {identifier = .roomNumber(newValue)}
  }

  /// Auth is an optional field that authenticates the call, which
  /// can be used to fill out extra information in the Metadata.
  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Identifier: Equatable {
    case chatID(Flipchat_Common_V1_ChatId)
    case roomNumber(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier, rhs: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatID, .chatID): return {
        guard case .chatID(let l) = lhs, case .chatID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomNumber, .roomNumber): return {
        guard case .roomNumber(let l) = lhs, case .roomNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_GetChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_GetChatResponse.Result = .ok

  /// Metadata is the chat metadata, if result == OK.
  ///
  /// The contents of the metadata may change whether or not the
  /// call was authenticated.
  public var metadata: Flipchat_Chat_V1_Metadata {
    get {return _metadata ?? Flipchat_Chat_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Members contains the chat members, if result == OK.
  public var members: [Flipchat_Chat_V1_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_GetChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_GetChatResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_StartChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parameters: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters? = nil

  public var twoWayChat: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters {
    get {
      if case .twoWayChat(let v)? = parameters {return v}
      return Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters()
    }
    set {parameters = .twoWayChat(newValue)}
  }

  public var groupChat: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters {
    get {
      if case .groupChat(let v)? = parameters {return v}
      return Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters()
    }
    set {parameters = .groupChat(newValue)}
  }

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parameters: Equatable {
    case twoWayChat(Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters)
    case groupChat(Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters, rhs: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.twoWayChat, .twoWayChat): return {
        guard case .twoWayChat(let l) = lhs, case .twoWayChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupChat, .groupChat): return {
        guard case .groupChat(let l) = lhs, case .groupChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// StartTwoWayChatParameters contains the parameters required to start
  /// or recover a two way chat between the caller and the specified 'other_user'.
  ///
  /// The 'other_user' is currently the 'tip_address', normally retrieved from
  /// user.Identity.GetTwitterUser(username).
  public struct StartTwoWayChatParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account id of the user the caller wishes to chat with.
    public var otherUserID: Flipchat_Common_V1_UserId {
      get {return _otherUserID ?? Flipchat_Common_V1_UserId()}
      set {_otherUserID = newValue}
    }
    /// Returns true if `otherUserID` has been explicitly set.
    public var hasOtherUserID: Bool {return self._otherUserID != nil}
    /// Clears the value of `otherUserID`. Subsequent reads from it will return its default value.
    public mutating func clearOtherUserID() {self._otherUserID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _otherUserID: Flipchat_Common_V1_UserId? = nil
  }

  public struct StartGroupChatParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A set of users (not including self) to initially set in the group chat.
    public var users: [Flipchat_Common_V1_UserId] = []

    /// Optional title to set for the group.
    public var title: String = String()

    /// Optional payment for creating the group. It's up to server to decide
    /// if the user is allowed to create a group without payment.
    public var paymentIntent: Flipchat_Common_V1_IntentId {
      get {return _paymentIntent ?? Flipchat_Common_V1_IntentId()}
      set {_paymentIntent = newValue}
    }
    /// Returns true if `paymentIntent` has been explicitly set.
    public var hasPaymentIntent: Bool {return self._paymentIntent != nil}
    /// Clears the value of `paymentIntent`. Subsequent reads from it will return its default value.
    public mutating func clearPaymentIntent() {self._paymentIntent = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _paymentIntent: Flipchat_Common_V1_IntentId? = nil
  }

  public init() {}

  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_StartChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_StartChatResponse.Result = .ok

  /// The chat to use if the RPC was successful.
  public var chat: Flipchat_Chat_V1_Metadata {
    get {return _chat ?? Flipchat_Chat_V1_Metadata()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// DENIED indicates the caller is not allowed to start/join the chat.
    case denied // = 1

    /// USER_NOT_FOUND indicates that (one of) the target user's was not found.
    case userNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .userNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .userNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chat: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_StartChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_StartChatResponse.Result] = [
    .ok,
    .denied,
    .userNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_StartGroupChatPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user creating the group chat, who will be the initial owner
  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
}

public struct Flipchat_Chat_V1_JoinChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier? = nil

  public var chatID: Flipchat_Common_V1_ChatId {
    get {
      if case .chatID(let v)? = identifier {return v}
      return Flipchat_Common_V1_ChatId()
    }
    set {identifier = .chatID(newValue)}
  }

  public var roomID: UInt64 {
    get {
      if case .roomID(let v)? = identifier {return v}
      return 0
    }
    set {identifier = .roomID(newValue)}
  }

  /// The payment for joining a chat, which is required when the user isn't
  /// the chat owner
  public var paymentIntent: Flipchat_Common_V1_IntentId {
    get {return _paymentIntent ?? Flipchat_Common_V1_IntentId()}
    set {_paymentIntent = newValue}
  }
  /// Returns true if `paymentIntent` has been explicitly set.
  public var hasPaymentIntent: Bool {return self._paymentIntent != nil}
  /// Clears the value of `paymentIntent`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentIntent() {self._paymentIntent = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Identifier: Equatable {
    case chatID(Flipchat_Common_V1_ChatId)
    case roomID(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier, rhs: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatID, .chatID): return {
        guard case .chatID(let l) = lhs, case .chatID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomID, .roomID): return {
        guard case .roomID(let l) = lhs, case .roomID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _paymentIntent: Flipchat_Common_V1_IntentId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_JoinChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_JoinChatResponse.Result = .ok

  /// The chat metadata, if join was successful.
  public var metadata: Flipchat_Chat_V1_Metadata {
    get {return _metadata ?? Flipchat_Chat_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// The members of the chat, if join was successful.
  public var members: [Flipchat_Chat_V1_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_JoinChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_JoinChatResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_JoinChatPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user joining the chat
  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The chat that the user is joining
  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
}

public struct Flipchat_Chat_V1_LeaveChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_LeaveChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_LeaveChatResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_LeaveChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_LeaveChatResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_SetMuteStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var isMuted: Bool = false

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_SetMuteStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_SetMuteStateResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case cantMute // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .cantMute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .cantMute: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_SetMuteStateResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_SetMuteStateResponse.Result] = [
    .ok,
    .denied,
    .cantMute,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_SetCoverChargeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var coverCharge: Flipchat_Common_V1_PaymentAmount {
    get {return _coverCharge ?? Flipchat_Common_V1_PaymentAmount()}
    set {_coverCharge = newValue}
  }
  /// Returns true if `coverCharge` has been explicitly set.
  public var hasCoverCharge: Bool {return self._coverCharge != nil}
  /// Clears the value of `coverCharge`. Subsequent reads from it will return its default value.
  public mutating func clearCoverCharge() {self._coverCharge = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _coverCharge: Flipchat_Common_V1_PaymentAmount? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_SetCoverChargeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_SetCoverChargeResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case cantSet // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .cantSet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .cantSet: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_SetCoverChargeResponse.Result] = [
    .ok,
    .denied,
    .cantSet,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// The type of chat
  public var type: Flipchat_Chat_V1_Metadata.ChatType = .unknown

  /// The chat title, which is _only_ set by server if an explicit title
  /// was set. Otherwise, clients should fill in an appropriate chat title.
  public var title: String = String()

  /// If non-zero, the room number associated with the chat.
  public var roomNumber: UInt64 = 0

  /// Whether or not the chat is muted (from the perspective of the caller).
  public var isMuted: Bool = false

  /// Whether or not the chat is mutable (from the persective of the caller).
  public var muteable: Bool = false

  /// Number of (estimated) unread message (from the perspective of the caller).
  public var numUnread: UInt32 = 0

  /// Owner is the owner/creator of the chat.
  ///
  /// This is a super priviledge role, in which there can only be one.
  /// This role is displayed as a 'host' currently.
  public var owner: Flipchat_Common_V1_UserId {
    get {return _owner ?? Flipchat_Common_V1_UserId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// If present, the cover charge that must be paid to join the chat
  public var coverCharge: Flipchat_Common_V1_PaymentAmount {
    get {return _coverCharge ?? Flipchat_Common_V1_PaymentAmount()}
    set {_coverCharge = newValue}
  }
  /// Returns true if `coverCharge` has been explicitly set.
  public var hasCoverCharge: Bool {return self._coverCharge != nil}
  /// Clears the value of `coverCharge`. Subsequent reads from it will return its default value.
  public mutating func clearCoverCharge() {self._coverCharge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ChatType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case twoWay // = 1
    case group // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .twoWay
      case 2: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .twoWay: return 1
      case .group: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _owner: Flipchat_Common_V1_UserId? = nil
  fileprivate var _coverCharge: Flipchat_Common_V1_PaymentAmount? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_Metadata.ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_Metadata.ChatType] = [
    .unknown,
    .twoWay,
    .group,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The chat member's identity/profile information.
  ///
  /// It is a light weight version of the users full profile, which
  /// can be retrieved from the Profile service.
  public var identity: Flipchat_Chat_V1_MemberIdentity {
    get {return _identity ?? Flipchat_Chat_V1_MemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  /// Chat message state for this member.
  ///
  /// If set, the list may contain DELIVERED and READ pointers. SENT pointers
  /// are only shared between the sender and server, to indicate persistence.
  ///
  /// The server may wish to omit all pointers in various types of group chats
  /// or as relief valves.
  public var pointers: [Flipchat_Messaging_V1_Pointer] = []

  /// If the member is the caller (where applicable), will be set to true.
  public var isSelf: Bool = false

  /// NOTE: We may switch to 'roles' in the future.
  public var isHost: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _identity: Flipchat_Chat_V1_MemberIdentity? = nil
}

public struct Flipchat_Chat_V1_MemberIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, the display name of the user.
  public var displayName: String = String()

  /// If present, the URL of the users profile pic.
  public var profilePicURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipchat_Chat_V1_StreamChatEventsRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsRequest.Params: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartGroupChatPaymentMetadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatPaymentMetadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetMuteStateRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetMuteStateResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetMuteStateResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_Metadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_Metadata.ChatType: @unchecked Sendable {}
extension Flipchat_Chat_V1_Member: @unchecked Sendable {}
extension Flipchat_Chat_V1_MemberIdentity: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipchat.chat.v1"

extension Flipchat_Chat_V1_StreamChatEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StreamChatEventsRequest.Params?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .params(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .params(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Common_V1_ClientPong?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .params?: try {
      guard case .params(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest, rhs: Flipchat_Chat_V1_StreamChatEventsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsRequest.Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsRequest.protoMessageName + ".Params"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest.Params, rhs: Flipchat_Chat_V1_StreamChatEventsRequest.Params) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ping"),
    2: .same(proto: "error"),
    3: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ServerPing?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .error(v)
        }
      }()
      case 3: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .events(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .events(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .events?: try {
      guard case .events(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse, rhs: Flipchat_Chat_V1_StreamChatEventsResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".StreamError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".EventBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".ChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "member_update"),
    4: .standard(proto: "last_message"),
    5: .same(proto: "pointer"),
    6: .standard(proto: "is_typing"),
  ]

  fileprivate class _StorageClass {
    var _chatID: Flipchat_Common_V1_ChatId? = nil
    var _metadata: Flipchat_Chat_V1_Metadata? = nil
    var _memberUpdate: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate? = nil
    var _lastMessage: Flipchat_Messaging_V1_Message? = nil
    var _pointer: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate? = nil
    var _isTyping: Flipchat_Messaging_V1_IsTyping? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _metadata = source._metadata
      _memberUpdate = source._memberUpdate
      _lastMessage = source._lastMessage
      _pointer = source._pointer
      _isTyping = source._isTyping
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memberUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pointer) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._isTyping) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chatID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memberUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._pointer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isTyping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._memberUpdate != rhs_storage._memberUpdate {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._pointer != rhs_storage._pointer {return false}
        if _storage._isTyping != rhs_storage._isTyping {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.protoMessageName + ".PointerUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "pointer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".MemberUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refresh"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .refresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .refresh(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .refresh(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".Refresh"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Refresh) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_options"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queryOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queryOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatsRequest, rhs: Flipchat_Chat_V1_GetChatsRequest) -> Bool {
    if lhs._queryOptions != rhs._queryOptions {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatsResponse, rhs: Flipchat_Chat_V1_GetChatsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Flipchat_Chat_V1_GetChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "room_number"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ChatId?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .chatID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .chatID(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .roomNumber(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .chatID?: try {
      guard case .chatID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .roomNumber?: try {
      guard case .roomNumber(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatRequest, rhs: Flipchat_Chat_V1_GetChatRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatResponse, rhs: Flipchat_Chat_V1_GetChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Flipchat_Chat_V1_StartChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_way_chat"),
    2: .standard(proto: "group_chat"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .twoWayChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .twoWayChat(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .groupChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .groupChat(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.parameters {
    case .twoWayChat?: try {
      guard case .twoWayChat(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupChat?: try {
      guard case .groupChat(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest, rhs: Flipchat_Chat_V1_StartChatRequest) -> Bool {
    if lhs.parameters != rhs.parameters {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StartChatRequest.protoMessageName + ".StartTwoWayChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherUserID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters, rhs: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters) -> Bool {
    if lhs._otherUserID != rhs._otherUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StartChatRequest.protoMessageName + ".StartGroupChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
    2: .same(proto: "title"),
    3: .standard(proto: "payment_intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentIntent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try { if let v = self._paymentIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters, rhs: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.title != rhs.title {return false}
    if lhs._paymentIntent != rhs._paymentIntent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatResponse, rhs: Flipchat_Chat_V1_StartChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "USER_NOT_FOUND"),
  ]
}

extension Flipchat_Chat_V1_StartGroupChatPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartGroupChatPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartGroupChatPaymentMetadata, rhs: Flipchat_Chat_V1_StartGroupChatPaymentMetadata) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "room_id"),
    9: .standard(proto: "payment_intent"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ChatId?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .chatID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .chatID(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .roomID(v)
        }
      }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._paymentIntent) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .chatID?: try {
      guard case .chatID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .roomID?: try {
      guard case .roomID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._paymentIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatRequest, rhs: Flipchat_Chat_V1_JoinChatRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._paymentIntent != rhs._paymentIntent {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatResponse, rhs: Flipchat_Chat_V1_JoinChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_JoinChatPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatPaymentMetadata, rhs: Flipchat_Chat_V1_JoinChatPaymentMetadata) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._chatID != rhs._chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_LeaveChatRequest, rhs: Flipchat_Chat_V1_LeaveChatRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_LeaveChatResponse, rhs: Flipchat_Chat_V1_LeaveChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Flipchat_Chat_V1_SetMuteStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "is_muted"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 2)
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetMuteStateRequest, rhs: Flipchat_Chat_V1_SetMuteStateRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetMuteStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMuteStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetMuteStateResponse, rhs: Flipchat_Chat_V1_SetMuteStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetMuteStateResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CANT_MUTE"),
  ]
}

extension Flipchat_Chat_V1_SetCoverChargeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCoverChargeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "cover_charge"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coverCharge) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coverCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetCoverChargeRequest, rhs: Flipchat_Chat_V1_SetCoverChargeRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._coverCharge != rhs._coverCharge {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetCoverChargeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCoverChargeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetCoverChargeResponse, rhs: Flipchat_Chat_V1_SetCoverChargeResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CANT_SET"),
  ]
}

extension Flipchat_Chat_V1_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .standard(proto: "room_number"),
    5: .standard(proto: "is_muted"),
    6: .same(proto: "muteable"),
    7: .standard(proto: "num_unread"),
    8: .same(proto: "owner"),
    9: .standard(proto: "cover_charge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.roomNumber) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.muteable) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._coverCharge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if self.roomNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.roomNumber, fieldNumber: 4)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 5)
    }
    if self.muteable != false {
      try visitor.visitSingularBoolField(value: self.muteable, fieldNumber: 6)
    }
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 7)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._coverCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_Metadata, rhs: Flipchat_Chat_V1_Metadata) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.roomNumber != rhs.roomNumber {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.muteable != rhs.muteable {return false}
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._coverCharge != rhs._coverCharge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_Metadata.ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TWO_WAY"),
    2: .same(proto: "GROUP"),
  ]
}

extension Flipchat_Chat_V1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "identity"),
    3: .same(proto: "pointers"),
    4: .standard(proto: "is_self"),
    5: .standard(proto: "is_host"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pointers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSelf) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isHost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pointers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointers, fieldNumber: 3)
    }
    if self.isSelf != false {
      try visitor.visitSingularBoolField(value: self.isSelf, fieldNumber: 4)
    }
    if self.isHost != false {
      try visitor.visitSingularBoolField(value: self.isHost, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_Member, rhs: Flipchat_Chat_V1_Member) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.pointers != rhs.pointers {return false}
    if lhs.isSelf != rhs.isSelf {return false}
    if lhs.isHost != rhs.isHost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MemberIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "profile_pic_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.profilePicURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.profilePicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePicURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MemberIdentity, rhs: Flipchat_Chat_V1_MemberIdentity) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.profilePicURL != rhs.profilePicURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
