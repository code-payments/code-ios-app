// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messaging/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Flipchat_Messaging_V1_TypingState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownTypingState // = 0
  case startedTyping // = 1
  case stillTyping // = 2
  case stoppedTyping // = 3
  case typingTimedOut // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownTypingState
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownTypingState
    case 1: self = .startedTyping
    case 2: self = .stillTyping
    case 3: self = .stoppedTyping
    case 4: self = .typingTimedOut
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownTypingState: return 0
    case .startedTyping: return 1
    case .stillTyping: return 2
    case .stoppedTyping: return 3
    case .typingTimedOut: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipchat_Messaging_V1_TypingState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Messaging_V1_TypingState] = [
    .unknownTypingState,
    .startedTyping,
    .stillTyping,
    .stoppedTyping,
    .typingTimedOut,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Messaging_V1_MessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A lexicographically sortable ID that can be used to sort source of
  /// chat history.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipchat_Messaging_V1_MessageIdBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Flipchat_Messaging_V1_MessageId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message in a chat
public struct Flipchat_Messaging_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this message
  public var messageID: Flipchat_Messaging_V1_MessageId {
    get {return _messageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// The chat member that sent the message. For NOTIFICATION chats, this field
  /// is omitted since the chat has exactly 1 member.
  public var senderID: Flipchat_Common_V1_UserId {
    get {return _senderID ?? Flipchat_Common_V1_UserId()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  /// Message content, which is currently guaranteed to have exactly one item.
  public var content: [Flipchat_Messaging_V1_Content] = []

  /// Timestamp this message was generated at. This value is also encoded in
  /// any time-based UUID message IDs.
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// If sender_id is provided, were they off stage at the time of sending
  /// this message
  public var wasSenderOffStage: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _senderID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Flipchat_Messaging_V1_MessageBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Flipchat_Messaging_V1_Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Pointer in a chat indicating a user's message history state in a chat.
public struct Flipchat_Messaging_V1_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of pointer indicates which user's message history state can be
  /// inferred from the pointer value. It is also possible to infer cross-pointer
  /// state. For example, if a chat member has a READ pointer for a message with
  /// ID N, then the DELIVERED pointer must be at least N.
  public var type: Flipchat_Messaging_V1_Pointer.TypeEnum = .unknown

  /// Everything at or before this message ID is considered to have the state
  /// inferred by the type of pointer.
  public var value: Flipchat_Messaging_V1_MessageId {
    get {return _value ?? Flipchat_Messaging_V1_MessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Always inferred by OK result in SendMessageResponse or message presence in a chat
    case sent // = 1
    case delivered // = 2
    case read // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sent
      case 2: self = .delivered
      case 3: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sent: return 1
      case .delivered: return 2
      case .read: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _value: Flipchat_Messaging_V1_MessageId? = nil
}

#if swift(>=4.2)

extension Flipchat_Messaging_V1_Pointer.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Messaging_V1_Pointer.TypeEnum] = [
    .unknown,
    .sent,
    .delivered,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Messaging_V1_PointerUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var member: Flipchat_Common_V1_UserId {
    get {return _member ?? Flipchat_Common_V1_UserId()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  public var pointer: Flipchat_Messaging_V1_Pointer {
    get {return _pointer ?? Flipchat_Messaging_V1_Pointer()}
    set {_pointer = newValue}
  }
  /// Returns true if `pointer` has been explicitly set.
  public var hasPointer: Bool {return self._pointer != nil}
  /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
  public mutating func clearPointer() {self._pointer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _member: Flipchat_Common_V1_UserId? = nil
  fileprivate var _pointer: Flipchat_Messaging_V1_Pointer? = nil
}

public struct Flipchat_Messaging_V1_PointerUpdateBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pointerUpdates: [Flipchat_Messaging_V1_PointerUpdate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipchat_Messaging_V1_IsTyping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// Deprecated: Use typing_state instead
  public var isTyping: Bool = false

  public var typingState: Flipchat_Messaging_V1_TypingState = .unknownTypingState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
}

public struct Flipchat_Messaging_V1_IsTypingBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isTypingNotifications: [Flipchat_Messaging_V1_IsTyping] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Content for a chat message
public struct Flipchat_Messaging_V1_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Messaging_V1_Content.OneOf_Type? = nil

  public var text: Flipchat_Messaging_V1_TextContent {
    get {
      if case .text(let v)? = type {return v}
      return Flipchat_Messaging_V1_TextContent()
    }
    set {type = .text(newValue)}
  }

  public var localizedAnnouncement: Flipchat_Messaging_V1_LocalizedAnnouncementContent {
    get {
      if case .localizedAnnouncement(let v)? = type {return v}
      return Flipchat_Messaging_V1_LocalizedAnnouncementContent()
    }
    set {type = .localizedAnnouncement(newValue)}
  }

  public var reaction: Flipchat_Messaging_V1_ReactionContent {
    get {
      if case .reaction(let v)? = type {return v}
      return Flipchat_Messaging_V1_ReactionContent()
    }
    set {type = .reaction(newValue)}
  }

  public var reply: Flipchat_Messaging_V1_ReplyContent {
    get {
      if case .reply(let v)? = type {return v}
      return Flipchat_Messaging_V1_ReplyContent()
    }
    set {type = .reply(newValue)}
  }

  public var tip: Flipchat_Messaging_V1_TipContent {
    get {
      if case .tip(let v)? = type {return v}
      return Flipchat_Messaging_V1_TipContent()
    }
    set {type = .tip(newValue)}
  }

  public var deleted: Flipchat_Messaging_V1_DeleteMessageContent {
    get {
      if case .deleted(let v)? = type {return v}
      return Flipchat_Messaging_V1_DeleteMessageContent()
    }
    set {type = .deleted(newValue)}
  }

  public var review: Flipchat_Messaging_V1_ReviewContent {
    get {
      if case .review(let v)? = type {return v}
      return Flipchat_Messaging_V1_ReviewContent()
    }
    set {type = .review(newValue)}
  }

  public var actionableAnnouncement: Flipchat_Messaging_V1_ActionableAnnouncementContent {
    get {
      if case .actionableAnnouncement(let v)? = type {return v}
      return Flipchat_Messaging_V1_ActionableAnnouncementContent()
    }
    set {type = .actionableAnnouncement(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Flipchat_Messaging_V1_TextContent)
    case localizedAnnouncement(Flipchat_Messaging_V1_LocalizedAnnouncementContent)
    case reaction(Flipchat_Messaging_V1_ReactionContent)
    case reply(Flipchat_Messaging_V1_ReplyContent)
    case tip(Flipchat_Messaging_V1_TipContent)
    case deleted(Flipchat_Messaging_V1_DeleteMessageContent)
    case review(Flipchat_Messaging_V1_ReviewContent)
    case actionableAnnouncement(Flipchat_Messaging_V1_ActionableAnnouncementContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Messaging_V1_Content.OneOf_Type, rhs: Flipchat_Messaging_V1_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localizedAnnouncement, .localizedAnnouncement): return {
        guard case .localizedAnnouncement(let l) = lhs, case .localizedAnnouncement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reaction, .reaction): return {
        guard case .reaction(let l) = lhs, case .reaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reply, .reply): return {
        guard case .reply(let l) = lhs, case .reply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tip, .tip): return {
        guard case .tip(let l) = lhs, case .tip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleted, .deleted): return {
        guard case .deleted(let l) = lhs, case .deleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.review, .review): return {
        guard case .review(let l) = lhs, case .review(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionableAnnouncement, .actionableAnnouncement): return {
        guard case .actionableAnnouncement(let l) = lhs, case .actionableAnnouncement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Raw text content
public struct Flipchat_Messaging_V1_TextContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LocalizedAnnouncementContent content is an annoucement that is either a
/// localization key that should be translated on client, or a server-side
/// translated piece of text.
public struct Flipchat_Messaging_V1_LocalizedAnnouncementContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ActionableAnnouncementContent is like LocalizedAnnouncementContent, but
/// contains additional metadata for actions
public struct Flipchat_Messaging_V1_ActionableAnnouncementContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  /// An action that can be taken by a user
  public var action: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action {
    get {return _action ?? Flipchat_Messaging_V1_ActionableAnnouncementContent.Action()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Action {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.OneOf_Type? = nil

    public var shareRoomLink: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink {
      get {
        if case .shareRoomLink(let v)? = type {return v}
        return Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink()
      }
      set {type = .shareRoomLink(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Type: Equatable {
      case shareRoomLink(Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink)

    #if !swift(>=4.1)
      public static func ==(lhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.OneOf_Type, rhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.OneOf_Type) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.shareRoomLink, .shareRoomLink): return {
          guard case .shareRoomLink(let l) = lhs, case .shareRoomLink(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// Displays a button to share a link to a room
    public struct ShareRoomLink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _action: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action? = nil
}

/// Emoji reaction to another message
public struct Flipchat_Messaging_V1_ReactionContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this reaction is associated with
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The emoji or reaction symbol
  public var emoji: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

/// Text reply of another message
public struct Flipchat_Messaging_V1_ReplyContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this reply is referencing
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The reply text, which can be handled similarly to TextContent
  public var replyText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

public struct Flipchat_Messaging_V1_TipContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this tip is referencing
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The amount tipped for the message
  public var tipAmount: Flipchat_Common_V1_PaymentAmount {
    get {return _tipAmount ?? Flipchat_Common_V1_PaymentAmount()}
    set {_tipAmount = newValue}
  }
  /// Returns true if `tipAmount` has been explicitly set.
  public var hasTipAmount: Bool {return self._tipAmount != nil}
  /// Clears the value of `tipAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTipAmount() {self._tipAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _tipAmount: Flipchat_Common_V1_PaymentAmount? = nil
}

public struct Flipchat_Messaging_V1_DeleteMessageContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message that was deleted
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

public struct Flipchat_Messaging_V1_ReviewContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message that is being reviewed. Currently, only
  /// off stage messages can be reviewed
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// Whether the message has been approved. In the event of multiple reviews,
  /// the first message in the message log takes priority.
  public var isApproved: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipchat_Messaging_V1_TypingState: @unchecked Sendable {}
extension Flipchat_Messaging_V1_MessageId: @unchecked Sendable {}
extension Flipchat_Messaging_V1_MessageIdBatch: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Message: @unchecked Sendable {}
extension Flipchat_Messaging_V1_MessageBatch: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer.TypeEnum: @unchecked Sendable {}
extension Flipchat_Messaging_V1_PointerUpdate: @unchecked Sendable {}
extension Flipchat_Messaging_V1_PointerUpdateBatch: @unchecked Sendable {}
extension Flipchat_Messaging_V1_IsTyping: @unchecked Sendable {}
extension Flipchat_Messaging_V1_IsTypingBatch: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Messaging_V1_TextContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_LocalizedAnnouncementContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ActionableAnnouncementContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ActionableAnnouncementContent.Action: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ReactionContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ReplyContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_TipContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_DeleteMessageContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ReviewContent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipchat.messaging.v1"

extension Flipchat_Messaging_V1_TypingState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPING_STATE"),
    1: .same(proto: "STARTED_TYPING"),
    2: .same(proto: "STILL_TYPING"),
    3: .same(proto: "STOPPED_TYPING"),
    4: .same(proto: "TYPING_TIMED_OUT"),
  ]
}

extension Flipchat_Messaging_V1_MessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_MessageId, rhs: Flipchat_Messaging_V1_MessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_MessageIdBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageIdBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messageIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_MessageIdBatch, rhs: Flipchat_Messaging_V1_MessageIdBatch) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
    5: .standard(proto: "was_sender_off_stage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.wasSenderOffStage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.wasSenderOffStage != false {
      try visitor.visitSingularBoolField(value: self.wasSenderOffStage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Message, rhs: Flipchat_Messaging_V1_Message) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._senderID != rhs._senderID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.wasSenderOffStage != rhs.wasSenderOffStage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_MessageBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_MessageBatch, rhs: Flipchat_Messaging_V1_MessageBatch) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Pointer, rhs: Flipchat_Messaging_V1_Pointer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SENT"),
    2: .same(proto: "DELIVERED"),
    3: .same(proto: "READ"),
  ]
}

extension Flipchat_Messaging_V1_PointerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointerUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "pointer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_PointerUpdate, rhs: Flipchat_Messaging_V1_PointerUpdate) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_PointerUpdateBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointerUpdateBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pointer_updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pointerUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pointerUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointerUpdates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_PointerUpdateBatch, rhs: Flipchat_Messaging_V1_PointerUpdateBatch) -> Bool {
    if lhs.pointerUpdates != rhs.pointerUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_IsTyping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTyping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "is_typing"),
    3: .standard(proto: "typing_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.typingState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    if self.typingState != .unknownTypingState {
      try visitor.visitSingularEnumField(value: self.typingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_IsTyping, rhs: Flipchat_Messaging_V1_IsTyping) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs.typingState != rhs.typingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_IsTypingBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTypingBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_typing_notifications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.isTypingNotifications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.isTypingNotifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.isTypingNotifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_IsTypingBatch, rhs: Flipchat_Messaging_V1_IsTypingBatch) -> Bool {
    if lhs.isTypingNotifications != rhs.isTypingNotifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "localized_announcement"),
    5: .same(proto: "reaction"),
    6: .same(proto: "reply"),
    7: .same(proto: "tip"),
    8: .same(proto: "deleted"),
    9: .same(proto: "review"),
    10: .standard(proto: "actionable_announcement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Messaging_V1_TextContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Messaging_V1_LocalizedAnnouncementContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localizedAnnouncement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localizedAnnouncement(v)
        }
      }()
      case 5: try {
        var v: Flipchat_Messaging_V1_ReactionContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reaction(v)
        }
      }()
      case 6: try {
        var v: Flipchat_Messaging_V1_ReplyContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reply(v)
        }
      }()
      case 7: try {
        var v: Flipchat_Messaging_V1_TipContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tip(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tip(v)
        }
      }()
      case 8: try {
        var v: Flipchat_Messaging_V1_DeleteMessageContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .deleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .deleted(v)
        }
      }()
      case 9: try {
        var v: Flipchat_Messaging_V1_ReviewContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .review(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .review(v)
        }
      }()
      case 10: try {
        var v: Flipchat_Messaging_V1_ActionableAnnouncementContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .actionableAnnouncement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .actionableAnnouncement(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localizedAnnouncement?: try {
      guard case .localizedAnnouncement(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reaction?: try {
      guard case .reaction(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .reply?: try {
      guard case .reply(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .tip?: try {
      guard case .tip(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleted?: try {
      guard case .deleted(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .review?: try {
      guard case .review(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .actionableAnnouncement?: try {
      guard case .actionableAnnouncement(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Content, rhs: Flipchat_Messaging_V1_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_TextContent, rhs: Flipchat_Messaging_V1_TextContent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_LocalizedAnnouncementContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedAnnouncementContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_LocalizedAnnouncementContent, rhs: Flipchat_Messaging_V1_LocalizedAnnouncementContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ActionableAnnouncementContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionableAnnouncementContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ActionableAnnouncementContent, rhs: Flipchat_Messaging_V1_ActionableAnnouncementContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ActionableAnnouncementContent.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Messaging_V1_ActionableAnnouncementContent.protoMessageName + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_room_link"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .shareRoomLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .shareRoomLink(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shareRoomLink(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action, rhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.protoMessageName + ".ShareRoomLink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink, rhs: Flipchat_Messaging_V1_ActionableAnnouncementContent.Action.ShareRoomLink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ReactionContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReactionContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .same(proto: "emoji"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ReactionContent, rhs: Flipchat_Messaging_V1_ReactionContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ReplyContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .standard(proto: "reply_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.replyText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.replyText.isEmpty {
      try visitor.visitSingularStringField(value: self.replyText, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ReplyContent, rhs: Flipchat_Messaging_V1_ReplyContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.replyText != rhs.replyText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_TipContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TipContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .standard(proto: "tip_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tipAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tipAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_TipContent, rhs: Flipchat_Messaging_V1_TipContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs._tipAmount != rhs._tipAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_DeleteMessageContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessageContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_DeleteMessageContent, rhs: Flipchat_Messaging_V1_DeleteMessageContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ReviewContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .standard(proto: "is_approved"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isApproved) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isApproved != false {
      try visitor.visitSingularBoolField(value: self.isApproved, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ReviewContent, rhs: Flipchat_Messaging_V1_ReviewContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.isApproved != rhs.isApproved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
