// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messaging/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Flipchat_Messaging_V1_MessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A lexicographically sortable ID that can be used to sort source of
  /// chat history.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message in a chat
public struct Flipchat_Messaging_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this message
  public var messageID: Flipchat_Messaging_V1_MessageId {
    get {return _messageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// The chat member that sent the message. For NOTIFICATION chats, this field
  /// is omitted since the chat has exactly 1 member.
  public var senderID: Flipchat_Common_V1_UserId {
    get {return _senderID ?? Flipchat_Common_V1_UserId()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  /// Ordered message content. A message may have more than one piece of content.
  public var content: [Flipchat_Messaging_V1_Content] = []

  /// Timestamp this message was generated at. This value is also encoded in
  /// any time-based UUID message IDs.
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _senderID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Pointer in a chat indicating a user's message history state in a chat.
public struct Flipchat_Messaging_V1_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of pointer indicates which user's message history state can be
  /// inferred from the pointer value. It is also possible to infer cross-pointer
  /// state. For example, if a chat member has a READ pointer for a message with
  /// ID N, then the DELIVERED pointer must be at least N.
  public var type: Flipchat_Messaging_V1_Pointer.TypeEnum = .unknown

  /// Everything at or before this message ID is considered to have the state
  /// inferred by the type of pointer.
  public var value: Flipchat_Messaging_V1_MessageId {
    get {return _value ?? Flipchat_Messaging_V1_MessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Always inferred by OK result in SendMessageResponse or message presence in a chat
    case sent // = 1
    case delivered // = 2
    case read // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sent
      case 2: self = .delivered
      case 3: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sent: return 1
      case .delivered: return 2
      case .read: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _value: Flipchat_Messaging_V1_MessageId? = nil
}

#if swift(>=4.2)

extension Flipchat_Messaging_V1_Pointer.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Messaging_V1_Pointer.TypeEnum] = [
    .unknown,
    .sent,
    .delivered,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Messaging_V1_IsTyping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// is_typing indicates whether or not the user is typing.
  /// If false, the user has explicitly stopped typing.
  public var isTyping: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
}

/// Content for a chat message
public struct Flipchat_Messaging_V1_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Messaging_V1_Content.OneOf_Type? = nil

  public var text: Flipchat_Messaging_V1_TextContent {
    get {
      if case .text(let v)? = type {return v}
      return Flipchat_Messaging_V1_TextContent()
    }
    set {type = .text(newValue)}
  }

  public var localized: Flipchat_Messaging_V1_LocalizedContent {
    get {
      if case .localized(let v)? = type {return v}
      return Flipchat_Messaging_V1_LocalizedContent()
    }
    set {type = .localized(newValue)}
  }

  ///ExchangeDataContent     exchange_data     = 3;
  public var naclBox: Flipchat_Messaging_V1_NaclBoxEncryptedContent {
    get {
      if case .naclBox(let v)? = type {return v}
      return Flipchat_Messaging_V1_NaclBoxEncryptedContent()
    }
    set {type = .naclBox(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Flipchat_Messaging_V1_TextContent)
    case localized(Flipchat_Messaging_V1_LocalizedContent)
    ///ExchangeDataContent     exchange_data     = 3;
    case naclBox(Flipchat_Messaging_V1_NaclBoxEncryptedContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Messaging_V1_Content.OneOf_Type, rhs: Flipchat_Messaging_V1_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localized, .localized): return {
        guard case .localized(let l) = lhs, case .localized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.naclBox, .naclBox): return {
        guard case .naclBox(let l) = lhs, case .naclBox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Raw text content
public struct Flipchat_Messaging_V1_TextContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Text content that is either a localization key that should be translated on
/// client, or a server-side translated piece of text.
public struct Flipchat_Messaging_V1_LocalizedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Encrypted piece of content using NaCl box encryption
public struct Flipchat_Messaging_V1_NaclBoxEncryptedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sender's public key that is used to derive the shared private key for
  /// decryption for message content.
  public var peerPublicKey: Flipchat_Common_V1_PublicKey {
    get {return _peerPublicKey ?? Flipchat_Common_V1_PublicKey()}
    set {_peerPublicKey = newValue}
  }
  /// Returns true if `peerPublicKey` has been explicitly set.
  public var hasPeerPublicKey: Bool {return self._peerPublicKey != nil}
  /// Clears the value of `peerPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPeerPublicKey() {self._peerPublicKey = nil}

  /// Globally random nonce that is unique to this encrypted piece of content
  public var nonce: Data = Data()

  /// The encrypted piece of message content
  public var encryptedPayload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerPublicKey: Flipchat_Common_V1_PublicKey? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipchat_Messaging_V1_MessageId: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Message: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer.TypeEnum: @unchecked Sendable {}
extension Flipchat_Messaging_V1_IsTyping: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Messaging_V1_TextContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_LocalizedContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_NaclBoxEncryptedContent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipchat.messaging.v1"

extension Flipchat_Messaging_V1_MessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_MessageId, rhs: Flipchat_Messaging_V1_MessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Message, rhs: Flipchat_Messaging_V1_Message) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._senderID != rhs._senderID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Pointer, rhs: Flipchat_Messaging_V1_Pointer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SENT"),
    2: .same(proto: "DELIVERED"),
    3: .same(proto: "READ"),
  ]
}

extension Flipchat_Messaging_V1_IsTyping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTyping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_IsTyping, rhs: Flipchat_Messaging_V1_IsTyping) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "localized"),
    4: .standard(proto: "nacl_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Messaging_V1_TextContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Messaging_V1_LocalizedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localized(v)
        }
      }()
      case 4: try {
        var v: Flipchat_Messaging_V1_NaclBoxEncryptedContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .naclBox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .naclBox(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localized?: try {
      guard case .localized(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .naclBox?: try {
      guard case .naclBox(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Content, rhs: Flipchat_Messaging_V1_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_TextContent, rhs: Flipchat_Messaging_V1_TextContent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_LocalizedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_LocalizedContent, rhs: Flipchat_Messaging_V1_LocalizedContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_NaclBoxEncryptedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NaclBoxEncryptedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_public_key"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "encrypted_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerPublicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedPayload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.encryptedPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedPayload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_NaclBoxEncryptedContent, rhs: Flipchat_Messaging_V1_NaclBoxEncryptedContent) -> Bool {
    if lhs._peerPublicKey != rhs._peerPublicKey {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.encryptedPayload != rhs.encryptedPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
