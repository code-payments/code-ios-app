// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messaging/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Flipchat_Messaging_V1_MessageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A lexicographically sortable ID that can be used to sort source of
  /// chat history.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message in a chat
public struct Flipchat_Messaging_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique ID for this message
  public var messageID: Flipchat_Messaging_V1_MessageId {
    get {return _messageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  /// The chat member that sent the message. For NOTIFICATION chats, this field
  /// is omitted since the chat has exactly 1 member.
  public var senderID: Flipchat_Common_V1_UserId {
    get {return _senderID ?? Flipchat_Common_V1_UserId()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  /// Message content, which is currently guaranteed to have exactly one item.
  public var content: [Flipchat_Messaging_V1_Content] = []

  /// Timestamp this message was generated at. This value is also encoded in
  /// any time-based UUID message IDs.
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _senderID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Pointer in a chat indicating a user's message history state in a chat.
public struct Flipchat_Messaging_V1_Pointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of pointer indicates which user's message history state can be
  /// inferred from the pointer value. It is also possible to infer cross-pointer
  /// state. For example, if a chat member has a READ pointer for a message with
  /// ID N, then the DELIVERED pointer must be at least N.
  public var type: Flipchat_Messaging_V1_Pointer.TypeEnum = .unknown

  /// Everything at or before this message ID is considered to have the state
  /// inferred by the type of pointer.
  public var value: Flipchat_Messaging_V1_MessageId {
    get {return _value ?? Flipchat_Messaging_V1_MessageId()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Always inferred by OK result in SendMessageResponse or message presence in a chat
    case sent // = 1
    case delivered // = 2
    case read // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sent
      case 2: self = .delivered
      case 3: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sent: return 1
      case .delivered: return 2
      case .read: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _value: Flipchat_Messaging_V1_MessageId? = nil
}

#if swift(>=4.2)

extension Flipchat_Messaging_V1_Pointer.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Messaging_V1_Pointer.TypeEnum] = [
    .unknown,
    .sent,
    .delivered,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Messaging_V1_IsTyping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// is_typing indicates whether or not the user is typing.
  /// If false, the user has explicitly stopped typing.
  public var isTyping: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
}

/// Content for a chat message
public struct Flipchat_Messaging_V1_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Messaging_V1_Content.OneOf_Type? = nil

  public var text: Flipchat_Messaging_V1_TextContent {
    get {
      if case .text(let v)? = type {return v}
      return Flipchat_Messaging_V1_TextContent()
    }
    set {type = .text(newValue)}
  }

  public var localizedAnnouncement: Flipchat_Messaging_V1_LocalizedAnnouncementContent {
    get {
      if case .localizedAnnouncement(let v)? = type {return v}
      return Flipchat_Messaging_V1_LocalizedAnnouncementContent()
    }
    set {type = .localizedAnnouncement(newValue)}
  }

  public var reaction: Flipchat_Messaging_V1_ReactionContent {
    get {
      if case .reaction(let v)? = type {return v}
      return Flipchat_Messaging_V1_ReactionContent()
    }
    set {type = .reaction(newValue)}
  }

  public var reply: Flipchat_Messaging_V1_ReplyContent {
    get {
      if case .reply(let v)? = type {return v}
      return Flipchat_Messaging_V1_ReplyContent()
    }
    set {type = .reply(newValue)}
  }

  public var tip: Flipchat_Messaging_V1_TipContent {
    get {
      if case .tip(let v)? = type {return v}
      return Flipchat_Messaging_V1_TipContent()
    }
    set {type = .tip(newValue)}
  }

  public var deleted: Flipchat_Messaging_V1_DeleteMessageContent {
    get {
      if case .deleted(let v)? = type {return v}
      return Flipchat_Messaging_V1_DeleteMessageContent()
    }
    set {type = .deleted(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Flipchat_Messaging_V1_TextContent)
    case localizedAnnouncement(Flipchat_Messaging_V1_LocalizedAnnouncementContent)
    case reaction(Flipchat_Messaging_V1_ReactionContent)
    case reply(Flipchat_Messaging_V1_ReplyContent)
    case tip(Flipchat_Messaging_V1_TipContent)
    case deleted(Flipchat_Messaging_V1_DeleteMessageContent)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Messaging_V1_Content.OneOf_Type, rhs: Flipchat_Messaging_V1_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localizedAnnouncement, .localizedAnnouncement): return {
        guard case .localizedAnnouncement(let l) = lhs, case .localizedAnnouncement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reaction, .reaction): return {
        guard case .reaction(let l) = lhs, case .reaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reply, .reply): return {
        guard case .reply(let l) = lhs, case .reply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tip, .tip): return {
        guard case .tip(let l) = lhs, case .tip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleted, .deleted): return {
        guard case .deleted(let l) = lhs, case .deleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Raw text content
public struct Flipchat_Messaging_V1_TextContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LocalizedAnnouncementContent content is an annoucement that is either a
/// localization key that should be translated on client, or a server-side
/// translated piece of text.
public struct Flipchat_Messaging_V1_LocalizedAnnouncementContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOrText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Emoji reaction to another message
public struct Flipchat_Messaging_V1_ReactionContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this reaction is associated with
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The emoji or reaction symbol
  public var emoji: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

/// Text reply of another message
public struct Flipchat_Messaging_V1_ReplyContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this reply is referencing
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The reply text, which can be handled similarly to TextContent
  public var replyText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

public struct Flipchat_Messaging_V1_TipContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message this tip is referencing
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  /// The amount tipped for the message
  public var tipAmount: Flipchat_Common_V1_PaymentAmount {
    get {return _tipAmount ?? Flipchat_Common_V1_PaymentAmount()}
    set {_tipAmount = newValue}
  }
  /// Returns true if `tipAmount` has been explicitly set.
  public var hasTipAmount: Bool {return self._tipAmount != nil}
  /// Clears the value of `tipAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTipAmount() {self._tipAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _tipAmount: Flipchat_Common_V1_PaymentAmount? = nil
}

public struct Flipchat_Messaging_V1_DeleteMessageContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message that was deleted
  public var originalMessageID: Flipchat_Messaging_V1_MessageId {
    get {return _originalMessageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_originalMessageID = newValue}
  }
  /// Returns true if `originalMessageID` has been explicitly set.
  public var hasOriginalMessageID: Bool {return self._originalMessageID != nil}
  /// Clears the value of `originalMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalMessageID() {self._originalMessageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalMessageID: Flipchat_Messaging_V1_MessageId? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipchat_Messaging_V1_MessageId: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Message: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Pointer.TypeEnum: @unchecked Sendable {}
extension Flipchat_Messaging_V1_IsTyping: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content: @unchecked Sendable {}
extension Flipchat_Messaging_V1_Content.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Messaging_V1_TextContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_LocalizedAnnouncementContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ReactionContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_ReplyContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_TipContent: @unchecked Sendable {}
extension Flipchat_Messaging_V1_DeleteMessageContent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipchat.messaging.v1"

extension Flipchat_Messaging_V1_MessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_MessageId, rhs: Flipchat_Messaging_V1_MessageId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Message, rhs: Flipchat_Messaging_V1_Message) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs._senderID != rhs._senderID {return false}
    if lhs.content != rhs.content {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Pointer, rhs: Flipchat_Messaging_V1_Pointer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Pointer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SENT"),
    2: .same(proto: "DELIVERED"),
    3: .same(proto: "READ"),
  ]
}

extension Flipchat_Messaging_V1_IsTyping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsTyping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "is_typing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTyping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTyping != false {
      try visitor.visitSingularBoolField(value: self.isTyping, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_IsTyping, rhs: Flipchat_Messaging_V1_IsTyping) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.isTyping != rhs.isTyping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "localized_announcement"),
    5: .same(proto: "reaction"),
    6: .same(proto: "reply"),
    7: .same(proto: "tip"),
    8: .same(proto: "deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Messaging_V1_TextContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Messaging_V1_LocalizedAnnouncementContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .localizedAnnouncement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .localizedAnnouncement(v)
        }
      }()
      case 5: try {
        var v: Flipchat_Messaging_V1_ReactionContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reaction(v)
        }
      }()
      case 6: try {
        var v: Flipchat_Messaging_V1_ReplyContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reply(v)
        }
      }()
      case 7: try {
        var v: Flipchat_Messaging_V1_TipContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tip(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tip(v)
        }
      }()
      case 8: try {
        var v: Flipchat_Messaging_V1_DeleteMessageContent?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .deleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .deleted(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localizedAnnouncement?: try {
      guard case .localizedAnnouncement(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reaction?: try {
      guard case .reaction(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .reply?: try {
      guard case .reply(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .tip?: try {
      guard case .tip(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleted?: try {
      guard case .deleted(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_Content, rhs: Flipchat_Messaging_V1_Content) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_TextContent, rhs: Flipchat_Messaging_V1_TextContent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_LocalizedAnnouncementContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedAnnouncementContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_or_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyOrText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyOrText.isEmpty {
      try visitor.visitSingularStringField(value: self.keyOrText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_LocalizedAnnouncementContent, rhs: Flipchat_Messaging_V1_LocalizedAnnouncementContent) -> Bool {
    if lhs.keyOrText != rhs.keyOrText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ReactionContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReactionContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .same(proto: "emoji"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ReactionContent, rhs: Flipchat_Messaging_V1_ReactionContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_ReplyContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .standard(proto: "reply_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.replyText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.replyText.isEmpty {
      try visitor.visitSingularStringField(value: self.replyText, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_ReplyContent, rhs: Flipchat_Messaging_V1_ReplyContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.replyText != rhs.replyText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_TipContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TipContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
    2: .standard(proto: "tip_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tipAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tipAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_TipContent, rhs: Flipchat_Messaging_V1_TipContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs._tipAmount != rhs._tipAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Messaging_V1_DeleteMessageContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessageContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originalMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Messaging_V1_DeleteMessageContent, rhs: Flipchat_Messaging_V1_DeleteMessageContent) -> Bool {
    if lhs._originalMessageID != rhs._originalMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
