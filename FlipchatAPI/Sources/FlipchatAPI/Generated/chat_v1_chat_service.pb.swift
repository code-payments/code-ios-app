// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/chat_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Flipchat_Chat_V1_StreamChatEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type? = nil

  public var params: Flipchat_Chat_V1_StreamChatEventsRequest.Params {
    get {
      if case .params(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsRequest.Params()
    }
    set {type = .params(newValue)}
  }

  public var pong: Flipchat_Common_V1_ClientPong {
    get {
      if case .pong(let v)? = type {return v}
      return Flipchat_Common_V1_ClientPong()
    }
    set {type = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case params(Flipchat_Chat_V1_StreamChatEventsRequest.Params)
    case pong(Flipchat_Common_V1_ClientPong)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type, rhs: Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.params, .params): return {
        guard case .params(let l) = lhs, case .params(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Params {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var auth: Flipchat_Common_V1_Auth {
      get {return _auth ?? Flipchat_Common_V1_Auth()}
      set {_auth = newValue}
    }
    /// Returns true if `auth` has been explicitly set.
    public var hasAuth: Bool {return self._auth != nil}
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    public mutating func clearAuth() {self._auth = nil}

    /// ts contains the time for stream open.
    ///
    /// It is used primarily as a nonce for auth. Server may reject
    /// timestamps that are too far in the future or past.
    public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_ts = newValue}
    }
    /// Returns true if `ts` has been explicitly set.
    public var hasTs: Bool {return self._ts != nil}
    /// Clears the value of `ts`. Subsequent reads from it will return its default value.
    public mutating func clearTs() {self._ts = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
    fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}
}

public struct Flipchat_Chat_V1_StreamChatEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type? = nil

  public var ping: Flipchat_Common_V1_ServerPing {
    get {
      if case .ping(let v)? = type {return v}
      return Flipchat_Common_V1_ServerPing()
    }
    set {type = .ping(newValue)}
  }

  public var error: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError {
    get {
      if case .error(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsResponse.StreamError()
    }
    set {type = .error(newValue)}
  }

  public var events: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch {
    get {
      if case .events(let v)? = type {return v}
      return Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch()
    }
    set {type = .events(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case ping(Flipchat_Common_V1_ServerPing)
    case error(Flipchat_Chat_V1_StreamChatEventsResponse.StreamError)
    case events(Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.events, .events): return {
        guard case .events(let l) = lhs, case .events(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct StreamError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code = .denied

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case denied // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct EventBatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var updates: [Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// ChatUpdate contains a set of updates for a given chat id.
  ///
  /// Only the relevant fields will be set on update. On initial
  /// stream open, all fields will be set, however.
  public struct ChatUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var chatID: Flipchat_Common_V1_ChatId {
      get {return _storage._chatID ?? Flipchat_Common_V1_ChatId()}
      set {_uniqueStorage()._chatID = newValue}
    }
    /// Returns true if `chatID` has been explicitly set.
    public var hasChatID: Bool {return _storage._chatID != nil}
    /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
    public mutating func clearChatID() {_uniqueStorage()._chatID = nil}

    /// Metadata contains the latest (full) chat metadata.
    ///
    /// Deprecated: Use metadata_updates instead. For backwards compatibility
    /// this will only contain full metadata refreshes.
    public var metadata: Flipchat_Chat_V1_Metadata {
      get {return _storage._metadata ?? Flipchat_Chat_V1_Metadata()}
      set {_uniqueStorage()._metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return _storage._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

    /// MetadataUpdate contains updates to a chat metadata
    public var metadataUpdates: [Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate] {
      get {return _storage._metadataUpdates}
      set {_uniqueStorage()._metadataUpdates = newValue}
    }

    /// MemberUpdate contains an update to the membership set.
    ///
    /// Deprecated: Use member_updates instead. For backwards compatibility
    /// this will only contain full member refreshes.
    public var memberUpdate: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate {
      get {return _storage._memberUpdate ?? Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate()}
      set {_uniqueStorage()._memberUpdate = newValue}
    }
    /// Returns true if `memberUpdate` has been explicitly set.
    public var hasMemberUpdate: Bool {return _storage._memberUpdate != nil}
    /// Clears the value of `memberUpdate`. Subsequent reads from it will return its default value.
    public mutating func clearMemberUpdate() {_uniqueStorage()._memberUpdate = nil}

    /// MemberUpdate contains updates to the membership set.
    public var memberUpdates: [Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate] {
      get {return _storage._memberUpdates}
      set {_uniqueStorage()._memberUpdates = newValue}
    }

    /// Message contains the last known message of the chat.
    public var lastMessage: Flipchat_Messaging_V1_Message {
      get {return _storage._lastMessage ?? Flipchat_Messaging_V1_Message()}
      set {_uniqueStorage()._lastMessage = newValue}
    }
    /// Returns true if `lastMessage` has been explicitly set.
    public var hasLastMessage: Bool {return _storage._lastMessage != nil}
    /// Clears the value of `lastMessage`. Subsequent reads from it will return its default value.
    public mutating func clearLastMessage() {_uniqueStorage()._lastMessage = nil}

    /// Relevant update to a chat member's pointer state, where 'relevant' means
    /// "relevant to UI updates". For example, when a user has read the latest
    /// message.
    public var pointer: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate {
      get {return _storage._pointer ?? Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate()}
      set {_uniqueStorage()._pointer = newValue}
    }
    /// Returns true if `pointer` has been explicitly set.
    public var hasPointer: Bool {return _storage._pointer != nil}
    /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
    public mutating func clearPointer() {_uniqueStorage()._pointer = nil}

    /// IsTyping indicates whether or not someone is typing in the group.
    public var isTyping: Flipchat_Messaging_V1_IsTyping {
      get {return _storage._isTyping ?? Flipchat_Messaging_V1_IsTyping()}
      set {_uniqueStorage()._isTyping = newValue}
    }
    /// Returns true if `isTyping` has been explicitly set.
    public var hasIsTyping: Bool {return _storage._isTyping != nil}
    /// Clears the value of `isTyping`. Subsequent reads from it will return its default value.
    public mutating func clearIsTyping() {_uniqueStorage()._isTyping = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct PointerUpdate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Common_V1_UserId {
        get {return _member ?? Flipchat_Common_V1_UserId()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var pointer: Flipchat_Messaging_V1_Pointer {
        get {return _pointer ?? Flipchat_Messaging_V1_Pointer()}
        set {_pointer = newValue}
      }
      /// Returns true if `pointer` has been explicitly set.
      public var hasPointer: Bool {return self._pointer != nil}
      /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
      public mutating func clearPointer() {self._pointer = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Common_V1_UserId? = nil
      fileprivate var _pointer: Flipchat_Messaging_V1_Pointer? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct MetadataUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.OneOf_Kind? = nil

    public var fullRefresh: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh {
      get {
        if case .fullRefresh(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh()
      }
      set {kind = .fullRefresh(newValue)}
    }

    public var unreadCountChanged: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged {
      get {
        if case .unreadCountChanged(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged()
      }
      set {kind = .unreadCountChanged(newValue)}
    }

    public var displayNameChanged: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged {
      get {
        if case .displayNameChanged(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged()
      }
      set {kind = .displayNameChanged(newValue)}
    }

    public var coverChargeChanged: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged {
      get {
        if case .coverChargeChanged(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged()
      }
      set {kind = .coverChargeChanged(newValue)}
    }

    public var lastActivityChanged: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged {
      get {
        if case .lastActivityChanged(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged()
      }
      set {kind = .lastActivityChanged(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case fullRefresh(Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh)
      case unreadCountChanged(Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged)
      case displayNameChanged(Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged)
      case coverChargeChanged(Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged)
      case lastActivityChanged(Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged)

    #if !swift(>=4.1)
      public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.OneOf_Kind, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fullRefresh, .fullRefresh): return {
          guard case .fullRefresh(let l) = lhs, case .fullRefresh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unreadCountChanged, .unreadCountChanged): return {
          guard case .unreadCountChanged(let l) = lhs, case .unreadCountChanged(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.displayNameChanged, .displayNameChanged): return {
          guard case .displayNameChanged(let l) = lhs, case .displayNameChanged(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.coverChargeChanged, .coverChargeChanged): return {
          guard case .coverChargeChanged(let l) = lhs, case .coverChargeChanged(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.lastActivityChanged, .lastActivityChanged): return {
          guard case .lastActivityChanged(let l) = lhs, case .lastActivityChanged(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Refreshes the entire chat metadata
    public struct FullRefresh {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var metadata: Flipchat_Chat_V1_Metadata {
        get {return _metadata ?? Flipchat_Chat_V1_Metadata()}
        set {_metadata = newValue}
      }
      /// Returns true if `metadata` has been explicitly set.
      public var hasMetadata: Bool {return self._metadata != nil}
      /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
      public mutating func clearMetadata() {self._metadata = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadata: Flipchat_Chat_V1_Metadata? = nil
    }

    /// New message in the chat has generated a new unread count
    public struct UnreadCountChanged {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Number of (estimated) unread message
      public var numUnread: UInt32 = 0

      /// If there are more unread messages than indicated by num_unread.
      /// If this is true, client should show num_unread+ as the unread count.
      public var hasMoreUnread_p: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The chat display name has been updated to a new value
    public struct DisplayNameChanged {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var newDisplayName: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The chat cover charge has been updated to a new value
    public struct CoverChargeChanged {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var newCoverCharge: Flipchat_Common_V1_PaymentAmount {
        get {return _newCoverCharge ?? Flipchat_Common_V1_PaymentAmount()}
        set {_newCoverCharge = newValue}
      }
      /// Returns true if `newCoverCharge` has been explicitly set.
      public var hasNewCoverCharge: Bool {return self._newCoverCharge != nil}
      /// Clears the value of `newCoverCharge`. Subsequent reads from it will return its default value.
      public mutating func clearNewCoverCharge() {self._newCoverCharge = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _newCoverCharge: Flipchat_Common_V1_PaymentAmount? = nil
    }

    /// The last activity timestamp has changed to a newer value
    public struct LastActivityChanged {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var newLastActivity: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _newLastActivity ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_newLastActivity = newValue}
      }
      /// Returns true if `newLastActivity` has been explicitly set.
      public var hasNewLastActivity: Bool {return self._newLastActivity != nil}
      /// Clears the value of `newLastActivity`. Subsequent reads from it will return its default value.
      public mutating func clearNewLastActivity() {self._newLastActivity = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _newLastActivity: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    public init() {}
  }

  public struct MemberUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind? = nil

    public var fullRefresh: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh {
      get {
        if case .fullRefresh(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh()
      }
      set {kind = .fullRefresh(newValue)}
    }

    public var individualRefresh: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh {
      get {
        if case .individualRefresh(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh()
      }
      set {kind = .individualRefresh(newValue)}
    }

    public var joined: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined {
      get {
        if case .joined(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined()
      }
      set {kind = .joined(newValue)}
    }

    public var left: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left {
      get {
        if case .left(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left()
      }
      set {kind = .left(newValue)}
    }

    public var removed: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed {
      get {
        if case .removed(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed()
      }
      set {kind = .removed(newValue)}
    }

    public var muted: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted {
      get {
        if case .muted(let v)? = kind {return v}
        return Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted()
      }
      set {kind = .muted(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case fullRefresh(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh)
      case individualRefresh(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh)
      case joined(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined)
      case left(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left)
      case removed(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed)
      case muted(Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted)

    #if !swift(>=4.1)
      public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fullRefresh, .fullRefresh): return {
          guard case .fullRefresh(let l) = lhs, case .fullRefresh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.individualRefresh, .individualRefresh): return {
          guard case .individualRefresh(let l) = lhs, case .individualRefresh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.joined, .joined): return {
          guard case .joined(let l) = lhs, case .joined(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.left, .left): return {
          guard case .left(let l) = lhs, case .left(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.removed, .removed): return {
          guard case .removed(let l) = lhs, case .removed(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.muted, .muted): return {
          guard case .muted(let l) = lhs, case .muted(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Refreshes the state of the entire chat membership
    public struct FullRefresh {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var members: [Flipchat_Chat_V1_Member] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Refreshes the state of an individual member in the chat
    public struct IndividualRefresh {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Chat_V1_Member {
        get {return _member ?? Flipchat_Chat_V1_Member()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Chat_V1_Member? = nil
    }

    /// Member joined the chat via the JoinChat RPC
    public struct Joined {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Chat_V1_Member {
        get {return _member ?? Flipchat_Chat_V1_Member()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Chat_V1_Member? = nil
    }

    /// Member left the chat via the LeaveChat RPC
    public struct Left {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Common_V1_UserId {
        get {return _member ?? Flipchat_Common_V1_UserId()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Common_V1_UserId? = nil
    }

    /// Member was removed from the chat via the RemoveUser RPC
    public struct Removed {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Common_V1_UserId {
        get {return _member ?? Flipchat_Common_V1_UserId()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var removedBy: Flipchat_Common_V1_UserId {
        get {return _removedBy ?? Flipchat_Common_V1_UserId()}
        set {_removedBy = newValue}
      }
      /// Returns true if `removedBy` has been explicitly set.
      public var hasRemovedBy: Bool {return self._removedBy != nil}
      /// Clears the value of `removedBy`. Subsequent reads from it will return its default value.
      public mutating func clearRemovedBy() {self._removedBy = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Common_V1_UserId? = nil
      fileprivate var _removedBy: Flipchat_Common_V1_UserId? = nil
    }

    /// Member was muted in the chat via the MuteUser RPC
    public struct Muted {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var member: Flipchat_Common_V1_UserId {
        get {return _member ?? Flipchat_Common_V1_UserId()}
        set {_member = newValue}
      }
      /// Returns true if `member` has been explicitly set.
      public var hasMember: Bool {return self._member != nil}
      /// Clears the value of `member`. Subsequent reads from it will return its default value.
      public mutating func clearMember() {self._member = nil}

      public var mutedBy: Flipchat_Common_V1_UserId {
        get {return _mutedBy ?? Flipchat_Common_V1_UserId()}
        set {_mutedBy = newValue}
      }
      /// Returns true if `mutedBy` has been explicitly set.
      public var hasMutedBy: Bool {return self._mutedBy != nil}
      /// Clears the value of `mutedBy`. Subsequent reads from it will return its default value.
      public mutating func clearMutedBy() {self._mutedBy = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _member: Flipchat_Common_V1_UserId? = nil
      fileprivate var _mutedBy: Flipchat_Common_V1_UserId? = nil
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code] = [
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_GetChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var queryOptions: Flipchat_Common_V1_QueryOptions {
    get {return _queryOptions ?? Flipchat_Common_V1_QueryOptions()}
    set {_queryOptions = newValue}
  }
  /// Returns true if `queryOptions` has been explicitly set.
  public var hasQueryOptions: Bool {return self._queryOptions != nil}
  /// Clears the value of `queryOptions`. Subsequent reads from it will return its default value.
  public mutating func clearQueryOptions() {self._queryOptions = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queryOptions: Flipchat_Common_V1_QueryOptions? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_GetChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_GetChatsResponse.Result = .ok

  public var chats: [Flipchat_Chat_V1_Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_GetChatsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_GetChatsResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_GetChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier? = nil

  public var chatID: Flipchat_Common_V1_ChatId {
    get {
      if case .chatID(let v)? = identifier {return v}
      return Flipchat_Common_V1_ChatId()
    }
    set {identifier = .chatID(newValue)}
  }

  public var roomNumber: UInt64 {
    get {
      if case .roomNumber(let v)? = identifier {return v}
      return 0
    }
    set {identifier = .roomNumber(newValue)}
  }

  public var excludeMembers: Bool = false

  /// Auth is an optional field that authenticates the call, which
  /// can be used to fill out extra information in the Metadata.
  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Identifier: Equatable {
    case chatID(Flipchat_Common_V1_ChatId)
    case roomNumber(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier, rhs: Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatID, .chatID): return {
        guard case .chatID(let l) = lhs, case .chatID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomNumber, .roomNumber): return {
        guard case .roomNumber(let l) = lhs, case .roomNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_GetChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_GetChatResponse.Result = .ok

  /// Metadata is the chat metadata, if result == OK.
  ///
  /// The contents of the metadata may change whether or not the
  /// call was authenticated.
  public var metadata: Flipchat_Chat_V1_Metadata {
    get {return _metadata ?? Flipchat_Chat_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Members contains the chat members, if result == OK and were requested.
  public var members: [Flipchat_Chat_V1_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_GetChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_GetChatResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_StartChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parameters: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters? = nil

  public var twoWayChat: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters {
    get {
      if case .twoWayChat(let v)? = parameters {return v}
      return Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters()
    }
    set {parameters = .twoWayChat(newValue)}
  }

  public var groupChat: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters {
    get {
      if case .groupChat(let v)? = parameters {return v}
      return Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters()
    }
    set {parameters = .groupChat(newValue)}
  }

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parameters: Equatable {
    case twoWayChat(Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters)
    case groupChat(Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters, rhs: Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.twoWayChat, .twoWayChat): return {
        guard case .twoWayChat(let l) = lhs, case .twoWayChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupChat, .groupChat): return {
        guard case .groupChat(let l) = lhs, case .groupChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// StartTwoWayChatParameters contains the parameters required to start
  /// or recover a two way chat between the caller and the specified 'other_user'.
  ///
  /// The 'other_user' is currently the 'tip_address', normally retrieved from
  /// user.Identity.GetTwitterUser(username).
  public struct StartTwoWayChatParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account id of the user the caller wishes to chat with.
    public var otherUserID: Flipchat_Common_V1_UserId {
      get {return _otherUserID ?? Flipchat_Common_V1_UserId()}
      set {_otherUserID = newValue}
    }
    /// Returns true if `otherUserID` has been explicitly set.
    public var hasOtherUserID: Bool {return self._otherUserID != nil}
    /// Clears the value of `otherUserID`. Subsequent reads from it will return its default value.
    public mutating func clearOtherUserID() {self._otherUserID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _otherUserID: Flipchat_Common_V1_UserId? = nil
  }

  public struct StartGroupChatParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A set of users (not including self) to initially set in the group chat.
    public var users: [Flipchat_Common_V1_UserId] = []

    /// Optional payment for creating the group. It's up to server to decide
    /// if the user is allowed to create a group without payment.
    public var paymentIntent: Flipchat_Common_V1_IntentId {
      get {return _paymentIntent ?? Flipchat_Common_V1_IntentId()}
      set {_paymentIntent = newValue}
    }
    /// Returns true if `paymentIntent` has been explicitly set.
    public var hasPaymentIntent: Bool {return self._paymentIntent != nil}
    /// Clears the value of `paymentIntent`. Subsequent reads from it will return its default value.
    public mutating func clearPaymentIntent() {self._paymentIntent = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _paymentIntent: Flipchat_Common_V1_IntentId? = nil
  }

  public init() {}

  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_StartChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_StartChatResponse.Result = .ok

  /// The chat to use, if result == OK.
  public var chat: Flipchat_Chat_V1_Metadata {
    get {return _chat ?? Flipchat_Chat_V1_Metadata()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  /// Members contains the chat members, if result == OK.
  public var members: [Flipchat_Chat_V1_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// DENIED indicates the caller is not allowed to start/join the chat.
    case denied // = 1

    /// USER_NOT_FOUND indicates that (one of) the target user's was not found.
    case userNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .userNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .userNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chat: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_StartChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_StartChatResponse.Result] = [
    .ok,
    .denied,
    .userNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_StartGroupChatPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user creating the group chat, who will be the initial owner
  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
}

public struct Flipchat_Chat_V1_JoinChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier? = nil

  public var chatID: Flipchat_Common_V1_ChatId {
    get {
      if case .chatID(let v)? = identifier {return v}
      return Flipchat_Common_V1_ChatId()
    }
    set {identifier = .chatID(newValue)}
  }

  public var roomID: UInt64 {
    get {
      if case .roomID(let v)? = identifier {return v}
      return 0
    }
    set {identifier = .roomID(newValue)}
  }

  /// Does the user want to join without the ability to send messages in the chat?
  /// If so, then payment_intent is not required? Otherwise, it is.
  public var withoutSendPermission: Bool = false

  /// The payment for joining a chat, which is required for sending messages in
  /// the chat.
  ///
  /// Note: The chat owner can always bypass payment.
  public var paymentIntent: Flipchat_Common_V1_IntentId {
    get {return _paymentIntent ?? Flipchat_Common_V1_IntentId()}
    set {_paymentIntent = newValue}
  }
  /// Returns true if `paymentIntent` has been explicitly set.
  public var hasPaymentIntent: Bool {return self._paymentIntent != nil}
  /// Clears the value of `paymentIntent`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentIntent() {self._paymentIntent = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Identifier: Equatable {
    case chatID(Flipchat_Common_V1_ChatId)
    case roomID(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier, rhs: Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatID, .chatID): return {
        guard case .chatID(let l) = lhs, case .chatID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomID, .roomID): return {
        guard case .roomID(let l) = lhs, case .roomID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _paymentIntent: Flipchat_Common_V1_IntentId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_JoinChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_JoinChatResponse.Result = .ok

  /// The chat metadata, if join was successful.
  public var metadata: Flipchat_Chat_V1_Metadata {
    get {return _metadata ?? Flipchat_Chat_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// The members of the chat, if join was successful.
  public var members: [Flipchat_Chat_V1_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Flipchat_Chat_V1_Metadata? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_JoinChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_JoinChatResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_JoinChatPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user joining the chat
  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The chat that the user is joining
  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
}

public struct Flipchat_Chat_V1_LeaveChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_LeaveChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_LeaveChatResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_LeaveChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_LeaveChatResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_SetDisplayNameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var displayName: String = String()

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_SetDisplayNameResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_SetDisplayNameResponse.Result = .ok

  public var alternateSuggestions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case cantSet // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .cantSet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .cantSet: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_SetDisplayNameResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_SetDisplayNameResponse.Result] = [
    .ok,
    .denied,
    .cantSet,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_SetCoverChargeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var coverCharge: Flipchat_Common_V1_PaymentAmount {
    get {return _coverCharge ?? Flipchat_Common_V1_PaymentAmount()}
    set {_coverCharge = newValue}
  }
  /// Returns true if `coverCharge` has been explicitly set.
  public var hasCoverCharge: Bool {return self._coverCharge != nil}
  /// Clears the value of `coverCharge`. Subsequent reads from it will return its default value.
  public mutating func clearCoverCharge() {self._coverCharge = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _coverCharge: Flipchat_Common_V1_PaymentAmount? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_SetCoverChargeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_SetCoverChargeResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case cantSet // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .cantSet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .cantSet: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_SetCoverChargeResponse.Result] = [
    .ok,
    .denied,
    .cantSet,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_RemoveUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_RemoveUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_RemoveUserResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_RemoveUserResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_RemoveUserResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_MuteUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_MuteUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_MuteUserResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_MuteUserResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_MuteUserResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_MuteChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_MuteChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_MuteChatResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_MuteChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_MuteChatResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_UnmuteChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_UnmuteChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_UnmuteChatResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_UnmuteChatResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_UnmuteChatResponse.Result] = [
    .ok,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_ReportUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var messageID: Flipchat_Messaging_V1_MessageId {
    get {return _messageID ?? Flipchat_Messaging_V1_MessageId()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var auth: Flipchat_Common_V1_Auth {
    get {return _auth ?? Flipchat_Common_V1_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _messageID: Flipchat_Messaging_V1_MessageId? = nil
  fileprivate var _auth: Flipchat_Common_V1_Auth? = nil
}

public struct Flipchat_Chat_V1_ReportUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Flipchat_Chat_V1_ReportUserResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_ReportUserResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_ReportUserResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Flipchat_Common_V1_ChatId {
    get {return _chatID ?? Flipchat_Common_V1_ChatId()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  /// The type of chat
  public var type: Flipchat_Chat_V1_Metadata.ChatType = .unknown

  /// The chat display name
  public var displayName: String = String()

  /// If non-zero, the room number associated with the chat.
  public var roomNumber: UInt64 = 0

  /// Are push notifications enabled for this chat (from the perspective of the caller)?
  public var isPushEnabled: Bool = false

  /// Can the user disable push notifications for this chat using MuteChat?
  public var canDisablePush: Bool = false

  /// Number of (estimated) unread message (from the perspective of the caller).
  public var numUnread: UInt32 = 0

  /// If there are more unread messages than indicated by num_unread. If this is
  /// true, client should show num_unread+ as the unread count.
  public var hasMoreUnread_p: Bool = false

  /// Owner is the owner/creator of the chat.
  ///
  /// This is a super priviledge role, in which there can only be one.
  /// This role is displayed as a 'host' currently.
  public var owner: Flipchat_Common_V1_UserId {
    get {return _owner ?? Flipchat_Common_V1_UserId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// If present, the cover charge that must be paid to join the chat
  public var coverCharge: Flipchat_Common_V1_PaymentAmount {
    get {return _coverCharge ?? Flipchat_Common_V1_PaymentAmount()}
    set {_coverCharge = newValue}
  }
  /// Returns true if `coverCharge` has been explicitly set.
  public var hasCoverCharge: Bool {return self._coverCharge != nil}
  /// Clears the value of `coverCharge`. Subsequent reads from it will return its default value.
  public mutating func clearCoverCharge() {self._coverCharge = nil}

  /// The timestamp of the last activity in this chat
  public var lastActivity: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastActivity ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastActivity = newValue}
  }
  /// Returns true if `lastActivity` has been explicitly set.
  public var hasLastActivity: Bool {return self._lastActivity != nil}
  /// Clears the value of `lastActivity`. Subsequent reads from it will return its default value.
  public mutating func clearLastActivity() {self._lastActivity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ChatType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case twoWay // = 1
    case group // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .twoWay
      case 2: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .twoWay: return 1
      case .group: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _chatID: Flipchat_Common_V1_ChatId? = nil
  fileprivate var _owner: Flipchat_Common_V1_UserId? = nil
  fileprivate var _coverCharge: Flipchat_Common_V1_PaymentAmount? = nil
  fileprivate var _lastActivity: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Flipchat_Chat_V1_Metadata.ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipchat_Chat_V1_Metadata.ChatType] = [
    .unknown,
    .twoWay,
    .group,
  ]
}

#endif  // swift(>=4.2)

public struct Flipchat_Chat_V1_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Flipchat_Common_V1_UserId {
    get {return _userID ?? Flipchat_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The chat member's identity/profile information.
  ///
  /// It is a light weight version of the users full profile, which
  /// can be retrieved from the Profile service.
  public var identity: Flipchat_Chat_V1_MemberIdentity {
    get {return _identity ?? Flipchat_Chat_V1_MemberIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {self._identity = nil}

  /// Chat message state for this member.
  ///
  /// If set, the list may contain DELIVERED and READ pointers. SENT pointers
  /// are only shared between the sender and server, to indicate persistence.
  ///
  /// The server may wish to omit all pointers in various types of group chats
  /// or as relief valves.
  public var pointers: [Flipchat_Messaging_V1_Pointer] = []

  /// If the member is the caller (where applicable), will be set to true.
  public var isSelf: Bool = false

  /// Does the chat member have permission to perform moderation actions in
  /// the chat?
  public var hasModeratorPermission_p: Bool = false

  /// Has the chat member been muted by a moderator? If so, they cannot send
  /// messages, even if they paid for the permission.
  public var isMuted: Bool = false

  /// Does the chat member have permission to send messages in the chat? If
  /// not, the user is considered to be a spectator.
  public var hasSendPermission_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: Flipchat_Common_V1_UserId? = nil
  fileprivate var _identity: Flipchat_Chat_V1_MemberIdentity? = nil
}

public struct Flipchat_Chat_V1_MemberIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, the display name of the user.
  public var displayName: String = String()

  /// If present, the URL of the users profile pic.
  public var profilePicURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipchat_Chat_V1_StreamChatEventsRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsRequest.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsRequest.Params: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.OneOf_Type: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.OneOf_Kind: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.OneOf_Kind: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed: @unchecked Sendable {}
extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatsResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatRequest.OneOf_Identifier: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_GetChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.OneOf_Parameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_StartGroupChatPaymentMetadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatRequest.OneOf_Identifier: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_JoinChatPaymentMetadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_LeaveChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetDisplayNameRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetDisplayNameResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetDisplayNameResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_RemoveUserRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_RemoveUserResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_RemoveUserResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteUserRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteUserResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteUserResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_MuteChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_UnmuteChatRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_UnmuteChatResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_UnmuteChatResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_ReportUserRequest: @unchecked Sendable {}
extension Flipchat_Chat_V1_ReportUserResponse: @unchecked Sendable {}
extension Flipchat_Chat_V1_ReportUserResponse.Result: @unchecked Sendable {}
extension Flipchat_Chat_V1_Metadata: @unchecked Sendable {}
extension Flipchat_Chat_V1_Metadata.ChatType: @unchecked Sendable {}
extension Flipchat_Chat_V1_Member: @unchecked Sendable {}
extension Flipchat_Chat_V1_MemberIdentity: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipchat.chat.v1"

extension Flipchat_Chat_V1_StreamChatEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StreamChatEventsRequest.Params?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .params(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .params(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Common_V1_ClientPong?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .params?: try {
      guard case .params(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest, rhs: Flipchat_Chat_V1_StreamChatEventsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsRequest.Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsRequest.protoMessageName + ".Params"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsRequest.Params, rhs: Flipchat_Chat_V1_StreamChatEventsRequest.Params) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamChatEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ping"),
    2: .same(proto: "error"),
    3: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ServerPing?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .error(v)
        }
      }()
      case 3: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .events(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .events(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .events?: try {
      guard case .events(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse, rhs: Flipchat_Chat_V1_StreamChatEventsResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".StreamError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.StreamError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.StreamError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".EventBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.EventBatch) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".ChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "metadata"),
    7: .standard(proto: "metadata_updates"),
    3: .standard(proto: "member_update"),
    8: .standard(proto: "member_updates"),
    4: .standard(proto: "last_message"),
    5: .same(proto: "pointer"),
    6: .standard(proto: "is_typing"),
  ]

  fileprivate class _StorageClass {
    var _chatID: Flipchat_Common_V1_ChatId? = nil
    var _metadata: Flipchat_Chat_V1_Metadata? = nil
    var _metadataUpdates: [Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate] = []
    var _memberUpdate: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate? = nil
    var _memberUpdates: [Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate] = []
    var _lastMessage: Flipchat_Messaging_V1_Message? = nil
    var _pointer: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate? = nil
    var _isTyping: Flipchat_Messaging_V1_IsTyping? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _metadata = source._metadata
      _metadataUpdates = source._metadataUpdates
      _memberUpdate = source._memberUpdate
      _memberUpdates = source._memberUpdates
      _lastMessage = source._lastMessage
      _pointer = source._pointer
      _isTyping = source._isTyping
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memberUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pointer) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._isTyping) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._metadataUpdates) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._memberUpdates) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chatID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memberUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._pointer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isTyping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._metadataUpdates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metadataUpdates, fieldNumber: 7)
      }
      if !_storage._memberUpdates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._memberUpdates, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._metadataUpdates != rhs_storage._metadataUpdates {return false}
        if _storage._memberUpdate != rhs_storage._memberUpdate {return false}
        if _storage._memberUpdates != rhs_storage._memberUpdates {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._pointer != rhs_storage._pointer {return false}
        if _storage._isTyping != rhs_storage._isTyping {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.protoMessageName + ".PointerUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "pointer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.ChatUpdate.PointerUpdate) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs._pointer != rhs._pointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".MetadataUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_refresh"),
    2: .standard(proto: "unread_count_changed"),
    3: .standard(proto: "display_name_changed"),
    4: .standard(proto: "cover_charge_changed"),
    5: .standard(proto: "last_activity_changed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .fullRefresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .fullRefresh(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .unreadCountChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .unreadCountChanged(v)
        }
      }()
      case 3: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .displayNameChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .displayNameChanged(v)
        }
      }()
      case 4: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .coverChargeChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .coverChargeChanged(v)
        }
      }()
      case 5: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .lastActivityChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .lastActivityChanged(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .fullRefresh?: try {
      guard case .fullRefresh(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unreadCountChanged?: try {
      guard case .unreadCountChanged(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .displayNameChanged?: try {
      guard case .displayNameChanged(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .coverChargeChanged?: try {
      guard case .coverChargeChanged(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .lastActivityChanged?: try {
      guard case .lastActivityChanged(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.protoMessageName + ".FullRefresh"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.FullRefresh) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.protoMessageName + ".UnreadCountChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_unread"),
    2: .standard(proto: "has_more_unread"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasMoreUnread_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 1)
    }
    if self.hasMoreUnread_p != false {
      try visitor.visitSingularBoolField(value: self.hasMoreUnread_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.UnreadCountChanged) -> Bool {
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs.hasMoreUnread_p != rhs.hasMoreUnread_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.protoMessageName + ".DisplayNameChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newDisplayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDisplayName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.DisplayNameChanged) -> Bool {
    if lhs.newDisplayName != rhs.newDisplayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.protoMessageName + ".CoverChargeChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_cover_charge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newCoverCharge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newCoverCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.CoverChargeChanged) -> Bool {
    if lhs._newCoverCharge != rhs._newCoverCharge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.protoMessageName + ".LastActivityChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_last_activity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newLastActivity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newLastActivity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MetadataUpdate.LastActivityChanged) -> Bool {
    if lhs._newLastActivity != rhs._newLastActivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.protoMessageName + ".MemberUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_refresh"),
    2: .standard(proto: "individual_refresh"),
    3: .same(proto: "joined"),
    4: .same(proto: "left"),
    5: .same(proto: "removed"),
    6: .same(proto: "muted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .fullRefresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .fullRefresh(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .individualRefresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .individualRefresh(v)
        }
      }()
      case 3: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .joined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .joined(v)
        }
      }()
      case 4: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .left(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .left(v)
        }
      }()
      case 5: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .removed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .removed(v)
        }
      }()
      case 6: try {
        var v: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .muted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .muted(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .fullRefresh?: try {
      guard case .fullRefresh(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .individualRefresh?: try {
      guard case .individualRefresh(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .joined?: try {
      guard case .joined(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .left?: try {
      guard case .left(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .removed?: try {
      guard case .removed(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .muted?: try {
      guard case .muted(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".FullRefresh"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.FullRefresh) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".IndividualRefresh"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.IndividualRefresh) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".Joined"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Joined) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".Left"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Left) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".Removed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .standard(proto: "removed_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._removedBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._removedBy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Removed) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs._removedBy != rhs._removedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.protoMessageName + ".Muted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .standard(proto: "muted_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mutedBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mutedBy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted, rhs: Flipchat_Chat_V1_StreamChatEventsResponse.MemberUpdate.Muted) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs._mutedBy != rhs._mutedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_options"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queryOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queryOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatsRequest, rhs: Flipchat_Chat_V1_GetChatsRequest) -> Bool {
    if lhs._queryOptions != rhs._queryOptions {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatsResponse, rhs: Flipchat_Chat_V1_GetChatsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Flipchat_Chat_V1_GetChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "room_number"),
    9: .standard(proto: "exclude_members"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ChatId?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .chatID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .chatID(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .roomNumber(v)
        }
      }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.excludeMembers) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .chatID?: try {
      guard case .chatID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .roomNumber?: try {
      guard case .roomNumber(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.excludeMembers != false {
      try visitor.visitSingularBoolField(value: self.excludeMembers, fieldNumber: 9)
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatRequest, rhs: Flipchat_Chat_V1_GetChatRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.excludeMembers != rhs.excludeMembers {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_GetChatResponse, rhs: Flipchat_Chat_V1_GetChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_GetChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Flipchat_Chat_V1_StartChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_way_chat"),
    2: .standard(proto: "group_chat"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .twoWayChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .twoWayChat(v)
        }
      }()
      case 2: try {
        var v: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .groupChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .groupChat(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.parameters {
    case .twoWayChat?: try {
      guard case .twoWayChat(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupChat?: try {
      guard case .groupChat(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest, rhs: Flipchat_Chat_V1_StartChatRequest) -> Bool {
    if lhs.parameters != rhs.parameters {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StartChatRequest.protoMessageName + ".StartTwoWayChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherUserID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters, rhs: Flipchat_Chat_V1_StartChatRequest.StartTwoWayChatParameters) -> Bool {
    if lhs._otherUserID != rhs._otherUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipchat_Chat_V1_StartChatRequest.protoMessageName + ".StartGroupChatParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
    3: .standard(proto: "payment_intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentIntent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try { if let v = self._paymentIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters, rhs: Flipchat_Chat_V1_StartChatRequest.StartGroupChatParameters) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs._paymentIntent != rhs._paymentIntent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "chat"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartChatResponse, rhs: Flipchat_Chat_V1_StartChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_StartChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "USER_NOT_FOUND"),
  ]
}

extension Flipchat_Chat_V1_StartGroupChatPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartGroupChatPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_StartGroupChatPaymentMetadata, rhs: Flipchat_Chat_V1_StartGroupChatPaymentMetadata) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "room_id"),
    8: .standard(proto: "without_send_permission"),
    9: .standard(proto: "payment_intent"),
    10: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipchat_Common_V1_ChatId?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .chatID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .chatID(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .roomID(v)
        }
      }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.withoutSendPermission) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._paymentIntent) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .chatID?: try {
      guard case .chatID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .roomID?: try {
      guard case .roomID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.withoutSendPermission != false {
      try visitor.visitSingularBoolField(value: self.withoutSendPermission, fieldNumber: 8)
    }
    try { if let v = self._paymentIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatRequest, rhs: Flipchat_Chat_V1_JoinChatRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.withoutSendPermission != rhs.withoutSendPermission {return false}
    if lhs._paymentIntent != rhs._paymentIntent {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatResponse, rhs: Flipchat_Chat_V1_JoinChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_JoinChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_JoinChatPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChatPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_JoinChatPaymentMetadata, rhs: Flipchat_Chat_V1_JoinChatPaymentMetadata) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._chatID != rhs._chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_LeaveChatRequest, rhs: Flipchat_Chat_V1_LeaveChatRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_LeaveChatResponse, rhs: Flipchat_Chat_V1_LeaveChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_LeaveChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Flipchat_Chat_V1_SetDisplayNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetDisplayNameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetDisplayNameRequest, rhs: Flipchat_Chat_V1_SetDisplayNameRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetDisplayNameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetDisplayNameResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "alternate_suggestions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.alternateSuggestions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.alternateSuggestions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alternateSuggestions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetDisplayNameResponse, rhs: Flipchat_Chat_V1_SetDisplayNameResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.alternateSuggestions != rhs.alternateSuggestions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetDisplayNameResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CANT_SET"),
  ]
}

extension Flipchat_Chat_V1_SetCoverChargeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCoverChargeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "cover_charge"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coverCharge) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coverCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetCoverChargeRequest, rhs: Flipchat_Chat_V1_SetCoverChargeRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._coverCharge != rhs._coverCharge {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetCoverChargeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCoverChargeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_SetCoverChargeResponse, rhs: Flipchat_Chat_V1_SetCoverChargeResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_SetCoverChargeResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CANT_SET"),
  ]
}

extension Flipchat_Chat_V1_RemoveUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_RemoveUserRequest, rhs: Flipchat_Chat_V1_RemoveUserRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_RemoveUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_RemoveUserResponse, rhs: Flipchat_Chat_V1_RemoveUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_RemoveUserResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_MuteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MuteUserRequest, rhs: Flipchat_Chat_V1_MuteUserRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MuteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MuteUserResponse, rhs: Flipchat_Chat_V1_MuteUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MuteUserResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_MuteChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MuteChatRequest, rhs: Flipchat_Chat_V1_MuteChatRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MuteChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MuteChatResponse, rhs: Flipchat_Chat_V1_MuteChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MuteChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_UnmuteChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnmuteChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_UnmuteChatRequest, rhs: Flipchat_Chat_V1_UnmuteChatRequest) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_UnmuteChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnmuteChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_UnmuteChatResponse, rhs: Flipchat_Chat_V1_UnmuteChatResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_UnmuteChatResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
  ]
}

extension Flipchat_Chat_V1_ReportUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_ReportUserRequest, rhs: Flipchat_Chat_V1_ReportUserRequest) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_ReportUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_ReportUserResponse, rhs: Flipchat_Chat_V1_ReportUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_ReportUserResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Flipchat_Chat_V1_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "type"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "room_number"),
    5: .standard(proto: "is_push_enabled"),
    6: .standard(proto: "can_disable_push"),
    7: .standard(proto: "num_unread"),
    11: .standard(proto: "has_more_unread"),
    8: .same(proto: "owner"),
    9: .standard(proto: "cover_charge"),
    10: .standard(proto: "last_activity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.roomNumber) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isPushEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.canDisablePush) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.numUnread) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._coverCharge) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._lastActivity) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.hasMoreUnread_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if self.roomNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.roomNumber, fieldNumber: 4)
    }
    if self.isPushEnabled != false {
      try visitor.visitSingularBoolField(value: self.isPushEnabled, fieldNumber: 5)
    }
    if self.canDisablePush != false {
      try visitor.visitSingularBoolField(value: self.canDisablePush, fieldNumber: 6)
    }
    if self.numUnread != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUnread, fieldNumber: 7)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._coverCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._lastActivity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.hasMoreUnread_p != false {
      try visitor.visitSingularBoolField(value: self.hasMoreUnread_p, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_Metadata, rhs: Flipchat_Chat_V1_Metadata) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.roomNumber != rhs.roomNumber {return false}
    if lhs.isPushEnabled != rhs.isPushEnabled {return false}
    if lhs.canDisablePush != rhs.canDisablePush {return false}
    if lhs.numUnread != rhs.numUnread {return false}
    if lhs.hasMoreUnread_p != rhs.hasMoreUnread_p {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._coverCharge != rhs._coverCharge {return false}
    if lhs._lastActivity != rhs._lastActivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_Metadata.ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TWO_WAY"),
    2: .same(proto: "GROUP"),
  ]
}

extension Flipchat_Chat_V1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "identity"),
    3: .same(proto: "pointers"),
    4: .standard(proto: "is_self"),
    5: .standard(proto: "has_moderator_permission"),
    6: .standard(proto: "is_muted"),
    7: .standard(proto: "has_send_permission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pointers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSelf) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasModeratorPermission_p) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasSendPermission_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pointers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointers, fieldNumber: 3)
    }
    if self.isSelf != false {
      try visitor.visitSingularBoolField(value: self.isSelf, fieldNumber: 4)
    }
    if self.hasModeratorPermission_p != false {
      try visitor.visitSingularBoolField(value: self.hasModeratorPermission_p, fieldNumber: 5)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 6)
    }
    if self.hasSendPermission_p != false {
      try visitor.visitSingularBoolField(value: self.hasSendPermission_p, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_Member, rhs: Flipchat_Chat_V1_Member) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.pointers != rhs.pointers {return false}
    if lhs.isSelf != rhs.isSelf {return false}
    if lhs.hasModeratorPermission_p != rhs.hasModeratorPermission_p {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.hasSendPermission_p != rhs.hasSendPermission_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipchat_Chat_V1_MemberIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "profile_pic_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.profilePicURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.profilePicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePicURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipchat_Chat_V1_MemberIdentity, rhs: Flipchat_Chat_V1_MemberIdentity) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.profilePicURL != rhs.profilePicURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
