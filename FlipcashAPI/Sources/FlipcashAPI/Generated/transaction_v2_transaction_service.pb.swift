// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction/v2/transaction_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Code_Transaction_V2_AirdropType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Reward for giving someone else their first crypto
  case giveFirstCrypto // = 1

  /// Airdrop for getting a user started with first crypto balance
  case getFirstCrypto // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .giveFirstCrypto
    case 2: self = .getFirstCrypto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .giveFirstCrypto: return 1
    case .getFirstCrypto: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Code_Transaction_V2_AirdropType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_AirdropType] = [
    .unknown,
    .giveFirstCrypto,
    .getFirstCrypto,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_SubmitIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request? = nil

  public var submitActions: Code_Transaction_V2_SubmitIntentRequest.SubmitActions {
    get {
      if case .submitActions(let v)? = request {return v}
      return Code_Transaction_V2_SubmitIntentRequest.SubmitActions()
    }
    set {request = .submitActions(newValue)}
  }

  public var submitSignatures: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures {
    get {
      if case .submitSignatures(let v)? = request {return v}
      return Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures()
    }
    set {request = .submitSignatures(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case submitActions(Code_Transaction_V2_SubmitIntentRequest.SubmitActions)
    case submitSignatures(Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request, rhs: Code_Transaction_V2_SubmitIntentRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.submitActions, .submitActions): return {
        guard case .submitActions(let l) = lhs, case .submitActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.submitSignatures, .submitSignatures): return {
        guard case .submitSignatures(let l) = lhs, case .submitSignatures(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct SubmitActions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The globally unique client generated intent ID. Use the original intent
    /// ID when operating on actions that mutate the intent.
    public var id: Code_Common_V1_IntentId {
      get {return _id ?? Code_Common_V1_IntentId()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// The verified owner account public key
    public var owner: Code_Common_V1_SolanaAccountId {
      get {return _owner ?? Code_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// Additional metadata that describes the high-level intention
    public var metadata: Code_Transaction_V2_Metadata {
      get {return _metadata ?? Code_Transaction_V2_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    /// The set of all ordered actions required to fulfill the intent
    public var actions: [Code_Transaction_V2_Action] = []

    /// The signature is of serialize(SubmitActions) without this field set using the
    /// private key of the owner account. This provides an authentication mechanism
    /// to the RPC.
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Code_Common_V1_IntentId? = nil
    fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _metadata: Code_Transaction_V2_Metadata? = nil
    fileprivate var _signature: Code_Common_V1_Signature? = nil
  }

  public struct SubmitSignatures {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all signatures for each transaction or virtual instruction requiring
    /// signature from the authority accounts.
    ///
    /// The signature for a transaction is for the marshalled transaction.
    /// The signature for a virtual instruction is the hash of the marshalled instruction.
    public var signatures: [Code_Common_V1_Signature] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Code_Transaction_V2_SubmitIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response? = nil

  public var serverParameters: Code_Transaction_V2_SubmitIntentResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Code_Transaction_V2_SubmitIntentResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Code_Transaction_V2_SubmitIntentResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Code_Transaction_V2_SubmitIntentResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case serverParameters(Code_Transaction_V2_SubmitIntentResponse.ServerParameters)
    case success(Code_Transaction_V2_SubmitIntentResponse.Success)
    case error(Code_Transaction_V2_SubmitIntentResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response, rhs: Code_Transaction_V2_SubmitIntentResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serverParameters, .serverParameters): return {
        guard case .serverParameters(let l) = lhs, case .serverParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ServerParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all server paremeters required to fill missing transaction
    /// or virtual instruction details. Server guarantees to provide a message
    /// for each client action in an order consistent with the received action
    /// list. 
    public var serverParameters: [Code_Transaction_V2_ServerParameter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SubmitIntentResponse.Success.Code = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The intent was successfully created and is now scheduled.
      case ok // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .ok
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ok
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .ok: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SubmitIntentResponse.Error.Code = .denied

    public var errorDetails: [Code_Transaction_V2_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// The intent is invalid.
      case invalidIntent // = 1

      /// There is an issue with provided signatures.
      case signatureError // = 2

      /// Server detected client has stale state.
      case staleState // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 1: self = .invalidIntent
        case 2: self = .signatureError
        case 3: self = .staleState
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .invalidIntent: return 1
        case .signatureError: return 2
        case .staleState: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SubmitIntentResponse.Success.Code] = [
    .ok,
  ]
}

extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SubmitIntentResponse.Error.Code] = [
    .denied,
    .invalidIntent,
    .signatureError,
    .staleState,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetIntentMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID to query
  public var intentID: Code_Common_V1_IntentId {
    get {return _intentID ?? Code_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The verified owner account public key when not signing with the rendezvous
  /// key. Only owner accounts involved in the intent can access the metadata.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetIntentStatusRequest) without this field set
  /// using the private key of the rendezvous or owner account. This provides an
  /// authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Code_Common_V1_IntentId? = nil
  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_GetIntentMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetIntentMetadataResponse.Result = .ok

  public var metadata: Code_Transaction_V2_Metadata {
    get {return _metadata ?? Code_Transaction_V2_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _metadata: Code_Transaction_V2_Metadata? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetIntentMetadataResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetIntentMetadataResponse.Result] = [
    .ok,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_GetLimitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account whose limits will be calculated. Any other owner accounts
  /// linked with the same identity of the owner will also be applied.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetLimitsRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// All transactions starting at this time will be incorporated into the consumed
  /// limit calculation. Clients should set this to the start of the current day in
  /// the client's current time zone (because server has no knowledge of this atm).
  public var consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _consumedSince ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_consumedSince = newValue}
  }
  /// Returns true if `consumedSince` has been explicitly set.
  public var hasConsumedSince: Bool {return self._consumedSince != nil}
  /// Clears the value of `consumedSince`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedSince() {self._consumedSince = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Code_Transaction_V2_GetLimitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_GetLimitsResponse.Result = .ok

  /// Send limits keyed by currency
  public var sendLimitsByCurrency: Dictionary<String,Code_Transaction_V2_SendLimit> = [:]

  /// Micro payment limits keyed by currency
  public var microPaymentLimitsByCurrency: Dictionary<String,Code_Transaction_V2_MicroPaymentLimit> = [:]

  /// Buy module limits keyed by currency
  public var buyModuleLimitsByCurrency: Dictionary<String,Code_Transaction_V2_BuyModuleLimit> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_GetLimitsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_GetLimitsResponse.Result] = [
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_CanWithdrawToAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Code_Common_V1_SolanaAccountId {
    get {return _account ?? Code_Common_V1_SolanaAccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_CanWithdrawToAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata so the client knows how to withdraw to the account. Server cannot
  /// provide precalculated addresses in this response to maintain non-custodial
  /// status.
  public var accountType: Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType = .unknown

  /// Server-controlled flag to indicate if the account can be withdrawn to.
  /// There are several reasons server may deny it, including:
  ///  - Wrong type of Code account
  ///  - Not wanting to subsidize the creation of an ATA
  ///  - Unsupported external account type (eg. token account but of the wrong mint)
  /// This is guaranteed to be false when account_type = Unknown.
  public var isValidPaymentDestination: Bool = false

  /// Token account requires initialization before the withdrawal can occur.
  /// Server has chosen not to subsidize the fees. The response is guaranteed
  /// to have set is_valid_payment_destination = false in this case.
  public var requiresInitialization: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AccountType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Server cannot determine
    case unknown // = 0

    /// Client uses the address as is in SubmitIntent
    case tokenAccount // = 1

    /// Client locally derives the ATA to use in SubmitIntent
    case ownerAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tokenAccount
      case 2: self = .ownerAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tokenAccount: return 1
      case .ownerAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType] = [
    .unknown,
    .tokenAccount,
    .ownerAccount,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_AirdropRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of airdrop to claim
  public var airdropType: Code_Transaction_V2_AirdropType = .unknown

  /// The owner account to airdrop core mint tokens to
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(AirdropRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_AirdropResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_AirdropResponse.Result = .ok

  /// Exchange data for the amount of core mint tokens airdropped when successful
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// Airdrops are unavailable
    case unavailable // = 1

    /// The airdrop has already been claimed by the owner
    case alreadyClaimed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unavailable
      case 2: self = .alreadyClaimed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unavailable: return 1
      case .alreadyClaimed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_AirdropResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_AirdropResponse.Result] = [
    .ok,
    .unavailable,
    .alreadyClaimed,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_SwapRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Code_Transaction_V2_SwapRequest.OneOf_Request? = nil

  public var initiate: Code_Transaction_V2_SwapRequest.Initiate {
    get {
      if case .initiate(let v)? = request {return v}
      return Code_Transaction_V2_SwapRequest.Initiate()
    }
    set {request = .initiate(newValue)}
  }

  public var submitSignature: Code_Transaction_V2_SwapRequest.SubmitSignature {
    get {
      if case .submitSignature(let v)? = request {return v}
      return Code_Transaction_V2_SwapRequest.SubmitSignature()
    }
    set {request = .submitSignature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case initiate(Code_Transaction_V2_SwapRequest.Initiate)
    case submitSignature(Code_Transaction_V2_SwapRequest.SubmitSignature)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SwapRequest.OneOf_Request, rhs: Code_Transaction_V2_SwapRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initiate, .initiate): return {
        guard case .initiate(let l) = lhs, case .initiate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.submitSignature, .submitSignature): return {
        guard case .submitSignature(let l) = lhs, case .submitSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Initiate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The verified owner account public key
    public var owner: Code_Common_V1_SolanaAccountId {
      get {return _owner ?? Code_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// The user authority account that will sign to authorize the swap. Ideally,
    /// this is an account derived off the owner account that is solely responsible
    /// for swapping.
    public var swapAuthority: Code_Common_V1_SolanaAccountId {
      get {return _swapAuthority ?? Code_Common_V1_SolanaAccountId()}
      set {_swapAuthority = newValue}
    }
    /// Returns true if `swapAuthority` has been explicitly set.
    public var hasSwapAuthority: Bool {return self._swapAuthority != nil}
    /// Clears the value of `swapAuthority`. Subsequent reads from it will return its default value.
    public mutating func clearSwapAuthority() {self._swapAuthority = nil}

    /// Maximum amount to swap from the source mint, in quarks. If value is set to zero,
    /// the entire amount will be swapped.
    public var limit: UInt64 = 0

    /// Whether the client wants the RPC to wait for blockchain status. If false,
    /// then the RPC will return Success when the swap is submitted to the blockchain.
    /// Otherwise, the RPC will observe and report back the status of the transaction.
    public var waitForBlockchainStatus: Bool = false

    /// The signature is of serialize(Initiate) without this field set using the
    /// private key of the owner account. This provides an authentication mechanism
    /// to the RPC.
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _swapAuthority: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _signature: Code_Common_V1_Signature? = nil
  }

  public struct SubmitSignature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The signature for the locally constructed swap transaction
    public var signature: Code_Common_V1_Signature {
      get {return _signature ?? Code_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _signature: Code_Common_V1_Signature? = nil
  }

  public init() {}
}

public struct Code_Transaction_V2_SwapResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Code_Transaction_V2_SwapResponse.OneOf_Response? = nil

  public var serverParameters: Code_Transaction_V2_SwapResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Code_Transaction_V2_SwapResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Code_Transaction_V2_SwapResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Code_Transaction_V2_SwapResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case serverParameters(Code_Transaction_V2_SwapResponse.ServerParameters)
    case success(Code_Transaction_V2_SwapResponse.Success)
    case error(Code_Transaction_V2_SwapResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_SwapResponse.OneOf_Response, rhs: Code_Transaction_V2_SwapResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serverParameters, .serverParameters): return {
        guard case .serverParameters(let l) = lhs, case .serverParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ServerParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Subisdizer account that will be paying for the swap
    public var payer: Code_Common_V1_SolanaAccountId {
      get {return _payer ?? Code_Common_V1_SolanaAccountId()}
      set {_payer = newValue}
    }
    /// Returns true if `payer` has been explicitly set.
    public var hasPayer: Bool {return self._payer != nil}
    /// Clears the value of `payer`. Subsequent reads from it will return its default value.
    public mutating func clearPayer() {self._payer = nil}

    /// Recent blockhash
    public var recentBlockhash: Code_Common_V1_Blockhash {
      get {return _recentBlockhash ?? Code_Common_V1_Blockhash()}
      set {_recentBlockhash = newValue}
    }
    /// Returns true if `recentBlockhash` has been explicitly set.
    public var hasRecentBlockhash: Bool {return self._recentBlockhash != nil}
    /// Clears the value of `recentBlockhash`. Subsequent reads from it will return its default value.
    public mutating func clearRecentBlockhash() {self._recentBlockhash = nil}

    /// Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
    /// instruction. If the value is 0, then the instruction can be omitted.
    public var computeUnitLimit: UInt32 = 0

    /// Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
    /// instruction. If the value is 0, then the instruction can be omitted.
    public var computeUnitPrice: UInt64 = 0

    /// On-chain program that will be performing the swap
    public var swapProgram: Code_Common_V1_SolanaAccountId {
      get {return _swapProgram ?? Code_Common_V1_SolanaAccountId()}
      set {_swapProgram = newValue}
    }
    /// Returns true if `swapProgram` has been explicitly set.
    public var hasSwapProgram: Bool {return self._swapProgram != nil}
    /// Clears the value of `swapProgram`. Subsequent reads from it will return its default value.
    public mutating func clearSwapProgram() {self._swapProgram = nil}

    /// Accounts provided to the swap instruction
    public var swapIxnAccounts: [Code_Common_V1_InstructionAccount] = []

    /// Instruction data for the swap instruction
    public var swapIxnData: Data = Data()

    /// Maximum quarks that will be sent out of the source account after
    /// executing the swap. If not, the validation instruction will cause
    /// the transaction to fail.
    public var maxToSend: UInt64 = 0

    /// Minimum quarks that will be received into the destination account
    /// after executing the swap. If not, the validation instruction will
    /// cause the transaction to fail.
    public var minToReceive: UInt64 = 0

    /// Nonce to use in swap validator state account PDA
    public var nonce: Code_Common_V1_SolanaAccountId {
      get {return _nonce ?? Code_Common_V1_SolanaAccountId()}
      set {_nonce = newValue}
    }
    /// Returns true if `nonce` has been explicitly set.
    public var hasNonce: Bool {return self._nonce != nil}
    /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
    public mutating func clearNonce() {self._nonce = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _payer: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _recentBlockhash: Code_Common_V1_Blockhash? = nil
    fileprivate var _swapProgram: Code_Common_V1_SolanaAccountId? = nil
    fileprivate var _nonce: Code_Common_V1_SolanaAccountId? = nil
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SwapResponse.Success.Code = .swapSubmitted

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The swap was submitted to the blockchain.
      case swapSubmitted // = 0

      /// The swap was finalized on the blockchain.
      case swapFinalized // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .swapSubmitted
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .swapSubmitted
        case 1: self = .swapFinalized
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .swapSubmitted: return 0
        case .swapFinalized: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Code_Transaction_V2_SwapResponse.Error.Code = .denied

    public var errorDetails: [Code_Transaction_V2_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// There is an issue with the provided signature.
      case signatureError // = 2

      /// The swap failed server-side validation
      case invalidSwap // = 3

      /// The submitted swap transaction failed. Attempt the swap again.
      case swapFailed // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 2: self = .signatureError
        case 3: self = .invalidSwap
        case 4: self = .swapFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .signatureError: return 2
        case .invalidSwap: return 3
        case .swapFailed: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_SwapResponse.Success.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SwapResponse.Success.Code] = [
    .swapSubmitted,
    .swapFinalized,
  ]
}

extension Code_Transaction_V2_SwapResponse.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_SwapResponse.Error.Code] = [
    .denied,
    .signatureError,
    .invalidSwap,
    .swapFailed,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account invoking the buy module
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The amount being purchased
  public var purchaseAmount: Code_Transaction_V2_ExchangeDataWithoutRate {
    get {return _purchaseAmount ?? Code_Transaction_V2_ExchangeDataWithoutRate()}
    set {_purchaseAmount = newValue}
  }
  /// Returns true if `purchaseAmount` has been explicitly set.
  public var hasPurchaseAmount: Bool {return self._purchaseAmount != nil}
  /// Clears the value of `purchaseAmount`. Subsequent reads from it will return its default value.
  public mutating func clearPurchaseAmount() {self._purchaseAmount = nil}

  /// A nonce value unique to the purchase. If it's included in a memo for the
  /// transaction for the deposit to the owner, then purchase_amount will be used
  /// for display values. Otherwise, the amount will be inferred from the transaction.
  public var nonce: Code_Common_V1_UUID {
    get {return _nonce ?? Code_Common_V1_UUID()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  public var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  public mutating func clearNonce() {self._nonce = nil}

  /// The signature is of serialize(DeclareFiatOnrampPurchaseAttemptRequest) without
  /// this field set using the private key of the owner account. This provides an
  /// authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _purchaseAmount: Code_Transaction_V2_ExchangeDataWithoutRate? = nil
  fileprivate var _nonce: Code_Common_V1_UUID? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The owner account is not valid (ie. it isn't a Code account)
    case invalidOwner // = 1

    /// The currency isn't supported
    case unsupportedCurrency // = 2

    /// The amount specified exceeds limits
    case amountExceedsMaximum // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidOwner
      case 2: self = .unsupportedCurrency
      case 3: self = .amountExceedsMaximum
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidOwner: return 1
      case .unsupportedCurrency: return 2
      case .amountExceedsMaximum: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result] = [
    .ok,
    .invalidOwner,
    .unsupportedCurrency,
    .amountExceedsMaximum,
  ]
}

#endif  // swift(>=4.2)

public struct Code_Transaction_V2_VoidGiftCardRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account that issued the gift card account
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The vault of the gift card account to void
  public var giftCardVault: Code_Common_V1_SolanaAccountId {
    get {return _giftCardVault ?? Code_Common_V1_SolanaAccountId()}
    set {_giftCardVault = newValue}
  }
  /// Returns true if `giftCardVault` has been explicitly set.
  public var hasGiftCardVault: Bool {return self._giftCardVault != nil}
  /// Clears the value of `giftCardVault`. Subsequent reads from it will return its default value.
  public mutating func clearGiftCardVault() {self._giftCardVault = nil}

  /// The signature is of serialize(VoidGiftCardRequest) without this field set using
  /// the private key of the owner account. This provides an authentication mechanism
  /// to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _giftCardVault: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_VoidGiftCardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Transaction_V2_VoidGiftCardResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0

    /// The owner account didn't issue the gift card accoun
    case denied // = 1

    /// A different owner account than the issuer claimed the gift card
    case claimedByOtherUser // = 2

    /// The gift card doesn't exist
    case notFound // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .claimedByOtherUser
      case 3: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .claimedByOtherUser: return 2
      case .notFound: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_VoidGiftCardResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_VoidGiftCardResponse.Result] = [
    .ok,
    .denied,
    .claimedByOtherUser,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

/// Metadata describes the high-level details of an intent
public struct Code_Transaction_V2_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Transaction_V2_Metadata.OneOf_Type? = nil

  public var openAccounts: Code_Transaction_V2_OpenAccountsMetadata {
    get {
      if case .openAccounts(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountsMetadata()
    }
    set {type = .openAccounts(newValue)}
  }

  public var sendPublicPayment: Code_Transaction_V2_SendPublicPaymentMetadata {
    get {
      if case .sendPublicPayment(let v)? = type {return v}
      return Code_Transaction_V2_SendPublicPaymentMetadata()
    }
    set {type = .sendPublicPayment(newValue)}
  }

  public var receivePaymentsPublicly: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata {
    get {
      if case .receivePaymentsPublicly(let v)? = type {return v}
      return Code_Transaction_V2_ReceivePaymentsPubliclyMetadata()
    }
    set {type = .receivePaymentsPublicly(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case openAccounts(Code_Transaction_V2_OpenAccountsMetadata)
    case sendPublicPayment(Code_Transaction_V2_SendPublicPaymentMetadata)
    case receivePaymentsPublicly(Code_Transaction_V2_ReceivePaymentsPubliclyMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_Metadata.OneOf_Type, rhs: Code_Transaction_V2_Metadata.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccounts, .openAccounts): return {
        guard case .openAccounts(let l) = lhs, case .openAccounts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendPublicPayment, .sendPublicPayment): return {
        guard case .sendPublicPayment(let l) = lhs, case .sendPublicPayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receivePaymentsPublicly, .receivePaymentsPublicly): return {
        guard case .receivePaymentsPublicly(let l) = lhs, case .receivePaymentsPublicly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Open a set of accounts. Currently, clients should only use this for new users
/// to open all required accounts up front..
///
/// Action Spec:
///
/// for account in [PRIMARY]
///   actions.push_back(OpenAccountAction(account))
public struct Code_Transaction_V2_OpenAccountsMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a payment to a destination account publicly.
///
/// Action Spec (Payment, Withdrawal):
///
/// actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
///
/// Action Spec (Remote Send):
///
/// actions = [
///   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
///   NoPrivacyTransferAction(PRIMARY, REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
///   NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, ExchangeData.Quarks, is_auto_return=true),
/// ]
///
/// todo: Possibly use a different action type for deferred closing?
public struct Code_Transaction_V2_SendPublicPaymentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The primary account where funds will be sent from. The primary account is assumed if this
  /// field is not set for backwards compatibility with old clients.
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination token account to send funds to.
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The exchange data of total funds being sent to the destination
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// Is the payment a withdrawal?
  public var isWithdrawal: Bool = false

  /// Is the payment going to a new gift card? Note is_withdrawal must be false.
  public var isRemoteSend: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

/// Receive funds into a user-owned account publicly. All use cases of this intent
/// close the account, so all funds must be moved.
///
/// Action Spec (Remote Send):
///
/// actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, quarks)]
public struct Code_Transaction_V2_ReceivePaymentsPubliclyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The remote send gift card to receive funds from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The exact amount of core mint quarks being received
  public var quarks: UInt64 = 0

  /// Is the receipt of funds from a remote send gift card? Currently, this is
  /// the only use case for this intent and validation enforces the flag to true.
  public var isRemoteSend: Bool = false

  /// If is_remote_send is true, the original exchange data that was provided as
  /// part of creating the gift card account. This is purely a server-provided value.
  /// SubmitIntent will disallow this being set.
  public var exchangeData: Code_Transaction_V2_ExchangeData {
    get {return _exchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Code_Transaction_V2_ExchangeData? = nil
}

/// Action is a well-defined, ordered and small set of transactions or virtual instructions
/// for a unit of work that the client wants to perform on the blockchain. Clients provide
/// parameters known to them in the action.
public struct Code_Transaction_V2_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this action, which is unique within an intent. It must match
  /// the index of the action's location in the SubmitAction's actions field.
  public var id: UInt32 = 0

  /// The type of action to perform.
  public var type: Code_Transaction_V2_Action.OneOf_Type? = nil

  public var openAccount: Code_Transaction_V2_OpenAccountAction {
    get {
      if case .openAccount(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountAction()
    }
    set {type = .openAccount(newValue)}
  }

  public var noPrivacyTransfer: Code_Transaction_V2_NoPrivacyTransferAction {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyTransferAction()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Code_Transaction_V2_NoPrivacyWithdrawAction {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyWithdrawAction()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var feePayment: Code_Transaction_V2_FeePaymentAction {
    get {
      if case .feePayment(let v)? = type {return v}
      return Code_Transaction_V2_FeePaymentAction()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of action to perform.
  public enum OneOf_Type: Equatable {
    case openAccount(Code_Transaction_V2_OpenAccountAction)
    case noPrivacyTransfer(Code_Transaction_V2_NoPrivacyTransferAction)
    case noPrivacyWithdraw(Code_Transaction_V2_NoPrivacyWithdrawAction)
    case feePayment(Code_Transaction_V2_FeePaymentAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_Action.OneOf_Type, rhs: Code_Transaction_V2_Action.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccount, .openAccount): return {
        guard case .openAccount(let l) = lhs, case .openAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyTransfer, .noPrivacyTransfer): return {
        guard case .noPrivacyTransfer(let l) = lhs, case .noPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyWithdraw, .noPrivacyWithdraw): return {
        guard case .noPrivacyWithdraw(let l) = lhs, case .noPrivacyWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feePayment, .feePayment): return {
        guard case .feePayment(let l) = lhs, case .feePayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// No client signature required
public struct Code_Transaction_V2_OpenAccountAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of account, which will dictate its intended use
  public var accountType: Code_Common_V1_AccountType = .unknown

  /// The owner of the account. For accounts liked to a user's 12 words, this is
  /// the verified parent owner account public key. All other account types should
  /// set this to the authority value.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The index used to for accounts that are derived from owner
  public var index: UInt64 = 0

  /// The public key of the private key that has authority over the opened token account
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The token account being opened
  public var token: Code_Common_V1_SolanaAccountId {
    get {return _token ?? Code_Common_V1_SolanaAccountId()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The signature is of serialize(OpenAccountAction) without this field set
  /// using the private key of the authority account. This provides a proof
  /// of authorization to link authority to owner.
  public var authoritySignature: Code_Common_V1_Signature {
    get {return _authoritySignature ?? Code_Common_V1_Signature()}
    set {_authoritySignature = newValue}
  }
  /// Returns true if `authoritySignature` has been explicitly set.
  public var hasAuthoritySignature: Bool {return self._authoritySignature != nil}
  /// Clears the value of `authoritySignature`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritySignature() {self._authoritySignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _token: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _authoritySignature: Code_Common_V1_Signature? = nil
}

/// Compact message signature required
public struct Code_Transaction_V2_NoPrivacyTransferAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The core mint quark amount to transfer
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Compact message signature required
public struct Code_Transaction_V2_NoPrivacyWithdrawAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The intended core mint quark amount to withdraw
  public var amount: UInt64 = 0

  /// Whether the account is closed afterwards. This is always true, since there
  /// are no current se cases to leave it open.
  public var shouldClose: Bool = false

  /// Whether this action is for an auto-return, which client allows server to defer
  /// scheduling at its own discretion to return funds back to the owner (to their primary
  /// account) that funded source.
  public var isAutoReturn: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

/// Compact message signature required
public struct Code_Transaction_V2_FeePaymentAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of fee being operated on
  public var type: Code_Transaction_V2_FeePaymentAction.FeeType = .code

  /// The public key of the private key that has authority over source
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _authority ?? Code_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Code_Common_V1_SolanaAccountId {
    get {return _source ?? Code_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The core mint quark amount to transfer
  public var amount: UInt64 = 0

  /// The destination where the fee payment is being made for fees outside of
  /// Code.
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FeeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Hardcoded $0.01 USD fee to a dynamic fee account specified by server
    case code // = 0

    /// Third party fee specified at time of payment request
    case thirdParty // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .code
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .code
      case 1: self = .thirdParty
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .code: return 0
      case .thirdParty: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _authority: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

#if swift(>=4.2)

extension Code_Transaction_V2_FeePaymentAction.FeeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_FeePaymentAction.FeeType] = [
    .code,
    .thirdParty,
  ]
}

#endif  // swift(>=4.2)

/// ServerParameter are a set of parameters known and returned by server that
/// enables clients to complete transaction construction. Any necessary proofs,
/// which are required to be locally verifiable, are also provided to ensure
/// safe use in the event of a malicious server.
public struct Code_Transaction_V2_ServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action the server parameters belong to
  public var actionID: UInt32 = 0

  /// The set of nonces used for the action. Server will only provide values
  /// for transactions requiring client signatures.
  public var nonces: [Code_Transaction_V2_NoncedTransactionMetadata] = []

  /// The type of server parameter which maps to the type of action requested
  public var type: Code_Transaction_V2_ServerParameter.OneOf_Type? = nil

  public var openAccount: Code_Transaction_V2_OpenAccountServerParameter {
    get {
      if case .openAccount(let v)? = type {return v}
      return Code_Transaction_V2_OpenAccountServerParameter()
    }
    set {type = .openAccount(newValue)}
  }

  public var noPrivacyTransfer: Code_Transaction_V2_NoPrivacyTransferServerParameter {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyTransferServerParameter()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Code_Transaction_V2_NoPrivacyWithdrawServerParameter {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Code_Transaction_V2_NoPrivacyWithdrawServerParameter()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var feePayment: Code_Transaction_V2_FeePaymentServerParameter {
    get {
      if case .feePayment(let v)? = type {return v}
      return Code_Transaction_V2_FeePaymentServerParameter()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of server parameter which maps to the type of action requested
  public enum OneOf_Type: Equatable {
    case openAccount(Code_Transaction_V2_OpenAccountServerParameter)
    case noPrivacyTransfer(Code_Transaction_V2_NoPrivacyTransferServerParameter)
    case noPrivacyWithdraw(Code_Transaction_V2_NoPrivacyWithdrawServerParameter)
    case feePayment(Code_Transaction_V2_FeePaymentServerParameter)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_ServerParameter.OneOf_Type, rhs: Code_Transaction_V2_ServerParameter.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openAccount, .openAccount): return {
        guard case .openAccount(let l) = lhs, case .openAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyTransfer, .noPrivacyTransfer): return {
        guard case .noPrivacyTransfer(let l) = lhs, case .noPrivacyTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPrivacyWithdraw, .noPrivacyWithdraw): return {
        guard case .noPrivacyWithdraw(let l) = lhs, case .noPrivacyWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feePayment, .feePayment): return {
        guard case .feePayment(let l) = lhs, case .feePayment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// For transactions, the nonce is a standard nonce on Solana
/// For virtual instructions, the nonce is a virtual nonce on the Code VM
public struct Code_Transaction_V2_NoncedTransactionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nonce account to use in the system::AdvanceNonce instruction
  public var nonce: Code_Common_V1_SolanaAccountId {
    get {return _nonce ?? Code_Common_V1_SolanaAccountId()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  public var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  public mutating func clearNonce() {self._nonce = nil}

  /// The blockhash to set in the transaction or virtual instruction
  public var blockhash: Code_Common_V1_Blockhash {
    get {return _blockhash ?? Code_Common_V1_Blockhash()}
    set {_blockhash = newValue}
  }
  /// Returns true if `blockhash` has been explicitly set.
  public var hasBlockhash: Bool {return self._blockhash != nil}
  /// Clears the value of `blockhash`. Subsequent reads from it will return its default value.
  public mutating func clearBlockhash() {self._blockhash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nonce: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _blockhash: Code_Common_V1_Blockhash? = nil
}

/// There are no transactions requiring client signatures
public struct Code_Transaction_V2_OpenAccountServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_NoPrivacyTransferServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Code_Transaction_V2_NoPrivacyWithdrawServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_FeePaymentServerParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination account where Code fee payments should be sent. This will
  /// only be set when the corresponding FeePaymentAction Type is CODE.
  public var codeDestination: Code_Common_V1_SolanaAccountId {
    get {return _codeDestination ?? Code_Common_V1_SolanaAccountId()}
    set {_codeDestination = newValue}
  }
  /// Returns true if `codeDestination` has been explicitly set.
  public var hasCodeDestination: Bool {return self._codeDestination != nil}
  /// Clears the value of `codeDestination`. Subsequent reads from it will return its default value.
  public mutating func clearCodeDestination() {self._codeDestination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _codeDestination: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_ErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Code_Transaction_V2_ErrorDetails.OneOf_Type? = nil

  public var reasonString: Code_Transaction_V2_ReasonStringErrorDetails {
    get {
      if case .reasonString(let v)? = type {return v}
      return Code_Transaction_V2_ReasonStringErrorDetails()
    }
    set {type = .reasonString(newValue)}
  }

  public var invalidSignature: Code_Transaction_V2_InvalidSignatureErrorDetails {
    get {
      if case .invalidSignature(let v)? = type {return v}
      return Code_Transaction_V2_InvalidSignatureErrorDetails()
    }
    set {type = .invalidSignature(newValue)}
  }

  public var denied: Code_Transaction_V2_DeniedErrorDetails {
    get {
      if case .denied(let v)? = type {return v}
      return Code_Transaction_V2_DeniedErrorDetails()
    }
    set {type = .denied(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case reasonString(Code_Transaction_V2_ReasonStringErrorDetails)
    case invalidSignature(Code_Transaction_V2_InvalidSignatureErrorDetails)
    case denied(Code_Transaction_V2_DeniedErrorDetails)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_ErrorDetails.OneOf_Type, rhs: Code_Transaction_V2_ErrorDetails.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reasonString, .reasonString): return {
        guard case .reasonString(let l) = lhs, case .reasonString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invalidSignature, .invalidSignature): return {
        guard case .invalidSignature(let l) = lhs, case .invalidSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.denied, .denied): return {
        guard case .denied(let l) = lhs, case .denied(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Code_Transaction_V2_ReasonStringErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_InvalidSignatureErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action whose signature mismatched
  public var actionID: UInt32 = 0

  public var expectedBlob: Code_Transaction_V2_InvalidSignatureErrorDetails.OneOf_ExpectedBlob? = nil

  /// The transaction the server expected to have signed.
  public var expectedTransaction: Code_Common_V1_Transaction {
    get {
      if case .expectedTransaction(let v)? = expectedBlob {return v}
      return Code_Common_V1_Transaction()
    }
    set {expectedBlob = .expectedTransaction(newValue)}
  }

  /// The virtual ixn hash the server expected to have signed.
  public var expectedVixnHash: Code_Common_V1_Hash {
    get {
      if case .expectedVixnHash(let v)? = expectedBlob {return v}
      return Code_Common_V1_Hash()
    }
    set {expectedBlob = .expectedVixnHash(newValue)}
  }

  /// The signature that was provided by the client.
  public var providedSignature: Code_Common_V1_Signature {
    get {return _providedSignature ?? Code_Common_V1_Signature()}
    set {_providedSignature = newValue}
  }
  /// Returns true if `providedSignature` has been explicitly set.
  public var hasProvidedSignature: Bool {return self._providedSignature != nil}
  /// Clears the value of `providedSignature`. Subsequent reads from it will return its default value.
  public mutating func clearProvidedSignature() {self._providedSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ExpectedBlob: Equatable {
    /// The transaction the server expected to have signed.
    case expectedTransaction(Code_Common_V1_Transaction)
    /// The virtual ixn hash the server expected to have signed.
    case expectedVixnHash(Code_Common_V1_Hash)

  #if !swift(>=4.1)
    public static func ==(lhs: Code_Transaction_V2_InvalidSignatureErrorDetails.OneOf_ExpectedBlob, rhs: Code_Transaction_V2_InvalidSignatureErrorDetails.OneOf_ExpectedBlob) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.expectedTransaction, .expectedTransaction): return {
        guard case .expectedTransaction(let l) = lhs, case .expectedTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expectedVixnHash, .expectedVixnHash): return {
        guard case .expectedVixnHash(let l) = lhs, case .expectedVixnHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _providedSignature: Code_Common_V1_Signature? = nil
}

public struct Code_Transaction_V2_DeniedErrorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Code_Transaction_V2_DeniedErrorDetails.Code = .unspecified

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Reason code not yet defined
    case unspecified // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Code_Transaction_V2_DeniedErrorDetails.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Code_Transaction_V2_DeniedErrorDetails.Code] = [
    .unspecified,
  ]
}

#endif  // swift(>=4.2)

/// ExchangeData defines an amount of crypto with currency exchange data
public struct Code_Transaction_V2_ExchangeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon exchange rate. This might not be the same as the
  /// actual exchange rate at the time of intent or fund transfer.
  public var exchangeRate: Double = 0

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  /// The exact amount of quarks to send. This will be used as the source of
  /// truth for validating transaction transfer amounts.
  public var quarks: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_ExchangeDataWithoutRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_AdditionalFeePayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination token account where the fee payment will be made
  public var destination: Code_Common_V1_SolanaAccountId {
    get {return _destination ?? Code_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// Fee percentage, in basis points, of the total quark amount of a payment.
  public var feeBps: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: Code_Common_V1_SolanaAccountId? = nil
}

public struct Code_Transaction_V2_SendLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remaining limit to apply on the next transaction
  public var nextTransaction: Float = 0

  /// Maximum allowed on a per-transaction basis
  public var maxPerTransaction: Float = 0

  /// Maximum allowed on a per-day basis
  public var maxPerDay: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_MicroPaymentLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum native amount that can be applied per micro payment transaction
  public var maxPerTransaction: Float = 0

  /// Minimum native amount that can be applied per micro payment transaction
  public var minPerTransaction: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_BuyModuleLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum amount that can be purchased through the buy module
  public var minPerTransaction: Float = 0

  /// Maximum amount that can be purchased through the buy module
  public var maxPerTransaction: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Code_Transaction_V2_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Code_Transaction_V2_AirdropType: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.OneOf_Request: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.SubmitActions: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.OneOf_Response: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.ServerParameters: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Success: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Error: @unchecked Sendable {}
extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetIntentMetadataResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsRequest: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsResponse: @unchecked Sendable {}
extension Code_Transaction_V2_GetLimitsResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountRequest: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountResponse: @unchecked Sendable {}
extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropRequest: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropResponse: @unchecked Sendable {}
extension Code_Transaction_V2_AirdropResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.OneOf_Request: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.Initiate: @unchecked Sendable {}
extension Code_Transaction_V2_SwapRequest.SubmitSignature: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.OneOf_Response: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.ServerParameters: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Success: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Success.Code: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Error: @unchecked Sendable {}
extension Code_Transaction_V2_SwapResponse.Error.Code: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse: @unchecked Sendable {}
extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_VoidGiftCardRequest: @unchecked Sendable {}
extension Code_Transaction_V2_VoidGiftCardResponse: @unchecked Sendable {}
extension Code_Transaction_V2_VoidGiftCardResponse.Result: @unchecked Sendable {}
extension Code_Transaction_V2_Metadata: @unchecked Sendable {}
extension Code_Transaction_V2_Metadata.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountsMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_SendPublicPaymentMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_ReceivePaymentsPubliclyMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_Action: @unchecked Sendable {}
extension Code_Transaction_V2_Action.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountAction: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyTransferAction: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyWithdrawAction: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentAction: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentAction.FeeType: @unchecked Sendable {}
extension Code_Transaction_V2_ServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_ServerParameter.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_NoncedTransactionMetadata: @unchecked Sendable {}
extension Code_Transaction_V2_OpenAccountServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyTransferServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_NoPrivacyWithdrawServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_FeePaymentServerParameter: @unchecked Sendable {}
extension Code_Transaction_V2_ErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_ErrorDetails.OneOf_Type: @unchecked Sendable {}
extension Code_Transaction_V2_ReasonStringErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_InvalidSignatureErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_InvalidSignatureErrorDetails.OneOf_ExpectedBlob: @unchecked Sendable {}
extension Code_Transaction_V2_DeniedErrorDetails: @unchecked Sendable {}
extension Code_Transaction_V2_DeniedErrorDetails.Code: @unchecked Sendable {}
extension Code_Transaction_V2_ExchangeData: @unchecked Sendable {}
extension Code_Transaction_V2_ExchangeDataWithoutRate: @unchecked Sendable {}
extension Code_Transaction_V2_AdditionalFeePayment: @unchecked Sendable {}
extension Code_Transaction_V2_SendLimit: @unchecked Sendable {}
extension Code_Transaction_V2_MicroPaymentLimit: @unchecked Sendable {}
extension Code_Transaction_V2_BuyModuleLimit: @unchecked Sendable {}
extension Code_Transaction_V2_Cursor: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.transaction.v2"

extension Code_Transaction_V2_AirdropType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GIVE_FIRST_CRYPTO"),
    2: .same(proto: "GET_FIRST_CRYPTO"),
  ]
}

extension Code_Transaction_V2_SubmitIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "submit_actions"),
    2: .standard(proto: "submit_signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SubmitIntentRequest.SubmitActions?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitActions(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignatures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignatures(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .submitActions?: try {
      guard case .submitActions(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignatures?: try {
      guard case .submitSignatures(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest, rhs: Code_Transaction_V2_SubmitIntentRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentRequest.SubmitActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentRequest.protoMessageName + ".SubmitActions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "owner"),
    3: .same(proto: "metadata"),
    4: .same(proto: "actions"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.SubmitActions, rhs: Code_Transaction_V2_SubmitIntentRequest.SubmitActions) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentRequest.protoMessageName + ".SubmitSignatures"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures, rhs: Code_Transaction_V2_SubmitIntentRequest.SubmitSignatures) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_SubmitIntentResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse, rhs: Code_Transaction_V2_SubmitIntentResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serverParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverParameters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.ServerParameters, rhs: Code_Transaction_V2_SubmitIntentResponse.ServerParameters) -> Bool {
    if lhs.serverParameters != rhs.serverParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.Success, rhs: Code_Transaction_V2_SubmitIntentResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Code_Transaction_V2_SubmitIntentResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SubmitIntentResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "error_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SubmitIntentResponse.Error, rhs: Code_Transaction_V2_SubmitIntentResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SubmitIntentResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
    1: .same(proto: "INVALID_INTENT"),
    2: .same(proto: "SIGNATURE_ERROR"),
    3: .same(proto: "STALE_STATE"),
  ]
}

extension Code_Transaction_V2_GetIntentMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetIntentMetadataRequest, rhs: Code_Transaction_V2_GetIntentMetadataRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetIntentMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetIntentMetadataResponse, rhs: Code_Transaction_V2_GetIntentMetadataResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetIntentMetadataResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Transaction_V2_GetLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "signature"),
    3: .standard(proto: "consumed_since"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumedSince) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._consumedSince {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetLimitsRequest, rhs: Code_Transaction_V2_GetLimitsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._consumedSince != rhs._consumedSince {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "send_limits_by_currency"),
    4: .standard(proto: "micro_payment_limits_by_currency"),
    5: .standard(proto: "buy_module_limits_by_currency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_SendLimit>.self, value: &self.sendLimitsByCurrency) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_MicroPaymentLimit>.self, value: &self.microPaymentLimitsByCurrency) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_BuyModuleLimit>.self, value: &self.buyModuleLimitsByCurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.sendLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_SendLimit>.self, value: self.sendLimitsByCurrency, fieldNumber: 2)
    }
    if !self.microPaymentLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_MicroPaymentLimit>.self, value: self.microPaymentLimitsByCurrency, fieldNumber: 4)
    }
    if !self.buyModuleLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Transaction_V2_BuyModuleLimit>.self, value: self.buyModuleLimitsByCurrency, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_GetLimitsResponse, rhs: Code_Transaction_V2_GetLimitsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.sendLimitsByCurrency != rhs.sendLimitsByCurrency {return false}
    if lhs.microPaymentLimitsByCurrency != rhs.microPaymentLimitsByCurrency {return false}
    if lhs.buyModuleLimitsByCurrency != rhs.buyModuleLimitsByCurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_GetLimitsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
  ]
}

extension Code_Transaction_V2_CanWithdrawToAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CanWithdrawToAccountRequest, rhs: Code_Transaction_V2_CanWithdrawToAccountRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CanWithdrawToAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "account_type"),
    1: .standard(proto: "is_valid_payment_destination"),
    3: .standard(proto: "requires_initialization"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValidPaymentDestination) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requiresInitialization) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isValidPaymentDestination != false {
      try visitor.visitSingularBoolField(value: self.isValidPaymentDestination, fieldNumber: 1)
    }
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 2)
    }
    if self.requiresInitialization != false {
      try visitor.visitSingularBoolField(value: self.requiresInitialization, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_CanWithdrawToAccountResponse, rhs: Code_Transaction_V2_CanWithdrawToAccountResponse) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs.isValidPaymentDestination != rhs.isValidPaymentDestination {return false}
    if lhs.requiresInitialization != rhs.requiresInitialization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_CanWithdrawToAccountResponse.AccountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "TokenAccount"),
    2: .same(proto: "OwnerAccount"),
  ]
}

extension Code_Transaction_V2_AirdropRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "airdrop_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.airdropType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.airdropType != .unknown {
      try visitor.visitSingularEnumField(value: self.airdropType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AirdropRequest, rhs: Code_Transaction_V2_AirdropRequest) -> Bool {
    if lhs.airdropType != rhs.airdropType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AirdropResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "exchange_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AirdropResponse, rhs: Code_Transaction_V2_AirdropResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AirdropResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "UNAVAILABLE"),
    2: .same(proto: "ALREADY_CLAIMED"),
  ]
}

extension Code_Transaction_V2_SwapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initiate"),
    2: .standard(proto: "submit_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SwapRequest.Initiate?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initiate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initiate(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SwapRequest.SubmitSignature?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initiate?: try {
      guard case .initiate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignature?: try {
      guard case .submitSignature(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest, rhs: Code_Transaction_V2_SwapRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapRequest.Initiate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapRequest.protoMessageName + ".Initiate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "swap_authority"),
    3: .same(proto: "limit"),
    4: .standard(proto: "wait_for_blockchain_status"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swapAuthority) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.waitForBlockchainStatus) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._swapAuthority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 3)
    }
    if self.waitForBlockchainStatus != false {
      try visitor.visitSingularBoolField(value: self.waitForBlockchainStatus, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest.Initiate, rhs: Code_Transaction_V2_SwapRequest.Initiate) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._swapAuthority != rhs._swapAuthority {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.waitForBlockchainStatus != rhs.waitForBlockchainStatus {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapRequest.SubmitSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapRequest.protoMessageName + ".SubmitSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapRequest.SubmitSignature, rhs: Code_Transaction_V2_SwapRequest.SubmitSignature) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_parameters"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_SwapResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_SwapResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_SwapResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse, rhs: Code_Transaction_V2_SwapResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payer"),
    2: .standard(proto: "recent_blockhash"),
    3: .standard(proto: "compute_unit_limit"),
    4: .standard(proto: "compute_unit_price"),
    5: .standard(proto: "swap_program"),
    6: .standard(proto: "swap_ixn_accounts"),
    7: .standard(proto: "swap_ixn_data"),
    8: .standard(proto: "max_to_send"),
    9: .standard(proto: "min_to_receive"),
    10: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recentBlockhash) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.computeUnitLimit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.computeUnitPrice) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._swapProgram) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.swapIxnAccounts) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.swapIxnData) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.maxToSend) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.minToReceive) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recentBlockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.computeUnitLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.computeUnitLimit, fieldNumber: 3)
    }
    if self.computeUnitPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeUnitPrice, fieldNumber: 4)
    }
    try { if let v = self._swapProgram {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.swapIxnAccounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.swapIxnAccounts, fieldNumber: 6)
    }
    if !self.swapIxnData.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapIxnData, fieldNumber: 7)
    }
    if self.maxToSend != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxToSend, fieldNumber: 8)
    }
    if self.minToReceive != 0 {
      try visitor.visitSingularUInt64Field(value: self.minToReceive, fieldNumber: 9)
    }
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.ServerParameters, rhs: Code_Transaction_V2_SwapResponse.ServerParameters) -> Bool {
    if lhs._payer != rhs._payer {return false}
    if lhs._recentBlockhash != rhs._recentBlockhash {return false}
    if lhs.computeUnitLimit != rhs.computeUnitLimit {return false}
    if lhs.computeUnitPrice != rhs.computeUnitPrice {return false}
    if lhs._swapProgram != rhs._swapProgram {return false}
    if lhs.swapIxnAccounts != rhs.swapIxnAccounts {return false}
    if lhs.swapIxnData != rhs.swapIxnData {return false}
    if lhs.maxToSend != rhs.maxToSend {return false}
    if lhs.minToReceive != rhs.minToReceive {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .swapSubmitted {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.Success, rhs: Code_Transaction_V2_SwapResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SWAP_SUBMITTED"),
    1: .same(proto: "SWAP_FINALIZED"),
  ]
}

extension Code_Transaction_V2_SwapResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Code_Transaction_V2_SwapResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "error_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SwapResponse.Error, rhs: Code_Transaction_V2_SwapResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SwapResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DENIED"),
    2: .same(proto: "SIGNATURE_ERROR"),
    3: .same(proto: "INVALID_SWAP"),
    4: .same(proto: "SWAP_FAILED"),
  ]
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareFiatOnrampPurchaseAttemptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "purchase_amount"),
    3: .same(proto: "nonce"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._purchaseAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._purchaseAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest, rhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._purchaseAmount != rhs._purchaseAmount {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareFiatOnrampPurchaseAttemptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse, rhs: Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeclareFiatOnrampPurchaseAttemptResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_OWNER"),
    2: .same(proto: "UNSUPPORTED_CURRENCY"),
    3: .same(proto: "AMOUNT_EXCEEDS_MAXIMUM"),
  ]
}

extension Code_Transaction_V2_VoidGiftCardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoidGiftCardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "gift_card_vault"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._giftCardVault) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._giftCardVault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_VoidGiftCardRequest, rhs: Code_Transaction_V2_VoidGiftCardRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._giftCardVault != rhs._giftCardVault {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_VoidGiftCardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoidGiftCardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_VoidGiftCardResponse, rhs: Code_Transaction_V2_VoidGiftCardResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_VoidGiftCardResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "DENIED"),
    2: .same(proto: "CLAIMED_BY_OTHER_USER"),
    3: .same(proto: "NOT_FOUND"),
  ]
}

extension Code_Transaction_V2_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_accounts"),
    6: .standard(proto: "send_public_payment"),
    7: .standard(proto: "receive_payments_publicly"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_OpenAccountsMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccounts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccounts(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_SendPublicPaymentMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sendPublicPayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sendPublicPayment(v)
        }
      }()
      case 7: try {
        var v: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .receivePaymentsPublicly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .receivePaymentsPublicly(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .openAccounts?: try {
      guard case .openAccounts(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendPublicPayment?: try {
      guard case .sendPublicPayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .receivePaymentsPublicly?: try {
      guard case .receivePaymentsPublicly(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Metadata, rhs: Code_Transaction_V2_Metadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountsMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountsMetadata, rhs: Code_Transaction_V2_OpenAccountsMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SendPublicPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPublicPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "source"),
    1: .same(proto: "destination"),
    2: .standard(proto: "exchange_data"),
    3: .standard(proto: "is_withdrawal"),
    5: .standard(proto: "is_remote_send"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isWithdrawal) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isWithdrawal != false {
      try visitor.visitSingularBoolField(value: self.isWithdrawal, fieldNumber: 3)
    }
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SendPublicPaymentMetadata, rhs: Code_Transaction_V2_SendPublicPaymentMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.isWithdrawal != rhs.isWithdrawal {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ReceivePaymentsPubliclyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivePaymentsPubliclyMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "quarks"),
    3: .standard(proto: "is_remote_send"),
    5: .standard(proto: "exchange_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 2)
    }
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 3)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata, rhs: Code_Transaction_V2_ReceivePaymentsPubliclyMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "open_account"),
    5: .standard(proto: "no_privacy_transfer"),
    6: .standard(proto: "no_privacy_withdraw"),
    10: .standard(proto: "fee_payment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Code_Transaction_V2_OpenAccountAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 5: try {
        var v: Code_Transaction_V2_NoPrivacyTransferAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_NoPrivacyWithdrawAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 10: try {
        var v: Code_Transaction_V2_FeePaymentAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Action, rhs: Code_Transaction_V2_Action) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "index"),
    4: .same(proto: "authority"),
    5: .same(proto: "token"),
    6: .standard(proto: "authority_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._authoritySignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 3)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._authoritySignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountAction, rhs: Code_Transaction_V2_OpenAccountAction) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.index != rhs.index {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._token != rhs._token {return false}
    if lhs._authoritySignature != rhs._authoritySignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyTransferAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyTransferAction, rhs: Code_Transaction_V2_NoPrivacyTransferAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyWithdrawAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
    4: .same(proto: "amount"),
    5: .standard(proto: "should_close"),
    6: .standard(proto: "is_auto_return"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.shouldClose) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isAutoReturn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if self.shouldClose != false {
      try visitor.visitSingularBoolField(value: self.shouldClose, fieldNumber: 5)
    }
    if self.isAutoReturn != false {
      try visitor.visitSingularBoolField(value: self.isAutoReturn, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyWithdrawAction, rhs: Code_Transaction_V2_NoPrivacyWithdrawAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.shouldClose != rhs.shouldClose {return false}
    if lhs.isAutoReturn != rhs.isAutoReturn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "type"),
    1: .same(proto: "authority"),
    2: .same(proto: "source"),
    3: .same(proto: "amount"),
    5: .same(proto: "destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.type != .code {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_FeePaymentAction, rhs: Code_Transaction_V2_FeePaymentAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentAction.FeeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODE"),
    1: .same(proto: "THIRD_PARTY"),
  ]
}

extension Code_Transaction_V2_ServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_id"),
    2: .same(proto: "nonces"),
    3: .standard(proto: "open_account"),
    6: .standard(proto: "no_privacy_transfer"),
    7: .standard(proto: "no_privacy_withdraw"),
    11: .standard(proto: "fee_payment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nonces) }()
      case 3: try {
        var v: Code_Transaction_V2_OpenAccountServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 6: try {
        var v: Code_Transaction_V2_NoPrivacyTransferServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 7: try {
        var v: Code_Transaction_V2_NoPrivacyWithdrawServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 11: try {
        var v: Code_Transaction_V2_FeePaymentServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    if !self.nonces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonces, fieldNumber: 2)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ServerParameter, rhs: Code_Transaction_V2_ServerParameter) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.nonces != rhs.nonces {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoncedTransactionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoncedTransactionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "blockhash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockhash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoncedTransactionMetadata, rhs: Code_Transaction_V2_NoncedTransactionMetadata) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._blockhash != rhs._blockhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_OpenAccountServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_OpenAccountServerParameter, rhs: Code_Transaction_V2_OpenAccountServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyTransferServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyTransferServerParameter, rhs: Code_Transaction_V2_NoPrivacyTransferServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_NoPrivacyWithdrawServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_NoPrivacyWithdrawServerParameter, rhs: Code_Transaction_V2_NoPrivacyWithdrawServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_FeePaymentServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentServerParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._codeDestination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._codeDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_FeePaymentServerParameter, rhs: Code_Transaction_V2_FeePaymentServerParameter) -> Bool {
    if lhs._codeDestination != rhs._codeDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reason_string"),
    2: .standard(proto: "invalid_signature"),
    3: .same(proto: "denied"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Code_Transaction_V2_ReasonStringErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reasonString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reasonString(v)
        }
      }()
      case 2: try {
        var v: Code_Transaction_V2_InvalidSignatureErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .invalidSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .invalidSignature(v)
        }
      }()
      case 3: try {
        var v: Code_Transaction_V2_DeniedErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .denied(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .denied(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .reasonString?: try {
      guard case .reasonString(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .invalidSignature?: try {
      guard case .invalidSignature(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .denied?: try {
      guard case .denied(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ErrorDetails, rhs: Code_Transaction_V2_ErrorDetails) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ReasonStringErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReasonStringErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ReasonStringErrorDetails, rhs: Code_Transaction_V2_ReasonStringErrorDetails) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_InvalidSignatureErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvalidSignatureErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_id"),
    2: .standard(proto: "expected_transaction"),
    4: .standard(proto: "expected_vixn_hash"),
    3: .standard(proto: "provided_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try {
        var v: Code_Common_V1_Transaction?
        var hadOneofValue = false
        if let current = self.expectedBlob {
          hadOneofValue = true
          if case .expectedTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedBlob = .expectedTransaction(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._providedSignature) }()
      case 4: try {
        var v: Code_Common_V1_Hash?
        var hadOneofValue = false
        if let current = self.expectedBlob {
          hadOneofValue = true
          if case .expectedVixnHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedBlob = .expectedVixnHash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    try { if case .expectedTransaction(let v)? = self.expectedBlob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._providedSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .expectedVixnHash(let v)? = self.expectedBlob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_InvalidSignatureErrorDetails, rhs: Code_Transaction_V2_InvalidSignatureErrorDetails) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.expectedBlob != rhs.expectedBlob {return false}
    if lhs._providedSignature != rhs._providedSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeniedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeniedErrorDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_DeniedErrorDetails, rhs: Code_Transaction_V2_DeniedErrorDetails) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_DeniedErrorDetails.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
  ]
}

extension Code_Transaction_V2_ExchangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "exchange_rate"),
    3: .standard(proto: "native_amount"),
    4: .same(proto: "quarks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.exchangeRate) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.exchangeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.exchangeRate, fieldNumber: 2)
    }
    if self.nativeAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 3)
    }
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ExchangeData, rhs: Code_Transaction_V2_ExchangeData) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_ExchangeDataWithoutRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataWithoutRate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "native_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.nativeAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_ExchangeDataWithoutRate, rhs: Code_Transaction_V2_ExchangeDataWithoutRate) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_AdditionalFeePayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdditionalFeePayment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "fee_bps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.feeBps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.feeBps != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeBps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_AdditionalFeePayment, rhs: Code_Transaction_V2_AdditionalFeePayment) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.feeBps != rhs.feeBps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_SendLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_transaction"),
    2: .standard(proto: "max_per_transaction"),
    3: .standard(proto: "max_per_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.nextTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxPerDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.nextTransaction, fieldNumber: 1)
    }
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 2)
    }
    if self.maxPerDay != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerDay, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_SendLimit, rhs: Code_Transaction_V2_SendLimit) -> Bool {
    if lhs.nextTransaction != rhs.nextTransaction {return false}
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.maxPerDay != rhs.maxPerDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_MicroPaymentLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroPaymentLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_per_transaction"),
    2: .standard(proto: "min_per_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.minPerTransaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 1)
    }
    if self.minPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.minPerTransaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_MicroPaymentLimit, rhs: Code_Transaction_V2_MicroPaymentLimit) -> Bool {
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.minPerTransaction != rhs.minPerTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_BuyModuleLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyModuleLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_per_transaction"),
    2: .standard(proto: "max_per_transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.minPerTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.minPerTransaction, fieldNumber: 1)
    }
    if self.maxPerTransaction != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_BuyModuleLimit, rhs: Code_Transaction_V2_BuyModuleLimit) -> Bool {
    if lhs.minPerTransaction != rhs.minPerTransaction {return false}
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Transaction_V2_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Transaction_V2_Cursor, rhs: Code_Transaction_V2_Cursor) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
