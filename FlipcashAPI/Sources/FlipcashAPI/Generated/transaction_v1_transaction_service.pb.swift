// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction/v1/transaction_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ocp_Transaction_V1_AirdropType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// Reward for onboarding another user
  case onboardingBonus // = 1

  /// Airdrop for getting a user started with first crypto balance
  case welcomeBonus // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .onboardingBonus
    case 2: self = .welcomeBonus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .onboardingBonus: return 1
    case .welcomeBonus: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ocp_Transaction_V1_AirdropType] = [
    .unknown,
    .onboardingBonus,
    .welcomeBonus,
  ]

}

public enum Ocp_Transaction_V1_FundingSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case submitIntent // = 1
  case externalWallet // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .submitIntent
    case 2: self = .externalWallet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .submitIntent: return 1
    case .externalWallet: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ocp_Transaction_V1_FundingSource] = [
    .unknown,
    .submitIntent,
    .externalWallet,
  ]

}

public struct Ocp_Transaction_V1_SubmitIntentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Ocp_Transaction_V1_SubmitIntentRequest.OneOf_Request? = nil

  public var submitActions: Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions {
    get {
      if case .submitActions(let v)? = request {return v}
      return Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions()
    }
    set {request = .submitActions(newValue)}
  }

  public var submitSignatures: Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures {
    get {
      if case .submitSignatures(let v)? = request {return v}
      return Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures()
    }
    set {request = .submitSignatures(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case submitActions(Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions)
    case submitSignatures(Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures)

  }

  public struct SubmitActions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The globally unique client generated intent ID. Use the original intent
    /// ID when operating on actions that mutate the intent.
    public var id: Ocp_Common_V1_IntentId {
      get {return _id ?? Ocp_Common_V1_IntentId()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// The verified owner account public key
    public var owner: Ocp_Common_V1_SolanaAccountId {
      get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// Additional metadata that describes the high-level intention
    public var metadata: Ocp_Transaction_V1_Metadata {
      get {return _metadata ?? Ocp_Transaction_V1_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    /// The set of all ordered actions required to fulfill the intent
    public var actions: [Ocp_Transaction_V1_Action] = []

    /// The signature is of serialize(SubmitActions) without this field set using the
    /// private key of the owner account. This provides an authentication mechanism
    /// to the RPC.
    public var signature: Ocp_Common_V1_Signature {
      get {return _signature ?? Ocp_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Ocp_Common_V1_IntentId? = nil
    fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
    fileprivate var _metadata: Ocp_Transaction_V1_Metadata? = nil
    fileprivate var _signature: Ocp_Common_V1_Signature? = nil
  }

  public struct SubmitSignatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all signatures for each transaction or virtual instruction requiring
    /// signature from the authority accounts.
    ///
    /// The signature for a transaction is for the marshalled transaction.
    /// The signature for a virtual instruction is the hash of the marshalled instruction.
    public var signatures: [Ocp_Common_V1_Signature] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Ocp_Transaction_V1_SubmitIntentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Ocp_Transaction_V1_SubmitIntentResponse.OneOf_Response? = nil

  public var serverParameters: Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Ocp_Transaction_V1_SubmitIntentResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Ocp_Transaction_V1_SubmitIntentResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Ocp_Transaction_V1_SubmitIntentResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Ocp_Transaction_V1_SubmitIntentResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case serverParameters(Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters)
    case success(Ocp_Transaction_V1_SubmitIntentResponse.Success)
    case error(Ocp_Transaction_V1_SubmitIntentResponse.Error)

  }

  public struct ServerParameters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of all server paremeters required to fill missing transaction
    /// or virtual instruction details. Server guarantees to provide a message
    /// for each client action in an order consistent with the received action
    /// list. 
    public var serverParameters: [Ocp_Transaction_V1_ServerParameter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Ocp_Transaction_V1_SubmitIntentResponse.Success.Code = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// The intent was successfully created and is now scheduled.
      case ok // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .ok
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ok
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .ok: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Ocp_Transaction_V1_SubmitIntentResponse.Success.Code] = [
        .ok,
      ]

    }

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Ocp_Transaction_V1_SubmitIntentResponse.Error.Code = .denied

    public var errorDetails: [Ocp_Transaction_V1_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// The intent is invalid.
      case invalidIntent // = 1

      /// There is an issue with provided signatures.
      case signatureError // = 2

      /// Server detected client has stale state.
      case staleState // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 1: self = .invalidIntent
        case 2: self = .signatureError
        case 3: self = .staleState
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .invalidIntent: return 1
        case .signatureError: return 2
        case .staleState: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Ocp_Transaction_V1_SubmitIntentResponse.Error.Code] = [
        .denied,
        .invalidIntent,
        .signatureError,
        .staleState,
      ]

    }

    public init() {}
  }

  public init() {}
}

public struct Ocp_Transaction_V1_GetIntentMetadataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The intent ID to query
  public var intentID: Ocp_Common_V1_IntentId {
    get {return _intentID ?? Ocp_Common_V1_IntentId()}
    set {_intentID = newValue}
  }
  /// Returns true if `intentID` has been explicitly set.
  public var hasIntentID: Bool {return self._intentID != nil}
  /// Clears the value of `intentID`. Subsequent reads from it will return its default value.
  public mutating func clearIntentID() {self._intentID = nil}

  /// The verified owner account public key when not signing with the rendezvous
  /// key. Only owner accounts involved in the intent can access the metadata.
  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetIntentStatusRequest) without this field set
  /// using the private key of the rendezvous or owner account. This provides an
  /// authentication mechanism to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _intentID: Ocp_Common_V1_IntentId? = nil
  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_GetIntentMetadataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_GetIntentMetadataResponse.Result = .ok

  public var metadata: Ocp_Transaction_V1_Metadata {
    get {return _metadata ?? Ocp_Transaction_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_GetIntentMetadataResponse.Result] = [
      .ok,
      .notFound,
    ]

  }

  public init() {}

  fileprivate var _metadata: Ocp_Transaction_V1_Metadata? = nil
}

public struct Ocp_Transaction_V1_GetLimitsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account whose limits will be calculated. Any other owner accounts
  /// linked with the same identity of the owner will also be applied.
  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetLimitsRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// All transactions starting at this time will be incorporated into the consumed
  /// limit calculation. Clients should set this to the start of the current day in
  /// the client's current time zone (because server has no knowledge of this atm).
  public var consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _consumedSince ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_consumedSince = newValue}
  }
  /// Returns true if `consumedSince` has been explicitly set.
  public var hasConsumedSince: Bool {return self._consumedSince != nil}
  /// Clears the value of `consumedSince`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedSince() {self._consumedSince = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
  fileprivate var _consumedSince: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocp_Transaction_V1_GetLimitsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_GetLimitsResponse.Result = .ok

  /// Send limits keyed by currency
  public var sendLimitsByCurrency: Dictionary<String,Ocp_Transaction_V1_SendLimit> = [:]

  /// The amount of USD transacted since the consumption timestamp
  public var usdTransacted: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_GetLimitsResponse.Result] = [
      .ok,
    ]

  }

  public init() {}
}

public struct Ocp_Transaction_V1_CanWithdrawToAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination account attempted to be withdrawn to. Can be an owner or
  /// token account.
  public var account: Ocp_Common_V1_SolanaAccountId {
    get {return _account ?? Ocp_Common_V1_SolanaAccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// The mint that the withdraw will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Transaction_V1_CanWithdrawToAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server-controlled flag to indicate if the account can be withdrawn to.
  /// There are several reasons server may deny it, including:
  ///  - Wrong type of Code account
  ///  - Unsupported external account type (eg. token account but of the wrong mint)
  /// This is guaranteed to be false when account_type = Unknown.
  public var isValidPaymentDestination: Bool = false

  /// Metadata so the client knows how to withdraw to the account. Server cannot
  /// provide precalculated addresses in this response to maintain non-custodial
  /// status.
  public var accountType: Ocp_Transaction_V1_CanWithdrawToAccountResponse.AccountType = .unknown

  /// ATA requires initialization before the withdrawal can occur. Server may not
  /// subsidize the account creation, so a fee may be required.
  public var requiresInitialization: Bool = false

  /// The CREATE_ON_SEND_WITHDRAWAL fee, in USD, that must be paid in order to
  /// submit a withdrawal to subsidize the creation of the account at time of
  /// send. The user must explicitly agree to this fee amount before submitting
  /// the intent.
  ///
  /// This can be set when requires_initialization = true if server decides to
  /// not subsidize the token account creation.
  ///
  /// Note: The fee is always paid in the target mint.
  public var feeAmount: Ocp_Transaction_V1_ExchangeDataWithoutRate {
    get {return _feeAmount ?? Ocp_Transaction_V1_ExchangeDataWithoutRate()}
    set {_feeAmount = newValue}
  }
  /// Returns true if `feeAmount` has been explicitly set.
  public var hasFeeAmount: Bool {return self._feeAmount != nil}
  /// Clears the value of `feeAmount`. Subsequent reads from it will return its default value.
  public mutating func clearFeeAmount() {self._feeAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AccountType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Server cannot determine
    case unknown // = 0

    /// Client uses the address as is in SubmitIntent
    case tokenAccount // = 1

    /// Client locally derives the ATA to use in SubmitIntent
    case ownerAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tokenAccount
      case 2: self = .ownerAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tokenAccount: return 1
      case .ownerAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_CanWithdrawToAccountResponse.AccountType] = [
      .unknown,
      .tokenAccount,
      .ownerAccount,
    ]

  }

  public init() {}

  fileprivate var _feeAmount: Ocp_Transaction_V1_ExchangeDataWithoutRate? = nil
}

public struct Ocp_Transaction_V1_AirdropRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of airdrop to claim
  public var airdropType: Ocp_Transaction_V1_AirdropType = .unknown

  /// The owner account to airdrop core mint tokens to
  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(AirdropRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_AirdropResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_AirdropResponse.Result = .ok

  /// Exchange data for the amount of core mint tokens airdropped when successful
  public var exchangeData: Ocp_Transaction_V1_ExchangeData {
    get {return _exchangeData ?? Ocp_Transaction_V1_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0

    /// Airdrops are unavailable
    case unavailable // = 1

    /// The airdrop has already been claimed by the owner
    case alreadyClaimed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unavailable
      case 2: self = .alreadyClaimed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unavailable: return 1
      case .alreadyClaimed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_AirdropResponse.Result] = [
      .ok,
      .unavailable,
      .alreadyClaimed,
    ]

  }

  public init() {}

  fileprivate var _exchangeData: Ocp_Transaction_V1_ExchangeData? = nil
}

public struct Ocp_Transaction_V1_VoidGiftCardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account that issued the gift card account
  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The vault of the gift card account to void
  public var giftCardVault: Ocp_Common_V1_SolanaAccountId {
    get {return _giftCardVault ?? Ocp_Common_V1_SolanaAccountId()}
    set {_giftCardVault = newValue}
  }
  /// Returns true if `giftCardVault` has been explicitly set.
  public var hasGiftCardVault: Bool {return self._giftCardVault != nil}
  /// Clears the value of `giftCardVault`. Subsequent reads from it will return its default value.
  public mutating func clearGiftCardVault() {self._giftCardVault = nil}

  /// The signature is of serialize(VoidGiftCardRequest) without this field set using
  /// the private key of the owner account. This provides an authentication mechanism
  /// to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _giftCardVault: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_VoidGiftCardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_VoidGiftCardResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0

    /// The owner account didn't issue the gift card accoun
    case denied // = 1

    /// A different owner account than the issuer claimed the gift card
    case claimedByOtherUser // = 2

    /// The gift card doesn't exist
    case notFound // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .denied
      case 2: self = .claimedByOtherUser
      case 3: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .denied: return 1
      case .claimedByOtherUser: return 2
      case .notFound: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_VoidGiftCardResponse.Result] = [
      .ok,
      .denied,
      .claimedByOtherUser,
      .notFound,
    ]

  }

  public init() {}
}

public struct Ocp_Transaction_V1_StatefulSwapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Ocp_Transaction_V1_StatefulSwapRequest.OneOf_Request? = nil

  public var initiate: Ocp_Transaction_V1_StatefulSwapRequest.Initiate {
    get {
      if case .initiate(let v)? = request {return v}
      return Ocp_Transaction_V1_StatefulSwapRequest.Initiate()
    }
    set {request = .initiate(newValue)}
  }

  public var submitSignatures: Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures {
    get {
      if case .submitSignatures(let v)? = request {return v}
      return Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures()
    }
    set {request = .submitSignatures(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case initiate(Ocp_Transaction_V1_StatefulSwapRequest.Initiate)
    case submitSignatures(Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures)

  }

  public struct Initiate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.OneOf_Kind? = nil

    public var currencyCreator: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator {
      get {
        if case .currencyCreator(let v)? = kind {return v}
        return Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator()
      }
      set {kind = .currencyCreator(newValue)}
    }

    /// The owner account starting the swap
    public var owner: Ocp_Common_V1_SolanaAccountId {
      get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    /// The user authority account that will sign to authorize the swap.
    ///
    /// For Currency Creator program buy/sell flows, this should be a random one-time use account.
    public var swapAuthority: Ocp_Common_V1_SolanaAccountId {
      get {return _swapAuthority ?? Ocp_Common_V1_SolanaAccountId()}
      set {_swapAuthority = newValue}
    }
    /// Returns true if `swapAuthority` has been explicitly set.
    public var hasSwapAuthority: Bool {return self._swapAuthority != nil}
    /// Clears the value of `swapAuthority`. Subsequent reads from it will return its default value.
    public mutating func clearSwapAuthority() {self._swapAuthority = nil}

    /// The signature of serialize(VerifiedSwapMetadata) for the swap being initiated.
    public var proofSignature: Ocp_Common_V1_Signature {
      get {return _proofSignature ?? Ocp_Common_V1_Signature()}
      set {_proofSignature = newValue}
    }
    /// Returns true if `proofSignature` has been explicitly set.
    public var hasProofSignature: Bool {return self._proofSignature != nil}
    /// Clears the value of `proofSignature`. Subsequent reads from it will return its default value.
    public mutating func clearProofSignature() {self._proofSignature = nil}

    /// The signature is of serialize(StatefulSwapRequest.Initiate) without this field
    /// set using the private key of the owner account. This provides an authentication
    /// mechanism to the RPC.
    public var signature: Ocp_Common_V1_Signature {
      get {return _signature ?? Ocp_Common_V1_Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case currencyCreator(Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator)

    }

    /// Server parameters for starting swaps against the Currency Creator program
    public struct CurrencyCreator: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The unique ID for this swap randomly generated on client
      public var id: Ocp_Common_V1_SwapId {
        get {return _id ?? Ocp_Common_V1_SwapId()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      public var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      public mutating func clearID() {self._id = nil}

      /// The source mint that will be swapped from
      public var fromMint: Ocp_Common_V1_SolanaAccountId {
        get {return _fromMint ?? Ocp_Common_V1_SolanaAccountId()}
        set {_fromMint = newValue}
      }
      /// Returns true if `fromMint` has been explicitly set.
      public var hasFromMint: Bool {return self._fromMint != nil}
      /// Clears the value of `fromMint`. Subsequent reads from it will return its default value.
      public mutating func clearFromMint() {self._fromMint = nil}

      /// The destination mint that will be swapped to
      public var toMint: Ocp_Common_V1_SolanaAccountId {
        get {return _toMint ?? Ocp_Common_V1_SolanaAccountId()}
        set {_toMint = newValue}
      }
      /// Returns true if `toMint` has been explicitly set.
      public var hasToMint: Bool {return self._toMint != nil}
      /// Clears the value of `toMint`. Subsequent reads from it will return its default value.
      public mutating func clearToMint() {self._toMint = nil}

      /// The amount to swap from the source mint in quarks.
      public var amount: UInt64 = 0

      /// Where "amount" of "from_mint" will be sent from to the VM swap PDA
      public var fundingSource: Ocp_Transaction_V1_FundingSource = .unknown

      /// The ID of the "transaction" to lookup funding state.
      ///
      /// For FUNDING_SOURCE_SUBMIT_INTENT, this value is the base58 encoded intent ID.
      /// For FUNDING_SOURCE_EXTERNAL_WALLET, this value is the base58 encoded transaction signature.
      public var fundingID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _id: Ocp_Common_V1_SwapId? = nil
      fileprivate var _fromMint: Ocp_Common_V1_SolanaAccountId? = nil
      fileprivate var _toMint: Ocp_Common_V1_SolanaAccountId? = nil
    }

    public init() {}

    fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
    fileprivate var _swapAuthority: Ocp_Common_V1_SolanaAccountId? = nil
    fileprivate var _proofSignature: Ocp_Common_V1_Signature? = nil
    fileprivate var _signature: Ocp_Common_V1_Signature? = nil
  }

  public struct SubmitSignatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The signatures for the locally constructed swap transaction
    public var transactionSignatures: [Ocp_Common_V1_Signature] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Ocp_Transaction_V1_StatefulSwapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Ocp_Transaction_V1_StatefulSwapResponse.OneOf_Response? = nil

  public var serverParameters: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters {
    get {
      if case .serverParameters(let v)? = response {return v}
      return Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters()
    }
    set {response = .serverParameters(newValue)}
  }

  public var success: Ocp_Transaction_V1_StatefulSwapResponse.Success {
    get {
      if case .success(let v)? = response {return v}
      return Ocp_Transaction_V1_StatefulSwapResponse.Success()
    }
    set {response = .success(newValue)}
  }

  public var error: Ocp_Transaction_V1_StatefulSwapResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Ocp_Transaction_V1_StatefulSwapResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case serverParameters(Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters)
    case success(Ocp_Transaction_V1_StatefulSwapResponse.Success)
    case error(Ocp_Transaction_V1_StatefulSwapResponse.Error)

  }

  public struct ServerParameters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.OneOf_Kind? = nil

    public var currencyCreator: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator {
      get {
        if case .currencyCreator(let v)? = kind {return v}
        return Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator()
      }
      set {kind = .currencyCreator(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case currencyCreator(Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator)

    }

    /// Server parameters when executing stateful buy/sell flows against the
    /// Currency Creator program
    ///
    /// Supported Solana transaction version: v0
    ///
    /// Instruction formats:
    ///
    /// Buy Tokens (Core Mint -> Launchpad Currency Mint):
    ///  1. System::AdvanceNonce
    ///  2. [Optional] ComputeBudget::SetComputeUnitLimit
    ///  3. [Optional] ComputeBudget::SetComputeUnitPrice
    ///  4. [Optional] Memo::Memo
    ///  5. AssociatedTokenAccount::CreateIdempotent (open Core Mint temporary account)
    ///  6. VM::TransferForSwap (Core Mint VM swap ATA -> Core Mint temporary account)
    ///  6. CurrencyCreator::BuyAndDepositIntoVm (bounded buy depositing to_mint tokens into the to_mint VM)
    ///  8. Token::CloseAccount (closes Core Mint temporary account)
    ///  9. VM::CloseSwapAccountIfEmpty (closes Core Mint VM swap ATA if empty)
    ///
    /// Sell Tokens (Launchpad Currency Mint -> Core Mint):
    ///  1. System::AdvanceNonce
    ///  2. [Optional] ComputeBudget::SetComputeUnitLimit
    ///  3. [Optional] ComputeBudget::SetComputeUnitPrice
    ///  4. [Optional] Memo::Memo
    ///  5. AssociatedTokenAccount::CreateIdempotent (open from_mint temporary account)
    ///  6. VM::TransferForSwap (from_mint VM swap ATA -> from_mint temporary account)
    ///  7. CurrencyCreator::SellAndDepositIntoVm (bounded sell depositing Core Mint into the Core Mint VM)
    ///  8. Token::CloseAccount (closes from_mint temporary account)
    ///  9. VM::CloseSwapAccountIfEmpty (closes from_mint swap PDA/ATA if empty)
    ///
    /// Swap Tokens (Launchpad Currency Mint -> Launchpad Currency Mint):
    ///  1.  System::AdvanceNonce
    ///  2.  [Optional] ComputeBudget::SetComputeUnitLimit
    ///  3.  [Optional] ComputeBudget::SetComputeUnitPrice
    ///  4.  [Optional] Memo::Memo
    ///  5.  AssociatedTokenAccount::CreateIdempotent (open Core Mint temporary account)
    ///  6.  AssociatedTokenAccount::CreateIdempotent (open from_mint temporary account)
    ///  7.  VM::TransferForSwap (from_mint VM swap ATA -> from_mint temporary account)
    ///  8.  CurrencyCreator::SellTokens (bounded sell transferring Core Mint into temporary account)
    ///  9.  CurrencyCreator::BuyAndDepositIntoVm (unlimited buy depositing to_mint tokens into the to_mint VM)
    ///  10. Token::CloseAccount (closes Core Mint temporary account)
    ///  11. Token::CloseAccount (closes from_mint temporary account)
    ///  12. VM::CloseSwapAccountIfEmpty (closes from_mint VM swap ATA if empty)
    public struct CurrencyCreator: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Subisdizer account that will be paying for the swap
      public var payer: Ocp_Common_V1_SolanaAccountId {
        get {return _payer ?? Ocp_Common_V1_SolanaAccountId()}
        set {_payer = newValue}
      }
      /// Returns true if `payer` has been explicitly set.
      public var hasPayer: Bool {return self._payer != nil}
      /// Clears the value of `payer`. Subsequent reads from it will return its default value.
      public mutating func clearPayer() {self._payer = nil}

      /// The nonce that is reserved for use in the swap transaction
      public var nonce: Ocp_Common_V1_SolanaAccountId {
        get {return _nonce ?? Ocp_Common_V1_SolanaAccountId()}
        set {_nonce = newValue}
      }
      /// Returns true if `nonce` has been explicitly set.
      public var hasNonce: Bool {return self._nonce != nil}
      /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
      public mutating func clearNonce() {self._nonce = nil}

      /// The blockhash that is reserved for use in the swap transaction
      public var blockhash: Ocp_Common_V1_Blockhash {
        get {return _blockhash ?? Ocp_Common_V1_Blockhash()}
        set {_blockhash = newValue}
      }
      /// Returns true if `blockhash` has been explicitly set.
      public var hasBlockhash: Bool {return self._blockhash != nil}
      /// Clears the value of `blockhash`. Subsequent reads from it will return its default value.
      public mutating func clearBlockhash() {self._blockhash = nil}

      /// ALTs that should be used when constructing the versioned transaction
      public var alts: [Ocp_Common_V1_SolanaAddressLookupTable] = []

      /// Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
      /// instruction. If the value is 0, then the instruction can be omitted.
      public var computeUnitLimit: UInt32 = 0

      /// Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
      /// instruction. If the value is 0, then the instruction can be omitted.
      public var computeUnitPrice: UInt64 = 0

      /// Value provided into the Memo::Memo instruction. If the value length is 0,
      /// then the instruction can be omitted.
      public var memoValue: String = String()

      /// The memory account where the destination virtual Timelock account lives
      public var memoryAccount: Ocp_Common_V1_SolanaAccountId {
        get {return _memoryAccount ?? Ocp_Common_V1_SolanaAccountId()}
        set {_memoryAccount = newValue}
      }
      /// Returns true if `memoryAccount` has been explicitly set.
      public var hasMemoryAccount: Bool {return self._memoryAccount != nil}
      /// Clears the value of `memoryAccount`. Subsequent reads from it will return its default value.
      public mutating func clearMemoryAccount() {self._memoryAccount = nil}

      /// The memory index where the destination virtual Timelock account lives
      public var memoryIndex: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _payer: Ocp_Common_V1_SolanaAccountId? = nil
      fileprivate var _nonce: Ocp_Common_V1_SolanaAccountId? = nil
      fileprivate var _blockhash: Ocp_Common_V1_Blockhash? = nil
      fileprivate var _memoryAccount: Ocp_Common_V1_SolanaAccountId? = nil
    }

    public init() {}
  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Ocp_Transaction_V1_StatefulSwapResponse.Success.Code = .ok

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case ok // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .ok
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ok
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .ok: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Ocp_Transaction_V1_StatefulSwapResponse.Success.Code] = [
        .ok,
      ]

    }

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Ocp_Transaction_V1_StatefulSwapResponse.Error.Code = .denied

    public var errorDetails: [Ocp_Transaction_V1_ErrorDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Denied by a guard (spam, money laundering, etc)
      case denied // = 0

      /// There is an issue with the provided proof or transaction signatures
      case signatureError // = 1

      /// The swap metadata failed server-side validation
      case invalidSwap // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .denied
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .denied
        case 1: self = .signatureError
        case 2: self = .invalidSwap
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .denied: return 0
        case .signatureError: return 1
        case .invalidSwap: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Ocp_Transaction_V1_StatefulSwapResponse.Error.Code] = [
        .denied,
        .signatureError,
        .invalidSwap,
      ]

    }

    public init() {}
  }

  public init() {}
}

public struct Ocp_Transaction_V1_GetSwapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Ocp_Common_V1_SwapId {
    get {return _id ?? Ocp_Common_V1_SwapId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetSwapRequest) without this field set using the
  /// private key of the owner account. This provides an authentication mechanism
  /// to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Ocp_Common_V1_SwapId? = nil
  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_GetSwapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_GetSwapResponse.Result = .ok

  public var swap: Ocp_Transaction_V1_SwapMetadata {
    get {return _swap ?? Ocp_Transaction_V1_SwapMetadata()}
    set {_swap = newValue}
  }
  /// Returns true if `swap` has been explicitly set.
  public var hasSwap: Bool {return self._swap != nil}
  /// Clears the value of `swap`. Subsequent reads from it will return its default value.
  public mutating func clearSwap() {self._swap = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case denied // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .denied: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_GetSwapResponse.Result] = [
      .ok,
      .notFound,
      .denied,
    ]

  }

  public init() {}

  fileprivate var _swap: Ocp_Transaction_V1_SwapMetadata? = nil
}

public struct Ocp_Transaction_V1_GetPendingSwapsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetPendingSwapsRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_GetPendingSwapsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Transaction_V1_GetPendingSwapsResponse.Result = .ok

  public var swaps: [Ocp_Transaction_V1_SwapMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_GetPendingSwapsResponse.Result] = [
      .ok,
      .notFound,
    ]

  }

  public init() {}
}

/// Metadata describes the high-level details of an intent
public struct Ocp_Transaction_V1_Metadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocp_Transaction_V1_Metadata.OneOf_Type? = nil

  public var openAccounts: Ocp_Transaction_V1_OpenAccountsMetadata {
    get {
      if case .openAccounts(let v)? = type {return v}
      return Ocp_Transaction_V1_OpenAccountsMetadata()
    }
    set {type = .openAccounts(newValue)}
  }

  public var sendPublicPayment: Ocp_Transaction_V1_SendPublicPaymentMetadata {
    get {
      if case .sendPublicPayment(let v)? = type {return v}
      return Ocp_Transaction_V1_SendPublicPaymentMetadata()
    }
    set {type = .sendPublicPayment(newValue)}
  }

  public var receivePaymentsPublicly: Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata {
    get {
      if case .receivePaymentsPublicly(let v)? = type {return v}
      return Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata()
    }
    set {type = .receivePaymentsPublicly(newValue)}
  }

  public var publicDistribution: Ocp_Transaction_V1_PublicDistributionMetadata {
    get {
      if case .publicDistribution(let v)? = type {return v}
      return Ocp_Transaction_V1_PublicDistributionMetadata()
    }
    set {type = .publicDistribution(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case openAccounts(Ocp_Transaction_V1_OpenAccountsMetadata)
    case sendPublicPayment(Ocp_Transaction_V1_SendPublicPaymentMetadata)
    case receivePaymentsPublicly(Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata)
    case publicDistribution(Ocp_Transaction_V1_PublicDistributionMetadata)

  }

  public init() {}
}

/// Open a set of accounts
///
/// Action Spec (User):
///
/// for account in [PRIMARY]
///   actions.push_back(OpenAccountAction(account))
///
/// Action Spec (Pool):
///
/// for account in [POOL]
///   actions.push_back(OpenAccountAction(account))
public struct Ocp_Transaction_V1_OpenAccountsMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountSet: Ocp_Transaction_V1_OpenAccountsMetadata.AccountSet = .user

  /// The mint that this action will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AccountSet: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Opens a set of user accounts
    case user // = 0

    /// Opens a pool account
    case pool // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .user
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .user
      case 1: self = .pool
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .user: return 0
      case .pool: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_OpenAccountsMetadata.AccountSet] = [
      .user,
      .pool,
    ]

  }

  public init() {}

  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Send a payment to a destination account publicly.
///
/// Action Spec (Payment):
///
/// actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
///
/// Action Spec (Withdrawal):
///
/// actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
/// if destinationRequiresInitialization {
///   actions[0].NoPrivacyTransferAction.ExchangeData.Quarks -= feeAmount
///   actions.push_back(FeePaymentAction(PRIMARY, feeAccount, feeAmount))
/// }
///
/// Action Spec (Remote Send):
///
/// actions = [
///   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
///   NoPrivacyTransferAction(PRIMARY, REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
///   NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, ExchangeData.Quarks, is_auto_return=true),
/// ]
public struct Ocp_Transaction_V1_SendPublicPaymentMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source account where funds will be sent from. Currently, this is always
  /// the user's primary account.
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination token account to send funds to.
  public var destination: Ocp_Common_V1_SolanaAccountId {
    get {return _destination ?? Ocp_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// Destination owner account, which is required for withdrawals that intend
  /// to create an ATA. Every other variation of this intent can omit this field.
  public var destinationOwner: Ocp_Common_V1_SolanaAccountId {
    get {return _destinationOwner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_destinationOwner = newValue}
  }
  /// Returns true if `destinationOwner` has been explicitly set.
  public var hasDestinationOwner: Bool {return self._destinationOwner != nil}
  /// Clears the value of `destinationOwner`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationOwner() {self._destinationOwner = nil}

  /// The exchange data of total funds being sent to the destination
  public var exchangeData: Ocp_Transaction_V1_ExchangeData {
    get {return _exchangeData ?? Ocp_Transaction_V1_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// Is the payment a withdrawal?
  public var isWithdrawal: Bool = false

  /// Is the payment going to a new gift card? Note is_withdrawal must be false.
  public var isRemoteSend: Bool = false

  /// The mint that this intent will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _destinationOwner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Ocp_Transaction_V1_ExchangeData? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Receive funds into a user-owned account publicly. All use cases of this intent
/// close the account, so all funds must be moved.
///
/// Action Spec (Remote Send):
///
/// actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, quarks)]
public struct Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The remote send gift card to receive funds from
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The exact amount of quarks being received
  public var quarks: UInt64 = 0

  /// Is the receipt of funds from a remote send gift card? Currently, this is
  /// the only use case for this intent and validation enforces the flag to true.
  public var isRemoteSend: Bool = false

  /// If is_remote_send is true, the original exchange data that was provided as
  /// part of creating the gift card account. This is purely a server-provided value.
  /// SubmitIntent will disallow this being set.
  public var exchangeData: Ocp_Transaction_V1_ExchangeData {
    get {return _exchangeData ?? Ocp_Transaction_V1_ExchangeData()}
    set {_exchangeData = newValue}
  }
  /// Returns true if `exchangeData` has been explicitly set.
  public var hasExchangeData: Bool {return self._exchangeData != nil}
  /// Clears the value of `exchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeData() {self._exchangeData = nil}

  /// The mint that this intent will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _exchangeData: Ocp_Transaction_V1_ExchangeData? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Distribute funds from a pool account publicly to one or more user-owned accounts.
///
/// Action Spec:
///
/// for distribution in distributions[:len(distributions)-1]
///   actions.push_back(NoPrivacyTransferAction(POOL, distribution.destination, distributions.quarks))
/// actions.push_back(NoPrivacyWithdrawAction(POOL, distributions[len(distributions)-1].destination, distributions[len(distributions)-1].quarks))
///
/// Notes:
///  - All funds must distributed. The balance of the pool must be zero at the end of the intent
///  - The pool is closed at the end of the intent via a NoPrivacyWithdrawAction
public struct Ocp_Transaction_V1_PublicDistributionMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pool account to distribute from
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The set of distributions
  public var distributions: [Ocp_Transaction_V1_PublicDistributionMetadata.Distribution] = []

  /// The mint that this intent will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Distribution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Destination where a portion of the pool's funds will be distributed.
    /// This must always be a primary account.
    public var destination: Ocp_Common_V1_SolanaAccountId {
      get {return _destination ?? Ocp_Common_V1_SolanaAccountId()}
      set {_destination = newValue}
    }
    /// Returns true if `destination` has been explicitly set.
    public var hasDestination: Bool {return self._destination != nil}
    /// Clears the value of `destination`. Subsequent reads from it will return its default value.
    public mutating func clearDestination() {self._destination = nil}

    /// The amount of funds to distribute to the destination
    public var quarks: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _destination: Ocp_Common_V1_SolanaAccountId? = nil
  }

  public init() {}

  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Action is a well-defined, ordered and small set of transactions or virtual instructions
/// for a unit of work that the client wants to perform on the blockchain. Clients provide
/// parameters known to them in the action.
public struct Ocp_Transaction_V1_Action: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this action, which is unique within an intent. It must match
  /// the index of the action's location in the SubmitAction's actions field.
  public var id: UInt32 = 0

  /// The type of action to perform.
  public var type: Ocp_Transaction_V1_Action.OneOf_Type? = nil

  public var openAccount: Ocp_Transaction_V1_OpenAccountAction {
    get {
      if case .openAccount(let v)? = type {return v}
      return Ocp_Transaction_V1_OpenAccountAction()
    }
    set {type = .openAccount(newValue)}
  }

  public var noPrivacyTransfer: Ocp_Transaction_V1_NoPrivacyTransferAction {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Ocp_Transaction_V1_NoPrivacyTransferAction()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Ocp_Transaction_V1_NoPrivacyWithdrawAction {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Ocp_Transaction_V1_NoPrivacyWithdrawAction()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var feePayment: Ocp_Transaction_V1_FeePaymentAction {
    get {
      if case .feePayment(let v)? = type {return v}
      return Ocp_Transaction_V1_FeePaymentAction()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of action to perform.
  public enum OneOf_Type: Equatable, Sendable {
    case openAccount(Ocp_Transaction_V1_OpenAccountAction)
    case noPrivacyTransfer(Ocp_Transaction_V1_NoPrivacyTransferAction)
    case noPrivacyWithdraw(Ocp_Transaction_V1_NoPrivacyWithdrawAction)
    case feePayment(Ocp_Transaction_V1_FeePaymentAction)

  }

  public init() {}
}

/// No client signature required
public struct Ocp_Transaction_V1_OpenAccountAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of account, which will dictate its intended use
  public var accountType: Ocp_Common_V1_AccountType = .unknown

  /// The owner of the account. For accounts liked to a user's 12 words, this is
  /// the verified parent owner account public key. All other account types should
  /// set this to the authority value.
  public var owner: Ocp_Common_V1_SolanaAccountId {
    get {return _owner ?? Ocp_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The index used to for accounts that are derived from owner
  public var index: UInt64 = 0

  /// The public key of the private key that has authority over the opened token account
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The token account being opened
  public var token: Ocp_Common_V1_SolanaAccountId {
    get {return _token ?? Ocp_Common_V1_SolanaAccountId()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The signature is of serialize(OpenAccountAction) without this field set
  /// using the private key of the authority account. This provides a proof
  /// of authorization to link authority to owner.
  public var authoritySignature: Ocp_Common_V1_Signature {
    get {return _authoritySignature ?? Ocp_Common_V1_Signature()}
    set {_authoritySignature = newValue}
  }
  /// Returns true if `authoritySignature` has been explicitly set.
  public var hasAuthoritySignature: Bool {return self._authoritySignature != nil}
  /// Clears the value of `authoritySignature`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritySignature() {self._authoritySignature = nil}

  /// The mint that this action will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _token: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _authoritySignature: Ocp_Common_V1_Signature? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Compact message signature required
public struct Ocp_Transaction_V1_NoPrivacyTransferAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Ocp_Common_V1_SolanaAccountId {
    get {return _destination ?? Ocp_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The quark amount to transfer
  public var amount: UInt64 = 0

  /// The mint that this action will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Compact message signature required
public struct Ocp_Transaction_V1_NoPrivacyWithdrawAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the private key that has authority over source
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The destination account where funds are transferred to
  public var destination: Ocp_Common_V1_SolanaAccountId {
    get {return _destination ?? Ocp_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// The quark amount to withdraw
  public var amount: UInt64 = 0

  /// Whether the account is closed afterwards. This is always true, since there
  /// are no current se cases to leave it open.
  public var shouldClose: Bool = false

  /// Whether this action is for an auto-return, which client allows server to defer
  /// scheduling at its own discretion to return funds back to the owner (to their primary
  /// account) that funded source.
  public var isAutoReturn: Bool = false

  /// The mint that this action will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _destination: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// Compact message signature required
public struct Ocp_Transaction_V1_FeePaymentAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of fee being operated on
  public var type: Ocp_Transaction_V1_FeePaymentAction.FeeType = .unknown

  /// The public key of the private key that has authority over source
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The source account where funds are transferred from
  public var source: Ocp_Common_V1_SolanaAccountId {
    get {return _source ?? Ocp_Common_V1_SolanaAccountId()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The quark amount to transfer
  public var amount: UInt64 = 0

  /// The mint that this action will be operating against
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FeeType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0

    /// Server-defined fee for creating an external ATA on withdrawals on send
    case createOnSendWithdrawal // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .createOnSendWithdrawal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .createOnSendWithdrawal: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_FeePaymentAction.FeeType] = [
      .unknown,
      .createOnSendWithdrawal,
    ]

  }

  public init() {}

  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _source: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

/// ServerParameter are a set of parameters known and returned by server that
/// enables clients to complete transaction construction. Any necessary proofs,
/// which are required to be locally verifiable, are also provided to ensure
/// safe use in the event of a malicious server.
public struct Ocp_Transaction_V1_ServerParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action the server parameters belong to
  public var actionID: UInt32 = 0

  /// The set of nonces used for the action. Server will only provide values
  /// for transactions requiring client signatures.
  public var nonces: [Ocp_Transaction_V1_NoncedTransactionMetadata] = []

  /// The type of server parameter which maps to the type of action requested
  public var type: Ocp_Transaction_V1_ServerParameter.OneOf_Type? = nil

  public var openAccount: Ocp_Transaction_V1_OpenAccountServerParameter {
    get {
      if case .openAccount(let v)? = type {return v}
      return Ocp_Transaction_V1_OpenAccountServerParameter()
    }
    set {type = .openAccount(newValue)}
  }

  public var noPrivacyTransfer: Ocp_Transaction_V1_NoPrivacyTransferServerParameter {
    get {
      if case .noPrivacyTransfer(let v)? = type {return v}
      return Ocp_Transaction_V1_NoPrivacyTransferServerParameter()
    }
    set {type = .noPrivacyTransfer(newValue)}
  }

  public var noPrivacyWithdraw: Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter {
    get {
      if case .noPrivacyWithdraw(let v)? = type {return v}
      return Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter()
    }
    set {type = .noPrivacyWithdraw(newValue)}
  }

  public var feePayment: Ocp_Transaction_V1_FeePaymentServerParameter {
    get {
      if case .feePayment(let v)? = type {return v}
      return Ocp_Transaction_V1_FeePaymentServerParameter()
    }
    set {type = .feePayment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of server parameter which maps to the type of action requested
  public enum OneOf_Type: Equatable, Sendable {
    case openAccount(Ocp_Transaction_V1_OpenAccountServerParameter)
    case noPrivacyTransfer(Ocp_Transaction_V1_NoPrivacyTransferServerParameter)
    case noPrivacyWithdraw(Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter)
    case feePayment(Ocp_Transaction_V1_FeePaymentServerParameter)

  }

  public init() {}
}

/// For transactions, the nonce is a standard nonce on Solana
/// For virtual instructions, the nonce is a virtual nonce on the Code VM
public struct Ocp_Transaction_V1_NoncedTransactionMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nonce account to use in the system::AdvanceNonce instruction
  public var nonce: Ocp_Common_V1_SolanaAccountId {
    get {return _nonce ?? Ocp_Common_V1_SolanaAccountId()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  public var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  public mutating func clearNonce() {self._nonce = nil}

  /// The blockhash to set in the transaction or virtual instruction
  public var blockhash: Ocp_Common_V1_Blockhash {
    get {return _blockhash ?? Ocp_Common_V1_Blockhash()}
    set {_blockhash = newValue}
  }
  /// Returns true if `blockhash` has been explicitly set.
  public var hasBlockhash: Bool {return self._blockhash != nil}
  /// Clears the value of `blockhash`. Subsequent reads from it will return its default value.
  public mutating func clearBlockhash() {self._blockhash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nonce: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _blockhash: Ocp_Common_V1_Blockhash? = nil
}

/// There are no transactions requiring client signatures
public struct Ocp_Transaction_V1_OpenAccountServerParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Ocp_Transaction_V1_NoPrivacyTransferServerParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// There are no action-specific server parameters
public struct Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocp_Transaction_V1_FeePaymentServerParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination account where OCP fee payments should be sent. This will
  /// only be set when the corresponding FeePaymentAction.Type:
  /// - CREATE_ON_SEND_WITHDRAWAL
  public var destination: Ocp_Common_V1_SolanaAccountId {
    get {return _destination ?? Ocp_Common_V1_SolanaAccountId()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Transaction_V1_ErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocp_Transaction_V1_ErrorDetails.OneOf_Type? = nil

  public var reasonString: Ocp_Transaction_V1_ReasonStringErrorDetails {
    get {
      if case .reasonString(let v)? = type {return v}
      return Ocp_Transaction_V1_ReasonStringErrorDetails()
    }
    set {type = .reasonString(newValue)}
  }

  public var invalidSignature: Ocp_Transaction_V1_InvalidSignatureErrorDetails {
    get {
      if case .invalidSignature(let v)? = type {return v}
      return Ocp_Transaction_V1_InvalidSignatureErrorDetails()
    }
    set {type = .invalidSignature(newValue)}
  }

  public var denied: Ocp_Transaction_V1_DeniedErrorDetails {
    get {
      if case .denied(let v)? = type {return v}
      return Ocp_Transaction_V1_DeniedErrorDetails()
    }
    set {type = .denied(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case reasonString(Ocp_Transaction_V1_ReasonStringErrorDetails)
    case invalidSignature(Ocp_Transaction_V1_InvalidSignatureErrorDetails)
    case denied(Ocp_Transaction_V1_DeniedErrorDetails)

  }

  public init() {}
}

public struct Ocp_Transaction_V1_ReasonStringErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocp_Transaction_V1_InvalidSignatureErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action whose signature mismatched
  public var actionID: UInt32 = 0

  public var expectedBlob: Ocp_Transaction_V1_InvalidSignatureErrorDetails.OneOf_ExpectedBlob? = nil

  /// The transaction the server expected to have signed.
  public var expectedTransaction: Ocp_Common_V1_Transaction {
    get {
      if case .expectedTransaction(let v)? = expectedBlob {return v}
      return Ocp_Common_V1_Transaction()
    }
    set {expectedBlob = .expectedTransaction(newValue)}
  }

  /// The virtual ixn hash the server expected to have signed.
  public var expectedVixnHash: Ocp_Common_V1_Hash {
    get {
      if case .expectedVixnHash(let v)? = expectedBlob {return v}
      return Ocp_Common_V1_Hash()
    }
    set {expectedBlob = .expectedVixnHash(newValue)}
  }

  /// The signature that was provided by the client.
  public var providedSignature: Ocp_Common_V1_Signature {
    get {return _providedSignature ?? Ocp_Common_V1_Signature()}
    set {_providedSignature = newValue}
  }
  /// Returns true if `providedSignature` has been explicitly set.
  public var hasProvidedSignature: Bool {return self._providedSignature != nil}
  /// Clears the value of `providedSignature`. Subsequent reads from it will return its default value.
  public mutating func clearProvidedSignature() {self._providedSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ExpectedBlob: Equatable, Sendable {
    /// The transaction the server expected to have signed.
    case expectedTransaction(Ocp_Common_V1_Transaction)
    /// The virtual ixn hash the server expected to have signed.
    case expectedVixnHash(Ocp_Common_V1_Hash)

  }

  public init() {}

  fileprivate var _providedSignature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Transaction_V1_DeniedErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocp_Transaction_V1_DeniedErrorDetails.Code = .unspecified

  /// Human readable string indicating the failure.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Reason code not yet defined
    case unspecified // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_DeniedErrorDetails.Code] = [
      .unspecified,
    ]

  }

  public init() {}
}

/// ExchangeData defines an amount of crypto with currency exchange data
public struct Ocp_Transaction_V1_ExchangeData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon exchange rate. This might not be the same as the
  /// actual exchange rate at the time of intent or fund transfer.
  public var exchangeRate: Double = 0

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  /// The exact amount of quarks to send. This will be used as the source of
  /// truth for validating transaction transfer amounts.
  public var quarks: UInt64 = 0

  /// The crypto mint that is being operated against for the exchange.
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Transaction_V1_ExchangeDataWithoutRate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ISO 4217 alpha-3 currency code.
  public var currency: String = String()

  /// The agreed upon transfer amount in the currency the payment was made
  /// in.
  public var nativeAmount: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocp_Transaction_V1_SendLimit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remaining limit to apply on the next transaction
  public var nextTransaction: Float = 0

  /// Maximum allowed on a per-transaction basis
  public var maxPerTransaction: Float = 0

  /// Maximum allowed on a per-day basis
  public var maxPerDay: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VerifiedSwapMetadata defines verifiable swap metadata for non-custodial swap
/// state management using client signature verification.
public struct Ocp_Transaction_V1_VerifiedSwapMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Ocp_Transaction_V1_VerifiedSwapMetadata.OneOf_Kind? = nil

  public var currencyCreator: Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata {
    get {
      if case .currencyCreator(let v)? = kind {return v}
      return Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata()
    }
    set {kind = .currencyCreator(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, Sendable {
    case currencyCreator(Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata)

  }

  public init() {}
}

/// VerifiedCurrencyCreatorSwapMetadata is verified metadata for swaps against the
/// Currency Creator program
public struct Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Verifiable client-side parameters that were provided during the StatefulSwap RPC
  public var clientParameters: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator {
    get {return _clientParameters ?? Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator()}
    set {_clientParameters = newValue}
  }
  /// Returns true if `clientParameters` has been explicitly set.
  public var hasClientParameters: Bool {return self._clientParameters != nil}
  /// Clears the value of `clientParameters`. Subsequent reads from it will return its default value.
  public mutating func clearClientParameters() {self._clientParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientParameters: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator? = nil
}

public struct Ocp_Transaction_V1_SwapMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verifiedMetadata: Ocp_Transaction_V1_VerifiedSwapMetadata {
    get {return _verifiedMetadata ?? Ocp_Transaction_V1_VerifiedSwapMetadata()}
    set {_verifiedMetadata = newValue}
  }
  /// Returns true if `verifiedMetadata` has been explicitly set.
  public var hasVerifiedMetadata: Bool {return self._verifiedMetadata != nil}
  /// Clears the value of `verifiedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVerifiedMetadata() {self._verifiedMetadata = nil}

  public var state: Ocp_Transaction_V1_SwapMetadata.State = .unknown

  /// The signature is of serialize(VerifiedSwapMetadata) using the private
  /// key of the owner account. Use this to guarantee that VerifiedSwapMetadata
  /// has not been tampered with.
  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0

    /// Swap state has been created and is pending funding
    case created // = 1

    /// The VM swap PDA is in the process of being funded
    case funding // = 2

    /// The VM swap PDA has been funded
    case funded // = 3

    /// The swap transaction is being submitted to the blockchain
    case submitting // = 4

    /// The swap transaction has been finalized on the blockchain
    case finalized // = 5

    /// The swap transaction failed
    case failed // = 6

    /// The swap is in the process of being cancelled.
    case cancelling // = 7

    /// The swap transaction is cancelled. Funds have been deposited back into the VM
    case cancelled // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .created
      case 2: self = .funding
      case 3: self = .funded
      case 4: self = .submitting
      case 5: self = .finalized
      case 6: self = .failed
      case 7: self = .cancelling
      case 8: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .created: return 1
      case .funding: return 2
      case .funded: return 3
      case .submitting: return 4
      case .finalized: return 5
      case .failed: return 6
      case .cancelling: return 7
      case .cancelled: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Transaction_V1_SwapMetadata.State] = [
      .unknown,
      .created,
      .funding,
      .funded,
      .submitting,
      .finalized,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  public init() {}

  fileprivate var _verifiedMetadata: Ocp_Transaction_V1_VerifiedSwapMetadata? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocp.transaction.v1"

extension Ocp_Transaction_V1_AirdropType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}ONBOARDING_BONUS\0\u{1}WELCOME_BONUS\0")
}

extension Ocp_Transaction_V1_FundingSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FUNDING_SOURCE_UNKNOWN\0\u{1}FUNDING_SOURCE_SUBMIT_INTENT\0\u{1}FUNDING_SOURCE_EXTERNAL_WALLET\0")
}

extension Ocp_Transaction_V1_SubmitIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}submit_actions\0\u{3}submit_signatures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitActions(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignatures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignatures(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .submitActions?: try {
      guard case .submitActions(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignatures?: try {
      guard case .submitSignatures(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentRequest, rhs: Ocp_Transaction_V1_SubmitIntentRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_SubmitIntentRequest.protoMessageName + ".SubmitActions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}owner\0\u{1}metadata\0\u{1}actions\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions, rhs: Ocp_Transaction_V1_SubmitIntentRequest.SubmitActions) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_SubmitIntentRequest.protoMessageName + ".SubmitSignatures"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}signatures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures, rhs: Ocp_Transaction_V1_SubmitIntentRequest.SubmitSignatures) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitIntentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_parameters\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_SubmitIntentResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Ocp_Transaction_V1_SubmitIntentResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentResponse, rhs: Ocp_Transaction_V1_SubmitIntentResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_SubmitIntentResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_parameters\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serverParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverParameters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters, rhs: Ocp_Transaction_V1_SubmitIntentResponse.ServerParameters) -> Bool {
    if lhs.serverParameters != rhs.serverParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_SubmitIntentResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentResponse.Success, rhs: Ocp_Transaction_V1_SubmitIntentResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0")
}

extension Ocp_Transaction_V1_SubmitIntentResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_SubmitIntentResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{3}error_details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SubmitIntentResponse.Error, rhs: Ocp_Transaction_V1_SubmitIntentResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SubmitIntentResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DENIED\0\u{1}INVALID_INTENT\0\u{1}SIGNATURE_ERROR\0\u{1}STALE_STATE\0")
}

extension Ocp_Transaction_V1_GetIntentMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}intent_id\0\u{1}owner\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._intentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetIntentMetadataRequest, rhs: Ocp_Transaction_V1_GetIntentMetadataRequest) -> Bool {
    if lhs._intentID != rhs._intentID {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetIntentMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIntentMetadataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetIntentMetadataResponse, rhs: Ocp_Transaction_V1_GetIntentMetadataResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetIntentMetadataResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0")
}

extension Ocp_Transaction_V1_GetLimitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}owner\0\u{1}signature\0\u{3}consumed_since\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumedSince) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._consumedSince {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetLimitsRequest, rhs: Ocp_Transaction_V1_GetLimitsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._consumedSince != rhs._consumedSince {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetLimitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLimitsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}send_limits_by_currency\0\u{3}usd_transacted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocp_Transaction_V1_SendLimit>.self, value: &self.sendLimitsByCurrency) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.usdTransacted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.sendLimitsByCurrency.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocp_Transaction_V1_SendLimit>.self, value: self.sendLimitsByCurrency, fieldNumber: 2)
    }
    if self.usdTransacted.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.usdTransacted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetLimitsResponse, rhs: Ocp_Transaction_V1_GetLimitsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.sendLimitsByCurrency != rhs.sendLimitsByCurrency {return false}
    if lhs.usdTransacted != rhs.usdTransacted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetLimitsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0")
}

extension Ocp_Transaction_V1_CanWithdrawToAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_CanWithdrawToAccountRequest, rhs: Ocp_Transaction_V1_CanWithdrawToAccountRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_CanWithdrawToAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawToAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_valid_payment_destination\0\u{3}account_type\0\u{3}requires_initialization\0\u{3}fee_amount\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValidPaymentDestination) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requiresInitialization) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._feeAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isValidPaymentDestination != false {
      try visitor.visitSingularBoolField(value: self.isValidPaymentDestination, fieldNumber: 1)
    }
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 2)
    }
    if self.requiresInitialization != false {
      try visitor.visitSingularBoolField(value: self.requiresInitialization, fieldNumber: 3)
    }
    try { if let v = self._feeAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_CanWithdrawToAccountResponse, rhs: Ocp_Transaction_V1_CanWithdrawToAccountResponse) -> Bool {
    if lhs.isValidPaymentDestination != rhs.isValidPaymentDestination {return false}
    if lhs.accountType != rhs.accountType {return false}
    if lhs.requiresInitialization != rhs.requiresInitialization {return false}
    if lhs._feeAmount != rhs._feeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_CanWithdrawToAccountResponse.AccountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Unknown\0\u{1}TokenAccount\0\u{1}OwnerAccount\0")
}

extension Ocp_Transaction_V1_AirdropRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}airdrop_type\0\u{1}owner\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.airdropType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.airdropType != .unknown {
      try visitor.visitSingularEnumField(value: self.airdropType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_AirdropRequest, rhs: Ocp_Transaction_V1_AirdropRequest) -> Bool {
    if lhs.airdropType != rhs.airdropType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_AirdropResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AirdropResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}exchange_data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_AirdropResponse, rhs: Ocp_Transaction_V1_AirdropResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_AirdropResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}UNAVAILABLE\0\u{1}ALREADY_CLAIMED\0")
}

extension Ocp_Transaction_V1_VoidGiftCardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoidGiftCardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}owner\0\u{3}gift_card_vault\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._giftCardVault) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._giftCardVault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_VoidGiftCardRequest, rhs: Ocp_Transaction_V1_VoidGiftCardRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._giftCardVault != rhs._giftCardVault {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_VoidGiftCardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoidGiftCardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_VoidGiftCardResponse, rhs: Ocp_Transaction_V1_VoidGiftCardResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_VoidGiftCardResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}DENIED\0\u{1}CLAIMED_BY_OTHER_USER\0\u{1}NOT_FOUND\0")
}

extension Ocp_Transaction_V1_StatefulSwapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatefulSwapRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}initiate\0\u{3}submit_signatures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_StatefulSwapRequest.Initiate?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initiate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initiate(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .submitSignatures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .submitSignatures(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initiate?: try {
      guard case .initiate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .submitSignatures?: try {
      guard case .submitSignatures(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapRequest, rhs: Ocp_Transaction_V1_StatefulSwapRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapRequest.Initiate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapRequest.protoMessageName + ".Initiate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}currency_creator\0\u{2}\u{8}owner\0\u{3}swap_authority\0\u{3}proof_signature\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .currencyCreator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .currencyCreator(v)
        }
      }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._swapAuthority) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._proofSignature) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .currencyCreator(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._swapAuthority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._proofSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapRequest.Initiate, rhs: Ocp_Transaction_V1_StatefulSwapRequest.Initiate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._swapAuthority != rhs._swapAuthority {return false}
    if lhs._proofSignature != rhs._proofSignature {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapRequest.Initiate.protoMessageName + ".CurrencyCreator"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}from_mint\0\u{3}to_mint\0\u{1}amount\0\u{3}funding_source\0\u{3}funding_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fromMint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._toMint) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.fundingSource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.fundingID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fromMint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._toMint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if self.fundingSource != .unknown {
      try visitor.visitSingularEnumField(value: self.fundingSource, fieldNumber: 5)
    }
    if !self.fundingID.isEmpty {
      try visitor.visitSingularStringField(value: self.fundingID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator, rhs: Ocp_Transaction_V1_StatefulSwapRequest.Initiate.CurrencyCreator) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._fromMint != rhs._fromMint {return false}
    if lhs._toMint != rhs._toMint {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.fundingSource != rhs.fundingSource {return false}
    if lhs.fundingID != rhs.fundingID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapRequest.protoMessageName + ".SubmitSignatures"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transaction_signatures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactionSignatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionSignatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionSignatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures, rhs: Ocp_Transaction_V1_StatefulSwapRequest.SubmitSignatures) -> Bool {
    if lhs.transactionSignatures != rhs.transactionSignatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatefulSwapResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_parameters\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .serverParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .serverParameters(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_StatefulSwapResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try {
        var v: Ocp_Transaction_V1_StatefulSwapResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .serverParameters?: try {
      guard case .serverParameters(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapResponse, rhs: Ocp_Transaction_V1_StatefulSwapResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapResponse.protoMessageName + ".ServerParameters"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}currency_creator\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .currencyCreator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .currencyCreator(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .currencyCreator(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters, rhs: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.protoMessageName + ".CurrencyCreator"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payer\0\u{1}nonce\0\u{1}blockhash\0\u{1}alts\0\u{3}compute_unit_limit\0\u{3}compute_unit_price\0\u{3}memo_value\0\u{3}memory_account\0\u{3}memory_index\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockhash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.alts) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.computeUnitLimit) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.computeUnitPrice) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.memoValue) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._memoryAccount) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.memoryIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.alts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alts, fieldNumber: 4)
    }
    if self.computeUnitLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.computeUnitLimit, fieldNumber: 5)
    }
    if self.computeUnitPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.computeUnitPrice, fieldNumber: 6)
    }
    if !self.memoValue.isEmpty {
      try visitor.visitSingularStringField(value: self.memoValue, fieldNumber: 7)
    }
    try { if let v = self._memoryAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.memoryIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.memoryIndex, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator, rhs: Ocp_Transaction_V1_StatefulSwapResponse.ServerParameters.CurrencyCreator) -> Bool {
    if lhs._payer != rhs._payer {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs._blockhash != rhs._blockhash {return false}
    if lhs.alts != rhs.alts {return false}
    if lhs.computeUnitLimit != rhs.computeUnitLimit {return false}
    if lhs.computeUnitPrice != rhs.computeUnitPrice {return false}
    if lhs.memoValue != rhs.memoValue {return false}
    if lhs._memoryAccount != rhs._memoryAccount {return false}
    if lhs.memoryIndex != rhs.memoryIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapResponse.Success, rhs: Ocp_Transaction_V1_StatefulSwapResponse.Success) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse.Success.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0")
}

extension Ocp_Transaction_V1_StatefulSwapResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_StatefulSwapResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{3}error_details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .denied {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_StatefulSwapResponse.Error, rhs: Ocp_Transaction_V1_StatefulSwapResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_StatefulSwapResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DENIED\0\u{1}SIGNATURE_ERROR\0\u{1}INVALID_SWAP\0")
}

extension Ocp_Transaction_V1_GetSwapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSwapRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}owner\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetSwapRequest, rhs: Ocp_Transaction_V1_GetSwapRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetSwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSwapResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}swap\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._swap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetSwapResponse, rhs: Ocp_Transaction_V1_GetSwapResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._swap != rhs._swap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetSwapResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0\u{1}DENIED\0")
}

extension Ocp_Transaction_V1_GetPendingSwapsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPendingSwapsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}owner\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetPendingSwapsRequest, rhs: Ocp_Transaction_V1_GetPendingSwapsRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetPendingSwapsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPendingSwapsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}swaps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.swaps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.swaps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.swaps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_GetPendingSwapsResponse, rhs: Ocp_Transaction_V1_GetPendingSwapsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.swaps != rhs.swaps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_GetPendingSwapsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0")
}

extension Ocp_Transaction_V1_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}open_accounts\0\u{3}send_public_payment\0\u{3}receive_payments_publicly\0\u{3}public_distribution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_OpenAccountsMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccounts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccounts(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_SendPublicPaymentMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sendPublicPayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sendPublicPayment(v)
        }
      }()
      case 3: try {
        var v: Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .receivePaymentsPublicly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .receivePaymentsPublicly(v)
        }
      }()
      case 4: try {
        var v: Ocp_Transaction_V1_PublicDistributionMetadata?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .publicDistribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .publicDistribution(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .openAccounts?: try {
      guard case .openAccounts(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendPublicPayment?: try {
      guard case .sendPublicPayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .receivePaymentsPublicly?: try {
      guard case .receivePaymentsPublicly(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .publicDistribution?: try {
      guard case .publicDistribution(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_Metadata, rhs: Ocp_Transaction_V1_Metadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_OpenAccountsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountsMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}account_set\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountSet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountSet != .user {
      try visitor.visitSingularEnumField(value: self.accountSet, fieldNumber: 1)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_OpenAccountsMetadata, rhs: Ocp_Transaction_V1_OpenAccountsMetadata) -> Bool {
    if lhs.accountSet != rhs.accountSet {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_OpenAccountsMetadata.AccountSet: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0USER\0\u{1}POOL\0")
}

extension Ocp_Transaction_V1_SendPublicPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPublicPaymentMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}destination\0\u{3}destination_owner\0\u{3}exchange_data\0\u{3}is_withdrawal\0\u{3}is_remote_send\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destinationOwner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWithdrawal) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destinationOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.isWithdrawal != false {
      try visitor.visitSingularBoolField(value: self.isWithdrawal, fieldNumber: 5)
    }
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 6)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SendPublicPaymentMetadata, rhs: Ocp_Transaction_V1_SendPublicPaymentMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._destinationOwner != rhs._destinationOwner {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs.isWithdrawal != rhs.isWithdrawal {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivePaymentsPubliclyMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}quarks\0\u{3}is_remote_send\0\u{3}exchange_data\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRemoteSend) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._exchangeData) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 2)
    }
    if self.isRemoteSend != false {
      try visitor.visitSingularBoolField(value: self.isRemoteSend, fieldNumber: 3)
    }
    try { if let v = self._exchangeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata, rhs: Ocp_Transaction_V1_ReceivePaymentsPubliclyMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.isRemoteSend != rhs.isRemoteSend {return false}
    if lhs._exchangeData != rhs._exchangeData {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_PublicDistributionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicDistributionMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}distributions\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.distributions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.distributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.distributions, fieldNumber: 2)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_PublicDistributionMetadata, rhs: Ocp_Transaction_V1_PublicDistributionMetadata) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.distributions != rhs.distributions {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_PublicDistributionMetadata.Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Transaction_V1_PublicDistributionMetadata.protoMessageName + ".Distribution"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destination\0\u{1}quarks\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_PublicDistributionMetadata.Distribution, rhs: Ocp_Transaction_V1_PublicDistributionMetadata.Distribution) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}open_account\0\u{3}no_privacy_transfer\0\u{3}no_privacy_withdraw\0\u{3}fee_payment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Ocp_Transaction_V1_OpenAccountAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 3: try {
        var v: Ocp_Transaction_V1_NoPrivacyTransferAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 4: try {
        var v: Ocp_Transaction_V1_NoPrivacyWithdrawAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 5: try {
        var v: Ocp_Transaction_V1_FeePaymentAction?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_Action, rhs: Ocp_Transaction_V1_Action) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_OpenAccountAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}account_type\0\u{1}owner\0\u{1}index\0\u{1}authority\0\u{1}token\0\u{3}authority_signature\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.accountType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._authoritySignature) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.accountType != .unknown {
      try visitor.visitSingularEnumField(value: self.accountType, fieldNumber: 1)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 3)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._authoritySignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_OpenAccountAction, rhs: Ocp_Transaction_V1_OpenAccountAction) -> Bool {
    if lhs.accountType != rhs.accountType {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.index != rhs.index {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._token != rhs._token {return false}
    if lhs._authoritySignature != rhs._authoritySignature {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_NoPrivacyTransferAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authority\0\u{1}source\0\u{1}destination\0\u{1}amount\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_NoPrivacyTransferAction, rhs: Ocp_Transaction_V1_NoPrivacyTransferAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_NoPrivacyWithdrawAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authority\0\u{1}source\0\u{1}destination\0\u{1}amount\0\u{3}should_close\0\u{3}is_auto_return\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.shouldClose) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isAutoReturn) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if self.shouldClose != false {
      try visitor.visitSingularBoolField(value: self.shouldClose, fieldNumber: 5)
    }
    if self.isAutoReturn != false {
      try visitor.visitSingularBoolField(value: self.isAutoReturn, fieldNumber: 6)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_NoPrivacyWithdrawAction, rhs: Ocp_Transaction_V1_NoPrivacyWithdrawAction) -> Bool {
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.shouldClose != rhs.shouldClose {return false}
    if lhs.isAutoReturn != rhs.isAutoReturn {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_FeePaymentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}authority\0\u{1}source\0\u{1}amount\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_FeePaymentAction, rhs: Ocp_Transaction_V1_FeePaymentAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._source != rhs._source {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_FeePaymentAction.FeeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}CREATE_ON_SEND_WITHDRAWAL\0")
}

extension Ocp_Transaction_V1_ServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}nonces\0\u{3}open_account\0\u{3}no_privacy_transfer\0\u{3}no_privacy_withdraw\0\u{3}fee_payment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nonces) }()
      case 3: try {
        var v: Ocp_Transaction_V1_OpenAccountServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .openAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .openAccount(v)
        }
      }()
      case 4: try {
        var v: Ocp_Transaction_V1_NoPrivacyTransferServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyTransfer(v)
        }
      }()
      case 5: try {
        var v: Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .noPrivacyWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .noPrivacyWithdraw(v)
        }
      }()
      case 6: try {
        var v: Ocp_Transaction_V1_FeePaymentServerParameter?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .feePayment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .feePayment(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    if !self.nonces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonces, fieldNumber: 2)
    }
    switch self.type {
    case .openAccount?: try {
      guard case .openAccount(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPrivacyTransfer?: try {
      guard case .noPrivacyTransfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .noPrivacyWithdraw?: try {
      guard case .noPrivacyWithdraw(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .feePayment?: try {
      guard case .feePayment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ServerParameter, rhs: Ocp_Transaction_V1_ServerParameter) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.nonces != rhs.nonces {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_NoncedTransactionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoncedTransactionMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nonce\0\u{1}blockhash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockhash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockhash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_NoncedTransactionMetadata, rhs: Ocp_Transaction_V1_NoncedTransactionMetadata) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._blockhash != rhs._blockhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_OpenAccountServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAccountServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_OpenAccountServerParameter, rhs: Ocp_Transaction_V1_OpenAccountServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_NoPrivacyTransferServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyTransferServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_NoPrivacyTransferServerParameter, rhs: Ocp_Transaction_V1_NoPrivacyTransferServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoPrivacyWithdrawServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter, rhs: Ocp_Transaction_V1_NoPrivacyWithdrawServerParameter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_FeePaymentServerParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeePaymentServerParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destination\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_FeePaymentServerParameter, rhs: Ocp_Transaction_V1_FeePaymentServerParameter) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_ErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reason_string\0\u{3}invalid_signature\0\u{1}denied\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_ReasonStringErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reasonString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reasonString(v)
        }
      }()
      case 2: try {
        var v: Ocp_Transaction_V1_InvalidSignatureErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .invalidSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .invalidSignature(v)
        }
      }()
      case 3: try {
        var v: Ocp_Transaction_V1_DeniedErrorDetails?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .denied(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .denied(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .reasonString?: try {
      guard case .reasonString(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .invalidSignature?: try {
      guard case .invalidSignature(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .denied?: try {
      guard case .denied(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ErrorDetails, rhs: Ocp_Transaction_V1_ErrorDetails) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_ReasonStringErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReasonStringErrorDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ReasonStringErrorDetails, rhs: Ocp_Transaction_V1_ReasonStringErrorDetails) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_InvalidSignatureErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvalidSignatureErrorDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{3}expected_transaction\0\u{3}provided_signature\0\u{3}expected_vixn_hash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 2: try {
        var v: Ocp_Common_V1_Transaction?
        var hadOneofValue = false
        if let current = self.expectedBlob {
          hadOneofValue = true
          if case .expectedTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedBlob = .expectedTransaction(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._providedSignature) }()
      case 4: try {
        var v: Ocp_Common_V1_Hash?
        var hadOneofValue = false
        if let current = self.expectedBlob {
          hadOneofValue = true
          if case .expectedVixnHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedBlob = .expectedVixnHash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 1)
    }
    try { if case .expectedTransaction(let v)? = self.expectedBlob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._providedSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .expectedVixnHash(let v)? = self.expectedBlob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_InvalidSignatureErrorDetails, rhs: Ocp_Transaction_V1_InvalidSignatureErrorDetails) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.expectedBlob != rhs.expectedBlob {return false}
    if lhs._providedSignature != rhs._providedSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_DeniedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeniedErrorDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_DeniedErrorDetails, rhs: Ocp_Transaction_V1_DeniedErrorDetails) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_DeniedErrorDetails.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0")
}

extension Ocp_Transaction_V1_ExchangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}currency\0\u{3}exchange_rate\0\u{3}native_amount\0\u{1}quarks\0\u{1}mint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.exchangeRate) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.quarks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.exchangeRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.exchangeRate, fieldNumber: 2)
    }
    if self.nativeAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 3)
    }
    if self.quarks != 0 {
      try visitor.visitSingularUInt64Field(value: self.quarks, fieldNumber: 4)
    }
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ExchangeData, rhs: Ocp_Transaction_V1_ExchangeData) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.quarks != rhs.quarks {return false}
    if lhs._mint != rhs._mint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_ExchangeDataWithoutRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeDataWithoutRate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}currency\0\u{3}native_amount\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.nativeAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.nativeAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.nativeAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_ExchangeDataWithoutRate, rhs: Ocp_Transaction_V1_ExchangeDataWithoutRate) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.nativeAmount != rhs.nativeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SendLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendLimit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_transaction\0\u{3}max_per_transaction\0\u{3}max_per_day\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.nextTransaction) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxPerTransaction) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxPerDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextTransaction.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.nextTransaction, fieldNumber: 1)
    }
    if self.maxPerTransaction.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerTransaction, fieldNumber: 2)
    }
    if self.maxPerDay.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxPerDay, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SendLimit, rhs: Ocp_Transaction_V1_SendLimit) -> Bool {
    if lhs.nextTransaction != rhs.nextTransaction {return false}
    if lhs.maxPerTransaction != rhs.maxPerTransaction {return false}
    if lhs.maxPerDay != rhs.maxPerDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_VerifiedSwapMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedSwapMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}currency_creator\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .currencyCreator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .currencyCreator(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .currencyCreator(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_VerifiedSwapMetadata, rhs: Ocp_Transaction_V1_VerifiedSwapMetadata) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedCurrencyCreatorSwapMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_parameters\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clientParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata, rhs: Ocp_Transaction_V1_VerifiedCurrencyCreatorSwapMetadata) -> Bool {
    if lhs._clientParameters != rhs._clientParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SwapMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}verified_metadata\0\u{1}state\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._verifiedMetadata) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._verifiedMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Transaction_V1_SwapMetadata, rhs: Ocp_Transaction_V1_SwapMetadata) -> Bool {
    if lhs._verifiedMetadata != rhs._verifiedMetadata {return false}
    if lhs.state != rhs.state {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Transaction_V1_SwapMetadata.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}CREATED\0\u{1}FUNDING\0\u{1}FUNDED\0\u{1}SUBMITTING\0\u{1}FINALIZED\0\u{1}FAILED\0\u{1}CANCELLING\0\u{1}CANCELLED\0")
}
