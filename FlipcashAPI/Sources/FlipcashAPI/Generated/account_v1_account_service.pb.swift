// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: account/v1/account_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Code_Account_V1_IsCodeAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to check against.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(IsCodeAccountRequest) without this field set
  /// using the private key of the owner account. This provides an authentication
  /// mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
}

public struct Code_Account_V1_IsCodeAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Account_V1_IsCodeAccountResponse.Result = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The account is a Code account.
    case ok // = 0

    /// The account is not a Code account.
    case notFound // = 1

    /// The account exists, but at least one timelock account is unlocked.
    case unlockedTimelockAccount // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .unlockedTimelockAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .unlockedTimelockAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_IsCodeAccountResponse.Result] = [
      .ok,
      .notFound,
      .unlockedTimelockAccount,
    ]

  }

  public init() {}
}

public struct Code_Account_V1_GetTokenAccountInfosRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner account to fetch balances for, which can also be thought of as a
  /// parent account for this RPC that links to one or more token accounts.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _owner ?? Code_Common_V1_SolanaAccountId()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// The signature is of serialize(GetTokenAccountInfosRequest) without signature
  /// fields set using the private key of the owner account. This provides
  /// an authentication mechanism to the RPC.
  public var signature: Code_Common_V1_Signature {
    get {return _signature ?? Code_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// A requesting owner account that is requesting the balance for owner. Additional
  /// metadata that is considered private will be provided, if applicable. An example
  /// use case includes a user owner account requesting account info for a gift card
  /// owner account.
  public var requestingOwner: Code_Common_V1_SolanaAccountId {
    get {return _requestingOwner ?? Code_Common_V1_SolanaAccountId()}
    set {_requestingOwner = newValue}
  }
  /// Returns true if `requestingOwner` has been explicitly set.
  public var hasRequestingOwner: Bool {return self._requestingOwner != nil}
  /// Clears the value of `requestingOwner`. Subsequent reads from it will return its default value.
  public mutating func clearRequestingOwner() {self._requestingOwner = nil}

  /// The signature is of serialize(GetTokenAccountInfosRequest) without signature
  /// fields set using the private key of the requesting_owner_signature account.
  /// This provides an authentication mechanism to the RPC when requesting_owner is
  /// present.
  ///
  /// This must be set when requesting_owner is present.
  public var requestingOwnerSignature: Code_Common_V1_Signature {
    get {return _requestingOwnerSignature ?? Code_Common_V1_Signature()}
    set {_requestingOwnerSignature = newValue}
  }
  /// Returns true if `requestingOwnerSignature` has been explicitly set.
  public var hasRequestingOwnerSignature: Bool {return self._requestingOwnerSignature != nil}
  /// Clears the value of `requestingOwnerSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRequestingOwnerSignature() {self._requestingOwnerSignature = nil}

  /// Filter to apply to limit response sizes
  public var filter: Code_Account_V1_GetTokenAccountInfosRequest.OneOf_Filter? = nil

  public var filterByTokenAddress: Code_Common_V1_SolanaAccountId {
    get {
      if case .filterByTokenAddress(let v)? = filter {return v}
      return Code_Common_V1_SolanaAccountId()
    }
    set {filter = .filterByTokenAddress(newValue)}
  }

  public var filterByAccountType: Code_Common_V1_AccountType {
    get {
      if case .filterByAccountType(let v)? = filter {return v}
      return .unknown
    }
    set {filter = .filterByAccountType(newValue)}
  }

  public var filterByMintAddress: Code_Common_V1_SolanaAccountId {
    get {
      if case .filterByMintAddress(let v)? = filter {return v}
      return Code_Common_V1_SolanaAccountId()
    }
    set {filter = .filterByMintAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Filter to apply to limit response sizes
  public enum OneOf_Filter: Equatable, Sendable {
    case filterByTokenAddress(Code_Common_V1_SolanaAccountId)
    case filterByAccountType(Code_Common_V1_AccountType)
    case filterByMintAddress(Code_Common_V1_SolanaAccountId)

  }

  public init() {}

  fileprivate var _owner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _signature: Code_Common_V1_Signature? = nil
  fileprivate var _requestingOwner: Code_Common_V1_SolanaAccountId? = nil
  fileprivate var _requestingOwnerSignature: Code_Common_V1_Signature? = nil
}

public struct Code_Account_V1_GetTokenAccountInfosResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Code_Account_V1_GetTokenAccountInfosResponse.Result = .ok

  public var tokenAccountInfos: Dictionary<String,Code_Account_V1_TokenAccountInfo> = [:]

  /// The next index clients should use for POOL account types
  public var nextPoolIndex: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_GetTokenAccountInfosResponse.Result] = [
      .ok,
      .notFound,
    ]

  }

  public init() {}
}

public struct Code_Account_V1_TokenAccountInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token account's address
  public var address: Code_Common_V1_SolanaAccountId {
    get {return _storage._address ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// The owner of the token account, which can also be thought of as a parent
  /// account that links to one or more token accounts. This is provided when
  /// available.
  public var owner: Code_Common_V1_SolanaAccountId {
    get {return _storage._owner ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// The token account's authority, which has access to moving funds for the
  /// account. This can be the owner account under certain circumstances (eg.
  /// ATA, primary account). This is provided when available.
  public var authority: Code_Common_V1_SolanaAccountId {
    get {return _storage._authority ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return _storage._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {_uniqueStorage()._authority = nil}

  /// The type of token account, which infers its intended use.
  public var accountType: Code_Common_V1_AccountType {
    get {return _storage._accountType}
    set {_uniqueStorage()._accountType = newValue}
  }

  /// The account's derivation index for applicable account types. When this field
  /// doesn't apply, a zero value is provided.
  public var index: UInt64 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  /// The source of truth for the balance calculation.
  public var balanceSource: Code_Account_V1_TokenAccountInfo.BalanceSource {
    get {return _storage._balanceSource}
    set {_uniqueStorage()._balanceSource = newValue}
  }

  /// The balance in quarks, as observed by Code. This may not reflect the value
  /// on the blockchain and could be non-zero even if the account hasn't been created.
  /// Use balance_source to determine how this value was calculated.
  public var balance: UInt64 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// The state of the account as it pertains to Code's ability to manage funds.
  public var managementState: Code_Account_V1_TokenAccountInfo.ManagementState {
    get {return _storage._managementState}
    set {_uniqueStorage()._managementState = newValue}
  }

  /// The state of the account on the blockchain.
  public var blockchainState: Code_Account_V1_TokenAccountInfo.BlockchainState {
    get {return _storage._blockchainState}
    set {_uniqueStorage()._blockchainState = newValue}
  }

  /// Whether an account is claimed. This only applies to relevant account types
  /// (eg. REMOTE_SEND_GIFT_CARD).
  public var claimState: Code_Account_V1_TokenAccountInfo.ClaimState {
    get {return _storage._claimState}
    set {_uniqueStorage()._claimState = newValue}
  }

  /// For account types used as an intermediary for sending money between two
  /// users (eg. REMOTE_SEND_GIFT_CARD), this represents the original exchange
  /// data used to fund the account. Over time, this value will become stale:
  ///  1. Exchange rates will fluctuate, so the total fiat amount will differ.
  ///  2. External entities can deposit additional funds into the account, so
  ///     the balance, in quarks, may be greater than the original quark value.
  ///  3. The balance could have been received, so the total balance can show
  ///     as zero.
  public var originalExchangeData: Code_Transaction_V2_ExchangeData {
    get {return _storage._originalExchangeData ?? Code_Transaction_V2_ExchangeData()}
    set {_uniqueStorage()._originalExchangeData = newValue}
  }
  /// Returns true if `originalExchangeData` has been explicitly set.
  public var hasOriginalExchangeData: Bool {return _storage._originalExchangeData != nil}
  /// Clears the value of `originalExchangeData`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalExchangeData() {_uniqueStorage()._originalExchangeData = nil}

  /// The token account's mint
  public var mint: Code_Common_V1_SolanaAccountId {
    get {return _storage._mint ?? Code_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return _storage._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {_uniqueStorage()._mint = nil}

  /// Time the account was created, if available. For Code accounts, this is
  /// the time of intent submission. Otherwise, for external accounts, it is
  /// the tiem created on the blockchain.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// For REMOTE_SEND_GIFT_CARD, if requesting_owner was provided, was
  /// requesting_owner the issuer of the account.
  public var isGiftCardIssuer: Bool {
    get {return _storage._isGiftCardIssuer}
    set {_uniqueStorage()._isGiftCardIssuer = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum BalanceSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The account's balance could not be determined. This may be returned when
    /// the data source is unstable and a reliable balance cannot be determined.
    case unknown // = 0

    /// The account's balance was fetched directly from a finalized state on the
    /// blockchain.
    case blockchain // = 1

    /// The account's balance was calculated using cached values in Code. Accuracy
    /// is only guaranteed when management_state is LOCKED.
    case cache // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .blockchain
      case 2: self = .cache
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .blockchain: return 1
      case .cache: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_TokenAccountInfo.BalanceSource] = [
      .unknown,
      .blockchain,
      .cache,
    ]

  }

  public enum ManagementState: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The state of the account is unknown. This may be returned when the
    /// data source is unstable and a reliable state cannot be determined.
    case unknown // = 0

    /// Code does not maintain a management state and won't move funds for this
    /// account.
    case none // = 1

    /// The account is in the process of transitioning to the LOCKED state.
    case locking // = 2

    /// The account's funds are locked and Code has co-signing authority.
    case locked // = 3

    /// The account is in the process of transitioning to the UNLOCKED state.
    case unlocking // = 4

    /// The account's funds are unlocked and Code no longer has co-signing
    /// authority. The account must transition to the LOCKED state to have
    /// management capabilities.
    case unlocked // = 5

    /// The account is in the process of transitioning to the CLOSED state.
    case closing // = 6

    /// The account has been closed and doesn't exist on the blockchain.
    /// Subsequently, it also has a zero balance.
    case closed // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .locking
      case 3: self = .locked
      case 4: self = .unlocking
      case 5: self = .unlocked
      case 6: self = .closing
      case 7: self = .closed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .locking: return 2
      case .locked: return 3
      case .unlocking: return 4
      case .unlocked: return 5
      case .closing: return 6
      case .closed: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_TokenAccountInfo.ManagementState] = [
      .unknown,
      .none,
      .locking,
      .locked,
      .unlocking,
      .unlocked,
      .closing,
      .closed,
    ]

  }

  public enum BlockchainState: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The state of the account is unknown. This may be returned when the
    /// data source is unstable and a reliable state cannot be determined.
    case unknown // = 0

    /// The account does not exist on the blockchain.
    case doesNotExist // = 1

    /// The account is created and exists on the blockchain.
    case exists // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .doesNotExist
      case 2: self = .exists
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .doesNotExist: return 1
      case .exists: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_TokenAccountInfo.BlockchainState] = [
      .unknown,
      .doesNotExist,
      .exists,
    ]

  }

  public enum ClaimState: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The account doesn't have a concept of being claimed, or the state
    /// could not be fetched by server.
    case unknown // = 0

    /// The account has not yet been claimed.
    case notClaimed // = 1

    /// The account is claimed. Attempting to claim it will fail.
    case claimed // = 2

    /// The account hasn't been claimed, but is expired. Funds will move
    /// back to the issuer. Attempting to claim it will fail.
    case expired // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .notClaimed
      case 2: self = .claimed
      case 3: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .notClaimed: return 1
      case .claimed: return 2
      case .expired: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Code_Account_V1_TokenAccountInfo.ClaimState] = [
      .unknown,
      .notClaimed,
      .claimed,
      .expired,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "code.account.v1"

extension Code_Account_V1_IsCodeAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsCodeAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}owner\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_IsCodeAccountRequest, rhs: Code_Account_V1_IsCodeAccountRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_IsCodeAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsCodeAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_IsCodeAccountResponse, rhs: Code_Account_V1_IsCodeAccountResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_IsCodeAccountResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0\u{1}UNLOCKED_TIMELOCK_ACCOUNT\0")
}

extension Code_Account_V1_GetTokenAccountInfosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTokenAccountInfosRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}owner\0\u{1}signature\0\u{3}requesting_owner\0\u{3}requesting_owner_signature\0\u{4}\u{6}filter_by_token_address\0\u{3}filter_by_account_type\0\u{3}filter_by_mint_address\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requestingOwner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._requestingOwnerSignature) }()
      case 10: try {
        var v: Code_Common_V1_SolanaAccountId?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .filterByTokenAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .filterByTokenAddress(v)
        }
      }()
      case 11: try {
        var v: Code_Common_V1_AccountType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.filter != nil {try decoder.handleConflictingOneOf()}
          self.filter = .filterByAccountType(v)
        }
      }()
      case 12: try {
        var v: Code_Common_V1_SolanaAccountId?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .filterByMintAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .filterByMintAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requestingOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requestingOwnerSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.filter {
    case .filterByTokenAddress?: try {
      guard case .filterByTokenAddress(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .filterByAccountType?: try {
      guard case .filterByAccountType(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    }()
    case .filterByMintAddress?: try {
      guard case .filterByMintAddress(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_GetTokenAccountInfosRequest, rhs: Code_Account_V1_GetTokenAccountInfosRequest) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._requestingOwner != rhs._requestingOwner {return false}
    if lhs._requestingOwnerSignature != rhs._requestingOwnerSignature {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_GetTokenAccountInfosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTokenAccountInfosResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}token_account_infos\0\u{3}next_pool_index\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Account_V1_TokenAccountInfo>.self, value: &self.tokenAccountInfos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.nextPoolIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.tokenAccountInfos.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Code_Account_V1_TokenAccountInfo>.self, value: self.tokenAccountInfos, fieldNumber: 2)
    }
    if self.nextPoolIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.nextPoolIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_GetTokenAccountInfosResponse, rhs: Code_Account_V1_GetTokenAccountInfosResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.tokenAccountInfos != rhs.tokenAccountInfos {return false}
    if lhs.nextPoolIndex != rhs.nextPoolIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_GetTokenAccountInfosResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0")
}

extension Code_Account_V1_TokenAccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenAccountInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}owner\0\u{1}authority\0\u{3}account_type\0\u{1}index\0\u{3}balance_source\0\u{1}balance\0\u{3}management_state\0\u{3}blockchain_state\0\u{4}\u{2}claim_state\0\u{3}original_exchange_data\0\u{1}mint\0\u{4}\u{4}created_at\0\u{3}is_gift_card_issuer\0\u{c}\u{a}\u{1}\u{c}\u{10}\u{1}")

  fileprivate class _StorageClass {
    var _address: Code_Common_V1_SolanaAccountId? = nil
    var _owner: Code_Common_V1_SolanaAccountId? = nil
    var _authority: Code_Common_V1_SolanaAccountId? = nil
    var _accountType: Code_Common_V1_AccountType = .unknown
    var _index: UInt64 = 0
    var _balanceSource: Code_Account_V1_TokenAccountInfo.BalanceSource = .unknown
    var _balance: UInt64 = 0
    var _managementState: Code_Account_V1_TokenAccountInfo.ManagementState = .unknown
    var _blockchainState: Code_Account_V1_TokenAccountInfo.BlockchainState = .unknown
    var _claimState: Code_Account_V1_TokenAccountInfo.ClaimState = .unknown
    var _originalExchangeData: Code_Transaction_V2_ExchangeData? = nil
    var _mint: Code_Common_V1_SolanaAccountId? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isGiftCardIssuer: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _authority = source._authority
      _accountType = source._accountType
      _index = source._index
      _balanceSource = source._balanceSource
      _balance = source._balance
      _managementState = source._managementState
      _blockchainState = source._blockchainState
      _claimState = source._claimState
      _originalExchangeData = source._originalExchangeData
      _mint = source._mint
      _createdAt = source._createdAt
      _isGiftCardIssuer = source._isGiftCardIssuer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._authority) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._accountType) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._index) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._balanceSource) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._balance) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._managementState) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._blockchainState) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._claimState) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._originalExchangeData) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._mint) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isGiftCardIssuer) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._authority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._accountType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._accountType, fieldNumber: 4)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._index, fieldNumber: 5)
      }
      if _storage._balanceSource != .unknown {
        try visitor.visitSingularEnumField(value: _storage._balanceSource, fieldNumber: 6)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._balance, fieldNumber: 7)
      }
      if _storage._managementState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._managementState, fieldNumber: 8)
      }
      if _storage._blockchainState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._blockchainState, fieldNumber: 9)
      }
      if _storage._claimState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._claimState, fieldNumber: 11)
      }
      try { if let v = _storage._originalExchangeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._mint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._isGiftCardIssuer != false {
        try visitor.visitSingularBoolField(value: _storage._isGiftCardIssuer, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Code_Account_V1_TokenAccountInfo, rhs: Code_Account_V1_TokenAccountInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._authority != rhs_storage._authority {return false}
        if _storage._accountType != rhs_storage._accountType {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._balanceSource != rhs_storage._balanceSource {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._managementState != rhs_storage._managementState {return false}
        if _storage._blockchainState != rhs_storage._blockchainState {return false}
        if _storage._claimState != rhs_storage._claimState {return false}
        if _storage._originalExchangeData != rhs_storage._originalExchangeData {return false}
        if _storage._mint != rhs_storage._mint {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._isGiftCardIssuer != rhs_storage._isGiftCardIssuer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Code_Account_V1_TokenAccountInfo.BalanceSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BALANCE_SOURCE_UNKNOWN\0\u{1}BALANCE_SOURCE_BLOCKCHAIN\0\u{1}BALANCE_SOURCE_CACHE\0")
}

extension Code_Account_V1_TokenAccountInfo.ManagementState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MANAGEMENT_STATE_UNKNOWN\0\u{1}MANAGEMENT_STATE_NONE\0\u{1}MANAGEMENT_STATE_LOCKING\0\u{1}MANAGEMENT_STATE_LOCKED\0\u{1}MANAGEMENT_STATE_UNLOCKING\0\u{1}MANAGEMENT_STATE_UNLOCKED\0\u{1}MANAGEMENT_STATE_CLOSING\0\u{1}MANAGEMENT_STATE_CLOSED\0")
}

extension Code_Account_V1_TokenAccountInfo.BlockchainState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BLOCKCHAIN_STATE_UNKNOWN\0\u{1}BLOCKCHAIN_STATE_DOES_NOT_EXIST\0\u{1}BLOCKCHAIN_STATE_EXISTS\0")
}

extension Code_Account_V1_TokenAccountInfo.ClaimState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLAIM_STATE_UNKNOWN\0\u{1}CLAIM_STATE_NOT_CLAIMED\0\u{1}CLAIM_STATE_CLAIMED\0\u{1}CLAIM_STATE_EXPIRED\0")
}
