// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: currency/v1/currency_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocp_Currency_V1_GetAllRatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If timestamp is included, the returned rate will be the most recent available
  /// exchange rate prior to the provided timestamp within the same day. Otherwise,
  /// the latest rates will be returned.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocp_Currency_V1_GetAllRatesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Currency_V1_GetAllRatesResponse.Result = .ok

  /// The time the exchange rates were observed
  public var asOf: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _asOf ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_asOf = newValue}
  }
  /// Returns true if `asOf` has been explicitly set.
  public var hasAsOf: Bool {return self._asOf != nil}
  /// Clears the value of `asOf`. Subsequent reads from it will return its default value.
  public mutating func clearAsOf() {self._asOf = nil}

  /// The price of 1 core mint token in different currencies, keyed on 3- or 4-
  /// letter lowercase currency code.
  public var rates: Dictionary<String,Double> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0

    /// No currency data is available for the requested timestamp.
    case missingData // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .missingData
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .missingData: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Currency_V1_GetAllRatesResponse.Result] = [
      .ok,
      .missingData,
    ]

  }

  public init() {}

  fileprivate var _asOf: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocp_Currency_V1_GetMintsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addresses: [Ocp_Common_V1_SolanaAccountId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocp_Currency_V1_GetMintsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Currency_V1_GetMintsResponse.Result = .ok

  public var metadataByAddress: Dictionary<String,Ocp_Currency_V1_Mint> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Currency_V1_GetMintsResponse.Result] = [
      .ok,
      .notFound,
    ]

  }

  public init() {}
}

public struct Ocp_Currency_V1_GetHistoricalMintDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mint address to get historical data for
  public var address: Ocp_Common_V1_SolanaAccountId {
    get {return _address ?? Ocp_Common_V1_SolanaAccountId()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// The currency code for the returned market data (e.g., "usd")
  public var currencyCode: String = String()

  public var range: Ocp_Currency_V1_GetHistoricalMintDataRequest.OneOf_Range? = nil

  public var predefinedRange: Ocp_Currency_V1_GetHistoricalMintDataRequest.PredefinedRange {
    get {
      if case .predefinedRange(let v)? = range {return v}
      return .allTime
    }
    set {range = .predefinedRange(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Range: Equatable, Sendable {
    case predefinedRange(Ocp_Currency_V1_GetHistoricalMintDataRequest.PredefinedRange)

  }

  public enum PredefinedRange: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case allTime // = 0
    case lastDay // = 1
    case lastWeek // = 2
    case lastMonth // = 3
    case lastYear // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .allTime
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allTime
      case 1: self = .lastDay
      case 2: self = .lastWeek
      case 3: self = .lastMonth
      case 4: self = .lastYear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allTime: return 0
      case .lastDay: return 1
      case .lastWeek: return 2
      case .lastMonth: return 3
      case .lastYear: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Currency_V1_GetHistoricalMintDataRequest.PredefinedRange] = [
      .allTime,
      .lastDay,
      .lastWeek,
      .lastMonth,
      .lastYear,
    ]

  }

  public init() {}

  fileprivate var _address: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Currency_V1_GetHistoricalMintDataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Ocp_Currency_V1_GetHistoricalMintDataResponse.Result = .ok

  public var data: [Ocp_Currency_V1_HistoricalMintData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case ok // = 0

    /// The requested mint or currency was not found
    case notFound // = 1

    /// No data available for the requested time range
    case missingData // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .missingData
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .missingData: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ocp_Currency_V1_GetHistoricalMintDataResponse.Result] = [
      .ok,
      .notFound,
      .missingData,
    ]

  }

  public init() {}
}

public struct Ocp_Currency_V1_StreamLiveMintDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocp_Currency_V1_StreamLiveMintDataRequest.OneOf_Type? = nil

  public var request: Ocp_Currency_V1_StreamLiveMintDataRequest.Request {
    get {
      if case .request(let v)? = type {return v}
      return Ocp_Currency_V1_StreamLiveMintDataRequest.Request()
    }
    set {type = .request(newValue)}
  }

  public var pong: Ocp_Common_V1_ClientPong {
    get {
      if case .pong(let v)? = type {return v}
      return Ocp_Common_V1_ClientPong()
    }
    set {type = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case request(Ocp_Currency_V1_StreamLiveMintDataRequest.Request)
    case pong(Ocp_Common_V1_ClientPong)

  }

  public struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of mints to receive live data against. To update the set of mints,
    /// close the current stream and open a new one with the new set.
    public var mints: [Ocp_Common_V1_SolanaAccountId] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Ocp_Currency_V1_StreamLiveMintDataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocp_Currency_V1_StreamLiveMintDataResponse.OneOf_Type? = nil

  public var data: Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData {
    get {
      if case .data(let v)? = type {return v}
      return Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData()
    }
    set {type = .data(newValue)}
  }

  public var ping: Ocp_Common_V1_ServerPing {
    get {
      if case .ping(let v)? = type {return v}
      return Ocp_Common_V1_ServerPing()
    }
    set {type = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case data(Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData)
    case ping(Ocp_Common_V1_ServerPing)

  }

  public struct LiveData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData.OneOf_Type? = nil

    public var coreMintFiatExchangeRates: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch {
      get {
        if case .coreMintFiatExchangeRates(let v)? = type {return v}
        return Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch()
      }
      set {type = .coreMintFiatExchangeRates(newValue)}
    }

    public var launchpadCurrencyReserveStates: Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch {
      get {
        if case .launchpadCurrencyReserveStates(let v)? = type {return v}
        return Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch()
      }
      set {type = .launchpadCurrencyReserveStates(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Type: Equatable, Sendable {
      case coreMintFiatExchangeRates(Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch)
      case launchpadCurrencyReserveStates(Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch)

    }

    public init() {}
  }

  public init() {}
}

public struct Ocp_Currency_V1_Mint: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token mint address
  public var address: Ocp_Common_V1_SolanaAccountId {
    get {return _storage._address ?? Ocp_Common_V1_SolanaAccountId()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// The number of decimals configured for the mint
  public var decimals: UInt32 {
    get {return _storage._decimals}
    set {_uniqueStorage()._decimals = newValue}
  }

  /// Currency name
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Currency ticker symbol
  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  /// Currency description
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// URL to currency image
  public var imageURL: String {
    get {return _storage._imageURL}
    set {_uniqueStorage()._imageURL = newValue}
  }

  /// Available when a VM exists for the given mint, and can be used for deriving
  /// VM deposit PDAs
  ///
  /// Note: Only currencies with a VM are useable for payments
  public var vmMetadata: Ocp_Currency_V1_VmMetadata {
    get {return _storage._vmMetadata ?? Ocp_Currency_V1_VmMetadata()}
    set {_uniqueStorage()._vmMetadata = newValue}
  }
  /// Returns true if `vmMetadata` has been explicitly set.
  public var hasVmMetadata: Bool {return _storage._vmMetadata != nil}
  /// Clears the value of `vmMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVmMetadata() {_uniqueStorage()._vmMetadata = nil}

  /// Available when created by the launchpad via the currency creator program, and
  /// can be used for calculating price, market cap, etc. based on the exponential
  /// bonding curve
  public var launchpadMetadata: Ocp_Currency_V1_LaunchpadMetadata {
    get {return _storage._launchpadMetadata ?? Ocp_Currency_V1_LaunchpadMetadata()}
    set {_uniqueStorage()._launchpadMetadata = newValue}
  }
  /// Returns true if `launchpadMetadata` has been explicitly set.
  public var hasLaunchpadMetadata: Bool {return _storage._launchpadMetadata != nil}
  /// Clears the value of `launchpadMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearLaunchpadMetadata() {_uniqueStorage()._launchpadMetadata = nil}

  /// Timestamp the currency was created
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocp_Currency_V1_VmMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VM address
  public var vm: Ocp_Common_V1_SolanaAccountId {
    get {return _vm ?? Ocp_Common_V1_SolanaAccountId()}
    set {_vm = newValue}
  }
  /// Returns true if `vm` has been explicitly set.
  public var hasVm: Bool {return self._vm != nil}
  /// Clears the value of `vm`. Subsequent reads from it will return its default value.
  public mutating func clearVm() {self._vm = nil}

  /// Authority that subsidizes and authorizes all transactions against the VM
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// Lock duration of Virtual Timelock Accounts on the VM, currently hardcoded
  /// to 21 days
  public var lockDurationInDays: UInt32 = 0

  /// VM omnibus address
  public var omnibus: Ocp_Common_V1_SolanaAccountId {
    get {return _omnibus ?? Ocp_Common_V1_SolanaAccountId()}
    set {_omnibus = newValue}
  }
  /// Returns true if `omnibus` has been explicitly set.
  public var hasOmnibus: Bool {return self._omnibus != nil}
  /// Clears the value of `omnibus`. Subsequent reads from it will return its default value.
  public mutating func clearOmnibus() {self._omnibus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vm: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _omnibus: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Currency_V1_LaunchpadMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address of the currency config
  public var currencyConfig: Ocp_Common_V1_SolanaAccountId {
    get {return _currencyConfig ?? Ocp_Common_V1_SolanaAccountId()}
    set {_currencyConfig = newValue}
  }
  /// Returns true if `currencyConfig` has been explicitly set.
  public var hasCurrencyConfig: Bool {return self._currencyConfig != nil}
  /// Clears the value of `currencyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCurrencyConfig() {self._currencyConfig = nil}

  /// The address of the liquidity pool
  public var liquidityPool: Ocp_Common_V1_SolanaAccountId {
    get {return _liquidityPool ?? Ocp_Common_V1_SolanaAccountId()}
    set {_liquidityPool = newValue}
  }
  /// Returns true if `liquidityPool` has been explicitly set.
  public var hasLiquidityPool: Bool {return self._liquidityPool != nil}
  /// Clears the value of `liquidityPool`. Subsequent reads from it will return its default value.
  public mutating func clearLiquidityPool() {self._liquidityPool = nil}

  /// The random seed used during currency creation
  public var seed: Ocp_Common_V1_SolanaAccountId {
    get {return _seed ?? Ocp_Common_V1_SolanaAccountId()}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  public var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  public mutating func clearSeed() {self._seed = nil}

  /// The address of the authority for the currency
  public var authority: Ocp_Common_V1_SolanaAccountId {
    get {return _authority ?? Ocp_Common_V1_SolanaAccountId()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  /// The address where this mint's tokens are locked against the liquidity pool
  public var mintVault: Ocp_Common_V1_SolanaAccountId {
    get {return _mintVault ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mintVault = newValue}
  }
  /// Returns true if `mintVault` has been explicitly set.
  public var hasMintVault: Bool {return self._mintVault != nil}
  /// Clears the value of `mintVault`. Subsequent reads from it will return its default value.
  public mutating func clearMintVault() {self._mintVault = nil}

  /// The address where core mint tokens are locked against the liquidity pool
  public var coreMintVault: Ocp_Common_V1_SolanaAccountId {
    get {return _coreMintVault ?? Ocp_Common_V1_SolanaAccountId()}
    set {_coreMintVault = newValue}
  }
  /// Returns true if `coreMintVault` has been explicitly set.
  public var hasCoreMintVault: Bool {return self._coreMintVault != nil}
  /// Clears the value of `coreMintVault`. Subsequent reads from it will return its default value.
  public mutating func clearCoreMintVault() {self._coreMintVault = nil}

  /// Current circulating mint token supply in quarks
  ///
  /// Deprecated: Use supply value from StreamLiveMintData
  public var supplyFromBonding: UInt64 = 0

  /// Precent fee for sells in basis points, currently hardcoded to 1%
  public var sellFeeBps: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currencyConfig: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _liquidityPool: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _seed: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _authority: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _mintVault: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _coreMintVault: Ocp_Common_V1_SolanaAccountId? = nil
}

public struct Ocp_Currency_V1_HistoricalMintData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp for this data point
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Market capitalization at this point in time
  public var marketCap: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocp_Currency_V1_CoreMintFiatExchangeRate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The currency code for the fiat exchange rate
  public var currencyCode: String = String()

  /// The exchange rate against the core mint
  public var exchangeRate: Double = 0

  /// Timestamp for this data point
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// CoreMintFiatExchangeRate with a server signature for proof for use in a payment
public struct Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeRate: Ocp_Currency_V1_CoreMintFiatExchangeRate {
    get {return _exchangeRate ?? Ocp_Currency_V1_CoreMintFiatExchangeRate()}
    set {_exchangeRate = newValue}
  }
  /// Returns true if `exchangeRate` has been explicitly set.
  public var hasExchangeRate: Bool {return self._exchangeRate != nil}
  /// Clears the value of `exchangeRate`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeRate() {self._exchangeRate = nil}

  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exchangeRate: Ocp_Currency_V1_CoreMintFiatExchangeRate? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeRates: [Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocp_Currency_V1_LaunchpadCurrencyReserveState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Launchpad currency mint address
  public var mint: Ocp_Common_V1_SolanaAccountId {
    get {return _mint ?? Ocp_Common_V1_SolanaAccountId()}
    set {_mint = newValue}
  }
  /// Returns true if `mint` has been explicitly set.
  public var hasMint: Bool {return self._mint != nil}
  /// Clears the value of `mint`. Subsequent reads from it will return its default value.
  public mutating func clearMint() {self._mint = nil}

  /// Current circulating mint token supply in quarks
  public var supplyFromBonding: UInt64 = 0

  /// Timestamp for this data point
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mint: Ocp_Common_V1_SolanaAccountId? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// LaunchpadCurrencyReserveState with a server signature for proof for use in a payment
public struct Ocp_Currency_V1_VerifiedLaunchpadCurrencyReserveState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reserveState: Ocp_Currency_V1_LaunchpadCurrencyReserveState {
    get {return _reserveState ?? Ocp_Currency_V1_LaunchpadCurrencyReserveState()}
    set {_reserveState = newValue}
  }
  /// Returns true if `reserveState` has been explicitly set.
  public var hasReserveState: Bool {return self._reserveState != nil}
  /// Clears the value of `reserveState`. Subsequent reads from it will return its default value.
  public mutating func clearReserveState() {self._reserveState = nil}

  public var signature: Ocp_Common_V1_Signature {
    get {return _signature ?? Ocp_Common_V1_Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reserveState: Ocp_Currency_V1_LaunchpadCurrencyReserveState? = nil
  fileprivate var _signature: Ocp_Common_V1_Signature? = nil
}

public struct Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reserveStates: [Ocp_Currency_V1_VerifiedLaunchpadCurrencyReserveState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocp.currency.v1"

extension Ocp_Currency_V1_GetAllRatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllRatesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetAllRatesRequest, rhs: Ocp_Currency_V1_GetAllRatesRequest) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetAllRatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllRatesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}as_of\0\u{1}rates\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asOf) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.rates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._asOf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.rates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.rates, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetAllRatesResponse, rhs: Ocp_Currency_V1_GetAllRatesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._asOf != rhs._asOf {return false}
    if lhs.rates != rhs.rates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetAllRatesResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}MISSING_DATA\0")
}

extension Ocp_Currency_V1_GetMintsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMintsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}addresses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetMintsRequest, rhs: Ocp_Currency_V1_GetMintsRequest) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetMintsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMintsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}metadata_by_address\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocp_Currency_V1_Mint>.self, value: &self.metadataByAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.metadataByAddress.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocp_Currency_V1_Mint>.self, value: self.metadataByAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetMintsResponse, rhs: Ocp_Currency_V1_GetMintsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.metadataByAddress != rhs.metadataByAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetMintsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0")
}

extension Ocp_Currency_V1_GetHistoricalMintDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetHistoricalMintDataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{3}currency_code\0\u{3}predefined_range\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try {
        var v: Ocp_Currency_V1_GetHistoricalMintDataRequest.PredefinedRange?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.range != nil {try decoder.handleConflictingOneOf()}
          self.range = .predefinedRange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    try { if case .predefinedRange(let v)? = self.range {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetHistoricalMintDataRequest, rhs: Ocp_Currency_V1_GetHistoricalMintDataRequest) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.range != rhs.range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetHistoricalMintDataRequest.PredefinedRange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ALL_TIME\0\u{1}LAST_DAY\0\u{1}LAST_WEEK\0\u{1}LAST_MONTH\0\u{1}LAST_YEAR\0")
}

extension Ocp_Currency_V1_GetHistoricalMintDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetHistoricalMintDataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_GetHistoricalMintDataResponse, rhs: Ocp_Currency_V1_GetHistoricalMintDataResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_GetHistoricalMintDataResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}NOT_FOUND\0\u{1}MISSING_DATA\0")
}

extension Ocp_Currency_V1_StreamLiveMintDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamLiveMintDataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}request\0\u{1}pong\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Currency_V1_StreamLiveMintDataRequest.Request?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .request(v)
        }
      }()
      case 2: try {
        var v: Ocp_Common_V1_ClientPong?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .request?: try {
      guard case .request(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_StreamLiveMintDataRequest, rhs: Ocp_Currency_V1_StreamLiveMintDataRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_StreamLiveMintDataRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Currency_V1_StreamLiveMintDataRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mints\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_StreamLiveMintDataRequest.Request, rhs: Ocp_Currency_V1_StreamLiveMintDataRequest.Request) -> Bool {
    if lhs.mints != rhs.mints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_StreamLiveMintDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamLiveMintDataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0\u{1}ping\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .data(v)
        }
      }()
      case 2: try {
        var v: Ocp_Common_V1_ServerPing?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .data?: try {
      guard case .data(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_StreamLiveMintDataResponse, rhs: Ocp_Currency_V1_StreamLiveMintDataResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ocp_Currency_V1_StreamLiveMintDataResponse.protoMessageName + ".LiveData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}core_mint_fiat_exchange_rates\0\u{3}launchpad_currency_reserve_states\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .coreMintFiatExchangeRates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .coreMintFiatExchangeRates(v)
        }
      }()
      case 2: try {
        var v: Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .launchpadCurrencyReserveStates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .launchpadCurrencyReserveStates(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .coreMintFiatExchangeRates?: try {
      guard case .coreMintFiatExchangeRates(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .launchpadCurrencyReserveStates?: try {
      guard case .launchpadCurrencyReserveStates(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData, rhs: Ocp_Currency_V1_StreamLiveMintDataResponse.LiveData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_Mint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mint"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}decimals\0\u{1}name\0\u{1}symbol\0\u{1}description\0\u{3}image_url\0\u{3}vm_metadata\0\u{3}launchpad_metadata\0\u{3}created_at\0")

  fileprivate class _StorageClass {
    var _address: Ocp_Common_V1_SolanaAccountId? = nil
    var _decimals: UInt32 = 0
    var _name: String = String()
    var _symbol: String = String()
    var _description_p: String = String()
    var _imageURL: String = String()
    var _vmMetadata: Ocp_Currency_V1_VmMetadata? = nil
    var _launchpadMetadata: Ocp_Currency_V1_LaunchpadMetadata? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _decimals = source._decimals
      _name = source._name
      _symbol = source._symbol
      _description_p = source._description_p
      _imageURL = source._imageURL
      _vmMetadata = source._vmMetadata
      _launchpadMetadata = source._launchpadMetadata
      _createdAt = source._createdAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._decimals) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._symbol) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._imageURL) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._vmMetadata) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._launchpadMetadata) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._decimals != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._decimals, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._imageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageURL, fieldNumber: 6)
      }
      try { if let v = _storage._vmMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._launchpadMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_Mint, rhs: Ocp_Currency_V1_Mint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._decimals != rhs_storage._decimals {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._imageURL != rhs_storage._imageURL {return false}
        if _storage._vmMetadata != rhs_storage._vmMetadata {return false}
        if _storage._launchpadMetadata != rhs_storage._launchpadMetadata {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_VmMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VmMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vm\0\u{1}authority\0\u{3}lock_duration_in_days\0\u{1}omnibus\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vm) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.lockDurationInDays) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._omnibus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.lockDurationInDays != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockDurationInDays, fieldNumber: 3)
    }
    try { if let v = self._omnibus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_VmMetadata, rhs: Ocp_Currency_V1_VmMetadata) -> Bool {
    if lhs._vm != rhs._vm {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs.lockDurationInDays != rhs.lockDurationInDays {return false}
    if lhs._omnibus != rhs._omnibus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_LaunchpadMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchpadMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}currency_config\0\u{3}liquidity_pool\0\u{1}seed\0\u{1}authority\0\u{3}mint_vault\0\u{3}core_mint_vault\0\u{3}supply_from_bonding\0\u{3}sell_fee_bps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currencyConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._liquidityPool) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._seed) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mintVault) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._coreMintVault) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.supplyFromBonding) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.sellFeeBps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currencyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._liquidityPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._seed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mintVault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._coreMintVault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.supplyFromBonding != 0 {
      try visitor.visitSingularUInt64Field(value: self.supplyFromBonding, fieldNumber: 7)
    }
    if self.sellFeeBps != 0 {
      try visitor.visitSingularUInt32Field(value: self.sellFeeBps, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_LaunchpadMetadata, rhs: Ocp_Currency_V1_LaunchpadMetadata) -> Bool {
    if lhs._currencyConfig != rhs._currencyConfig {return false}
    if lhs._liquidityPool != rhs._liquidityPool {return false}
    if lhs._seed != rhs._seed {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs._mintVault != rhs._mintVault {return false}
    if lhs._coreMintVault != rhs._coreMintVault {return false}
    if lhs.supplyFromBonding != rhs.supplyFromBonding {return false}
    if lhs.sellFeeBps != rhs.sellFeeBps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_HistoricalMintData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricalMintData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}market_cap\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.marketCap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.marketCap.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.marketCap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_HistoricalMintData, rhs: Ocp_Currency_V1_HistoricalMintData) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.marketCap != rhs.marketCap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_CoreMintFiatExchangeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoreMintFiatExchangeRate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}currency_code\0\u{3}exchange_rate\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.exchangeRate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 1)
    }
    if self.exchangeRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.exchangeRate, fieldNumber: 2)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_CoreMintFiatExchangeRate, rhs: Ocp_Currency_V1_CoreMintFiatExchangeRate) -> Bool {
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedCoreMintFiatExchangeRate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}exchange_rate\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._exchangeRate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exchangeRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRate, rhs: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRate) -> Bool {
    if lhs._exchangeRate != rhs._exchangeRate {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedCoreMintFiatExchangeRateBatch"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}exchange_rates\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.exchangeRates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeRates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exchangeRates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch, rhs: Ocp_Currency_V1_VerifiedCoreMintFiatExchangeRateBatch) -> Bool {
    if lhs.exchangeRates != rhs.exchangeRates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_LaunchpadCurrencyReserveState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchpadCurrencyReserveState"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mint\0\u{3}supply_from_bonding\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mint) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.supplyFromBonding) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.supplyFromBonding != 0 {
      try visitor.visitSingularUInt64Field(value: self.supplyFromBonding, fieldNumber: 2)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_LaunchpadCurrencyReserveState, rhs: Ocp_Currency_V1_LaunchpadCurrencyReserveState) -> Bool {
    if lhs._mint != rhs._mint {return false}
    if lhs.supplyFromBonding != rhs.supplyFromBonding {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_VerifiedLaunchpadCurrencyReserveState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedLaunchpadCurrencyReserveState"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reserve_state\0\u{1}signature\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reserveState) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reserveState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_VerifiedLaunchpadCurrencyReserveState, rhs: Ocp_Currency_V1_VerifiedLaunchpadCurrencyReserveState) -> Bool {
    if lhs._reserveState != rhs._reserveState {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifiedLaunchapdCurrencyReserveStateBatch"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}reserve_states\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reserveStates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reserveStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reserveStates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch, rhs: Ocp_Currency_V1_VerifiedLaunchapdCurrencyReserveStateBatch) -> Bool {
    if lhs.reserveStates != rhs.reserveStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
