// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: activity/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ActivityFeedType enables multiple activity feeds, where notifications may be
/// split across different parts of the app
public enum Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// Activity feed displayed under the Balance tab
  case transactionHistory // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .transactionHistory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .transactionHistory: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_ActivityFeedType] = [
    .unknown,
    .transactionHistory,
  ]

}

/// NotificationState determines the mutability of a notification, and whether
/// client should attempt to refetch state.
public enum Flipcash_Activity_V1_NotificationState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// Notification state will change based on some app action in the future
  case pending // = 1

  /// Notification state will not change
  case completed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .completed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_NotificationState] = [
    .unknown,
    .pending,
    .completed,
  ]

}

/// The ID of the notification
public struct Flipcash_Activity_V1_NotificationId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Notification is a message that is displayed in an activity feed
public struct Flipcash_Activity_V1_Notification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this notification
  public var id: Flipcash_Activity_V1_NotificationId {
    get {return _id ?? Flipcash_Activity_V1_NotificationId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The localized title text for the notification
  public var localizedText: String = String()

  /// If a payment applies, the amount that was paid
  public var paymentAmount: Flipcash_Common_V1_CryptoPaymentAmount {
    get {return _paymentAmount ?? Flipcash_Common_V1_CryptoPaymentAmount()}
    set {_paymentAmount = newValue}
  }
  /// Returns true if `paymentAmount` has been explicitly set.
  public var hasPaymentAmount: Bool {return self._paymentAmount != nil}
  /// Clears the value of `paymentAmount`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentAmount() {self._paymentAmount = nil}

  /// The timestamp of this notification
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// The state of this notification
  public var state: Flipcash_Activity_V1_NotificationState = .unknown

  /// Additional metadata for this notification specific to the notification
  public var additionalMetadata: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata? = nil

  public var welcomeBonus: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata {
    get {
      if case .welcomeBonus(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WelcomeBonusNotificationMetadata()
    }
    set {additionalMetadata = .welcomeBonus(newValue)}
  }

  public var gaveCrypto: Flipcash_Activity_V1_GaveCryptoNotificationMetadata {
    get {
      if case .gaveCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_GaveCryptoNotificationMetadata()
    }
    set {additionalMetadata = .gaveCrypto(newValue)}
  }

  public var receivedCrypto: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata {
    get {
      if case .receivedCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata()
    }
    set {additionalMetadata = .receivedCrypto(newValue)}
  }

  public var withdrewCrypto: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata {
    get {
      if case .withdrewCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata()
    }
    set {additionalMetadata = .withdrewCrypto(newValue)}
  }

  public var sentCrypto: Flipcash_Activity_V1_SentCryptoNotificationMetadata {
    get {
      if case .sentCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_SentCryptoNotificationMetadata()
    }
    set {additionalMetadata = .sentCrypto(newValue)}
  }

  public var depositedCrypto: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata {
    get {
      if case .depositedCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_DepositedCryptoNotificationMetadata()
    }
    set {additionalMetadata = .depositedCrypto(newValue)}
  }

  public var boughtCrypto: Flipcash_Activity_V1_BoughtCryptoNotificationMetadata {
    get {
      if case .boughtCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_BoughtCryptoNotificationMetadata()
    }
    set {additionalMetadata = .boughtCrypto(newValue)}
  }

  public var soldCrypto: Flipcash_Activity_V1_SoldCryptoNotificationMetadata {
    get {
      if case .soldCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_SoldCryptoNotificationMetadata()
    }
    set {additionalMetadata = .soldCrypto(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Additional metadata for this notification specific to the notification
  public enum OneOf_AdditionalMetadata: Equatable, Sendable {
    case welcomeBonus(Flipcash_Activity_V1_WelcomeBonusNotificationMetadata)
    case gaveCrypto(Flipcash_Activity_V1_GaveCryptoNotificationMetadata)
    case receivedCrypto(Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata)
    case withdrewCrypto(Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata)
    case sentCrypto(Flipcash_Activity_V1_SentCryptoNotificationMetadata)
    case depositedCrypto(Flipcash_Activity_V1_DepositedCryptoNotificationMetadata)
    case boughtCrypto(Flipcash_Activity_V1_BoughtCryptoNotificationMetadata)
    case soldCrypto(Flipcash_Activity_V1_SoldCryptoNotificationMetadata)

  }

  public init() {}

  fileprivate var _id: Flipcash_Activity_V1_NotificationId? = nil
  fileprivate var _paymentAmount: Flipcash_Common_V1_CryptoPaymentAmount? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_GaveCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_SentCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vault of the gift card account that was created for the cash link
  public var vault: Flipcash_Common_V1_PublicKey {
    get {return _vault ?? Flipcash_Common_V1_PublicKey()}
    set {_vault = newValue}
  }
  /// Returns true if `vault` has been explicitly set.
  public var hasVault: Bool {return self._vault != nil}
  /// Clears the value of `vault`. Subsequent reads from it will return its default value.
  public mutating func clearVault() {self._vault = nil}

  /// Whether the cancel action can be initiated by the user
  public var canInitiateCancelAction: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vault: Flipcash_Common_V1_PublicKey? = nil
}

public struct Flipcash_Activity_V1_DepositedCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_BoughtCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_SoldCryptoNotificationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipcash.activity.v1"

extension Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}TRANSACTION_HISTORY\0")
}

extension Flipcash_Activity_V1_NotificationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOTIFICATION_STATE_UNKNOWN\0\u{1}NOTIFICATION_STATE_PENDING\0\u{1}NOTIFICATION_STATE_COMPLETED\0")
}

extension Flipcash_Activity_V1_NotificationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_NotificationId, rhs: Flipcash_Activity_V1_NotificationId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}localized_text\0\u{3}payment_amount\0\u{1}ts\0\u{1}state\0\u{3}welcome_bonus\0\u{3}gave_crypto\0\u{3}received_crypto\0\u{3}withdrew_crypto\0\u{3}sent_crypto\0\u{3}deposited_crypto\0\u{3}bought_crypto\0\u{3}sold_crypto\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localizedText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 6: try {
        var v: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .welcomeBonus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .welcomeBonus(v)
        }
      }()
      case 7: try {
        var v: Flipcash_Activity_V1_GaveCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .gaveCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .gaveCrypto(v)
        }
      }()
      case 8: try {
        var v: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .receivedCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .receivedCrypto(v)
        }
      }()
      case 9: try {
        var v: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .withdrewCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .withdrewCrypto(v)
        }
      }()
      case 10: try {
        var v: Flipcash_Activity_V1_SentCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .sentCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .sentCrypto(v)
        }
      }()
      case 11: try {
        var v: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .depositedCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .depositedCrypto(v)
        }
      }()
      case 12: try {
        var v: Flipcash_Activity_V1_BoughtCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .boughtCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .boughtCrypto(v)
        }
      }()
      case 13: try {
        var v: Flipcash_Activity_V1_SoldCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .soldCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .soldCrypto(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.localizedText.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedText, fieldNumber: 2)
    }
    try { if let v = self._paymentAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    switch self.additionalMetadata {
    case .welcomeBonus?: try {
      guard case .welcomeBonus(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .gaveCrypto?: try {
      guard case .gaveCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .receivedCrypto?: try {
      guard case .receivedCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .withdrewCrypto?: try {
      guard case .withdrewCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .sentCrypto?: try {
      guard case .sentCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .depositedCrypto?: try {
      guard case .depositedCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .boughtCrypto?: try {
      guard case .boughtCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .soldCrypto?: try {
      guard case .soldCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_Notification, rhs: Flipcash_Activity_V1_Notification) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.localizedText != rhs.localizedText {return false}
    if lhs._paymentAmount != rhs._paymentAmount {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.state != rhs.state {return false}
    if lhs.additionalMetadata != rhs.additionalMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeBonusNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata, rhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_GaveCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GaveCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_GaveCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_GaveCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivedCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrewCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_SentCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vault\0\u{3}can_initiate_cancel_action\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vault) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canInitiateCancelAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.canInitiateCancelAction != false {
      try visitor.visitSingularBoolField(value: self.canInitiateCancelAction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_SentCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_SentCryptoNotificationMetadata) -> Bool {
    if lhs._vault != rhs._vault {return false}
    if lhs.canInitiateCancelAction != rhs.canInitiateCancelAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DepositedCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositedCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_BoughtCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoughtCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_BoughtCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_BoughtCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_SoldCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoldCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_SoldCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_SoldCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
