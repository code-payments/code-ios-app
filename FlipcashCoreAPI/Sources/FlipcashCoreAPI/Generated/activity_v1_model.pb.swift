// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: activity/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ActivityFeedType enables multiple activity feeds, where notifications may be
/// split across different parts of the app
public enum Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Activity feed displayed under the Balance tab
  case transactionHistory // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .transactionHistory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .transactionHistory: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipcash_Activity_V1_ActivityFeedType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_ActivityFeedType] = [
    .unknown,
    .transactionHistory,
  ]
}

#endif  // swift(>=4.2)

/// NotificationState determines the mutability of a notification, and whether
/// client should attempt to refetch state.
public enum Flipcash_Activity_V1_NotificationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Notification state will change based on some app action in the future
  case pending // = 1

  /// Notification state will not change
  case completed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .completed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipcash_Activity_V1_NotificationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_NotificationState] = [
    .unknown,
    .pending,
    .completed,
  ]
}

#endif  // swift(>=4.2)

/// The ID of the notification
public struct Flipcash_Activity_V1_NotificationId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Notification is a message that is displayed in an activity feed
public struct Flipcash_Activity_V1_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this notification
  public var id: Flipcash_Activity_V1_NotificationId {
    get {return _id ?? Flipcash_Activity_V1_NotificationId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The localized title text for the notification
  public var localizedText: String = String()

  /// If a payment applies, the amount that was paid
  public var paymentAmount: Flipcash_Common_V1_CryptoPaymentAmount {
    get {return _paymentAmount ?? Flipcash_Common_V1_CryptoPaymentAmount()}
    set {_paymentAmount = newValue}
  }
  /// Returns true if `paymentAmount` has been explicitly set.
  public var hasPaymentAmount: Bool {return self._paymentAmount != nil}
  /// Clears the value of `paymentAmount`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentAmount() {self._paymentAmount = nil}

  /// The timestamp of this notification
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// The state of this notification
  public var state: Flipcash_Activity_V1_NotificationState = .unknown

  /// Additional metadata for this notification specific to the notification
  public var additionalMetadata: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata? = nil

  public var welcomeBonus: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata {
    get {
      if case .welcomeBonus(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WelcomeBonusNotificationMetadata()
    }
    set {additionalMetadata = .welcomeBonus(newValue)}
  }

  public var gaveCrypto: Flipcash_Activity_V1_GaveCryptoNotificationMetadata {
    get {
      if case .gaveCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_GaveCryptoNotificationMetadata()
    }
    set {additionalMetadata = .gaveCrypto(newValue)}
  }

  public var receivedCrypto: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata {
    get {
      if case .receivedCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata()
    }
    set {additionalMetadata = .receivedCrypto(newValue)}
  }

  public var withdrewCrypto: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata {
    get {
      if case .withdrewCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata()
    }
    set {additionalMetadata = .withdrewCrypto(newValue)}
  }

  public var sentCrypto: Flipcash_Activity_V1_SentCryptoNotificationMetadata {
    get {
      if case .sentCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_SentCryptoNotificationMetadata()
    }
    set {additionalMetadata = .sentCrypto(newValue)}
  }

  public var depositedCrypto: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata {
    get {
      if case .depositedCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_DepositedCryptoNotificationMetadata()
    }
    set {additionalMetadata = .depositedCrypto(newValue)}
  }

  public var paidCrypto: Flipcash_Activity_V1_PaidCryptoNotificationMetadata {
    get {
      if case .paidCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_PaidCryptoNotificationMetadata()
    }
    set {additionalMetadata = .paidCrypto(newValue)}
  }

  public var distributedCrypto: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata {
    get {
      if case .distributedCrypto(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_DistributedCryptoNotificationMetadata()
    }
    set {additionalMetadata = .distributedCrypto(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Additional metadata for this notification specific to the notification
  public enum OneOf_AdditionalMetadata: Equatable {
    case welcomeBonus(Flipcash_Activity_V1_WelcomeBonusNotificationMetadata)
    case gaveCrypto(Flipcash_Activity_V1_GaveCryptoNotificationMetadata)
    case receivedCrypto(Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata)
    case withdrewCrypto(Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata)
    case sentCrypto(Flipcash_Activity_V1_SentCryptoNotificationMetadata)
    case depositedCrypto(Flipcash_Activity_V1_DepositedCryptoNotificationMetadata)
    case paidCrypto(Flipcash_Activity_V1_PaidCryptoNotificationMetadata)
    case distributedCrypto(Flipcash_Activity_V1_DistributedCryptoNotificationMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata, rhs: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.welcomeBonus, .welcomeBonus): return {
        guard case .welcomeBonus(let l) = lhs, case .welcomeBonus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gaveCrypto, .gaveCrypto): return {
        guard case .gaveCrypto(let l) = lhs, case .gaveCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receivedCrypto, .receivedCrypto): return {
        guard case .receivedCrypto(let l) = lhs, case .receivedCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withdrewCrypto, .withdrewCrypto): return {
        guard case .withdrewCrypto(let l) = lhs, case .withdrewCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sentCrypto, .sentCrypto): return {
        guard case .sentCrypto(let l) = lhs, case .sentCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.depositedCrypto, .depositedCrypto): return {
        guard case .depositedCrypto(let l) = lhs, case .depositedCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paidCrypto, .paidCrypto): return {
        guard case .paidCrypto(let l) = lhs, case .paidCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributedCrypto, .distributedCrypto): return {
        guard case .distributedCrypto(let l) = lhs, case .distributedCrypto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Flipcash_Activity_V1_NotificationId? = nil
  fileprivate var _paymentAmount: Flipcash_Common_V1_CryptoPaymentAmount? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Flipcash_Activity_V1_WelcomeBonusNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_GaveCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_SentCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vault of the gift card account that was created for the cash link
  public var vault: Flipcash_Common_V1_PublicKey {
    get {return _vault ?? Flipcash_Common_V1_PublicKey()}
    set {_vault = newValue}
  }
  /// Returns true if `vault` has been explicitly set.
  public var hasVault: Bool {return self._vault != nil}
  /// Clears the value of `vault`. Subsequent reads from it will return its default value.
  public mutating func clearVault() {self._vault = nil}

  /// Whether the cancel action can be initiated by the user
  public var canInitiateCancelAction: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vault: Flipcash_Common_V1_PublicKey? = nil
}

public struct Flipcash_Activity_V1_DepositedCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_PaidCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paymentMetadata: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.OneOf_PaymentMetadata? = nil

  public var pool: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata {
    get {
      if case .pool(let v)? = paymentMetadata {return v}
      return Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata()
    }
    set {paymentMetadata = .pool(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PaymentMetadata: Equatable {
    case pool(Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.OneOf_PaymentMetadata, rhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.OneOf_PaymentMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pool, .pool): return {
        guard case .pool(let l) = lhs, case .pool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Payment metadata for betting pools
  public struct PoolPaymentMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pool that was entered for this payment
    public var poolID: Flipcash_Pool_V1_PoolId {
      get {return _poolID ?? Flipcash_Pool_V1_PoolId()}
      set {_poolID = newValue}
    }
    /// Returns true if `poolID` has been explicitly set.
    public var hasPoolID: Bool {return self._poolID != nil}
    /// Clears the value of `poolID`. Subsequent reads from it will return its default value.
    public mutating func clearPoolID() {self._poolID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _poolID: Flipcash_Pool_V1_PoolId? = nil
  }

  public init() {}
}

public struct Flipcash_Activity_V1_DistributedCryptoNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var distributionMetadata: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.OneOf_DistributionMetadata? = nil

  public var pool: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata {
    get {
      if case .pool(let v)? = distributionMetadata {return v}
      return Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata()
    }
    set {distributionMetadata = .pool(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DistributionMetadata: Equatable {
    case pool(Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.OneOf_DistributionMetadata, rhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.OneOf_DistributionMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pool, .pool): return {
        guard case .pool(let l) = lhs, case .pool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Distribution metadata for betting pools
  public struct PoolDistributionMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pool where funds were distributed from
    public var poolID: Flipcash_Pool_V1_PoolId {
      get {return _poolID ?? Flipcash_Pool_V1_PoolId()}
      set {_poolID = newValue}
    }
    /// Returns true if `poolID` has been explicitly set.
    public var hasPoolID: Bool {return self._poolID != nil}
    /// Clears the value of `poolID`. Subsequent reads from it will return its default value.
    public mutating func clearPoolID() {self._poolID = nil}

    /// The outcome for this pool for the user that indicates the reason for
    /// receiving the distribution.
    public var outcome: Flipcash_Pool_V1_UserOutcome = .unknownOutcoe

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _poolID: Flipcash_Pool_V1_PoolId? = nil
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipcash_Activity_V1_ActivityFeedType: @unchecked Sendable {}
extension Flipcash_Activity_V1_NotificationState: @unchecked Sendable {}
extension Flipcash_Activity_V1_NotificationId: @unchecked Sendable {}
extension Flipcash_Activity_V1_Notification: @unchecked Sendable {}
extension Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_GaveCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_SentCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DepositedCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidCryptoNotificationMetadata.OneOf_PaymentMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedCryptoNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.OneOf_DistributionMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipcash.activity.v1"

extension Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TRANSACTION_HISTORY"),
  ]
}

extension Flipcash_Activity_V1_NotificationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFICATION_STATE_UNKNOWN"),
    1: .same(proto: "NOTIFICATION_STATE_PENDING"),
    2: .same(proto: "NOTIFICATION_STATE_COMPLETED"),
  ]
}

extension Flipcash_Activity_V1_NotificationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_NotificationId, rhs: Flipcash_Activity_V1_NotificationId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "localized_text"),
    3: .standard(proto: "payment_amount"),
    4: .same(proto: "ts"),
    10: .same(proto: "state"),
    5: .standard(proto: "welcome_bonus"),
    6: .standard(proto: "gave_crypto"),
    7: .standard(proto: "received_crypto"),
    8: .standard(proto: "withdrew_crypto"),
    9: .standard(proto: "sent_crypto"),
    11: .standard(proto: "deposited_crypto"),
    12: .standard(proto: "paid_crypto"),
    13: .standard(proto: "distributed_crypto"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localizedText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try {
        var v: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .welcomeBonus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .welcomeBonus(v)
        }
      }()
      case 6: try {
        var v: Flipcash_Activity_V1_GaveCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .gaveCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .gaveCrypto(v)
        }
      }()
      case 7: try {
        var v: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .receivedCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .receivedCrypto(v)
        }
      }()
      case 8: try {
        var v: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .withdrewCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .withdrewCrypto(v)
        }
      }()
      case 9: try {
        var v: Flipcash_Activity_V1_SentCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .sentCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .sentCrypto(v)
        }
      }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 11: try {
        var v: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .depositedCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .depositedCrypto(v)
        }
      }()
      case 12: try {
        var v: Flipcash_Activity_V1_PaidCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .paidCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .paidCrypto(v)
        }
      }()
      case 13: try {
        var v: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .distributedCrypto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .distributedCrypto(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.localizedText.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedText, fieldNumber: 2)
    }
    try { if let v = self._paymentAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.additionalMetadata {
    case .welcomeBonus?: try {
      guard case .welcomeBonus(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .gaveCrypto?: try {
      guard case .gaveCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .receivedCrypto?: try {
      guard case .receivedCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .withdrewCrypto?: try {
      guard case .withdrewCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sentCrypto?: try {
      guard case .sentCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 10)
    }
    switch self.additionalMetadata {
    case .depositedCrypto?: try {
      guard case .depositedCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .paidCrypto?: try {
      guard case .paidCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .distributedCrypto?: try {
      guard case .distributedCrypto(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_Notification, rhs: Flipcash_Activity_V1_Notification) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.localizedText != rhs.localizedText {return false}
    if lhs._paymentAmount != rhs._paymentAmount {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.state != rhs.state {return false}
    if lhs.additionalMetadata != rhs.additionalMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeBonusNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata, rhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_GaveCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GaveCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_GaveCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_GaveCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivedCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_ReceivedCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrewCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_WithdrewCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_SentCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentCryptoNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vault"),
    2: .standard(proto: "can_initiate_cancel_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vault) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canInitiateCancelAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.canInitiateCancelAction != false {
      try visitor.visitSingularBoolField(value: self.canInitiateCancelAction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_SentCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_SentCryptoNotificationMetadata) -> Bool {
    if lhs._vault != rhs._vault {return false}
    if lhs.canInitiateCancelAction != rhs.canInitiateCancelAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DepositedCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositedCryptoNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_DepositedCryptoNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_PaidCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaidCryptoNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata?
        var hadOneofValue = false
        if let current = self.paymentMetadata {
          hadOneofValue = true
          if case .pool(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.paymentMetadata = .pool(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .pool(let v)? = self.paymentMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata) -> Bool {
    if lhs.paymentMetadata != rhs.paymentMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Activity_V1_PaidCryptoNotificationMetadata.protoMessageName + ".PoolPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata, rhs: Flipcash_Activity_V1_PaidCryptoNotificationMetadata.PoolPaymentMetadata) -> Bool {
    if lhs._poolID != rhs._poolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DistributedCryptoNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributedCryptoNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata?
        var hadOneofValue = false
        if let current = self.distributionMetadata {
          hadOneofValue = true
          if case .pool(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.distributionMetadata = .pool(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .pool(let v)? = self.distributionMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata, rhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata) -> Bool {
    if lhs.distributionMetadata != rhs.distributionMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.protoMessageName + ".PoolDistributionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "outcome"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.outcome) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.outcome != .unknownOutcoe {
      try visitor.visitSingularEnumField(value: self.outcome, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata, rhs: Flipcash_Activity_V1_DistributedCryptoNotificationMetadata.PoolDistributionMetadata) -> Bool {
    if lhs._poolID != rhs._poolID {return false}
    if lhs.outcome != rhs.outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
