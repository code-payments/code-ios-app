// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: activity/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ActivityFeedType enables multiple activity feeds, where notifications may be
/// split across different parts of the app
public enum Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Activity feed displayed under the Balance tab
  case transactionHistory // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .transactionHistory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .transactionHistory: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipcash_Activity_V1_ActivityFeedType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_ActivityFeedType] = [
    .unknown,
    .transactionHistory,
  ]
}

#endif  // swift(>=4.2)

/// NotificationState determines the mutability of a notification, and whether
/// client should attempt to refetch state.
public enum Flipcash_Activity_V1_NotificationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Notification state will change based on some app action in the future
  case pending // = 1

  /// Notification state will not change
  case completed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .completed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipcash_Activity_V1_NotificationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Activity_V1_NotificationState] = [
    .unknown,
    .pending,
    .completed,
  ]
}

#endif  // swift(>=4.2)

/// The ID of the notification
public struct Flipcash_Activity_V1_NotificationId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Notification is a message that is displayed in an activity feed
public struct Flipcash_Activity_V1_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of this notification
  public var id: Flipcash_Activity_V1_NotificationId {
    get {return _id ?? Flipcash_Activity_V1_NotificationId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The localized title text for the notification
  public var localizedText: String = String()

  /// If a payment applies, the amount that was paid
  public var paymentAmount: Flipcash_Common_V1_UsdcPaymentAmount {
    get {return _paymentAmount ?? Flipcash_Common_V1_UsdcPaymentAmount()}
    set {_paymentAmount = newValue}
  }
  /// Returns true if `paymentAmount` has been explicitly set.
  public var hasPaymentAmount: Bool {return self._paymentAmount != nil}
  /// Clears the value of `paymentAmount`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentAmount() {self._paymentAmount = nil}

  /// The timestamp of this notification
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  /// The state of this notification
  public var state: Flipcash_Activity_V1_NotificationState = .unknown

  /// Additional metadata for this notification specific to the notification
  public var additionalMetadata: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata? = nil

  public var welcomeBonus: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata {
    get {
      if case .welcomeBonus(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WelcomeBonusNotificationMetadata()
    }
    set {additionalMetadata = .welcomeBonus(newValue)}
  }

  public var gaveUsdc: Flipcash_Activity_V1_GaveUsdcNotificationMetadata {
    get {
      if case .gaveUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_GaveUsdcNotificationMetadata()
    }
    set {additionalMetadata = .gaveUsdc(newValue)}
  }

  public var receivedUsdc: Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata {
    get {
      if case .receivedUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata()
    }
    set {additionalMetadata = .receivedUsdc(newValue)}
  }

  public var withdrewUsdc: Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata {
    get {
      if case .withdrewUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata()
    }
    set {additionalMetadata = .withdrewUsdc(newValue)}
  }

  public var sentUsdc: Flipcash_Activity_V1_SentUsdcNotificationMetadata {
    get {
      if case .sentUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_SentUsdcNotificationMetadata()
    }
    set {additionalMetadata = .sentUsdc(newValue)}
  }

  public var depositedUsdc: Flipcash_Activity_V1_DepositedUsdcNotificationMetadata {
    get {
      if case .depositedUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_DepositedUsdcNotificationMetadata()
    }
    set {additionalMetadata = .depositedUsdc(newValue)}
  }

  public var paidUsdc: Flipcash_Activity_V1_PaidUsdcNotificationMetadata {
    get {
      if case .paidUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_PaidUsdcNotificationMetadata()
    }
    set {additionalMetadata = .paidUsdc(newValue)}
  }

  public var distributedUsdc: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata {
    get {
      if case .distributedUsdc(let v)? = additionalMetadata {return v}
      return Flipcash_Activity_V1_DistributedUsdcNotificationMetadata()
    }
    set {additionalMetadata = .distributedUsdc(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Additional metadata for this notification specific to the notification
  public enum OneOf_AdditionalMetadata: Equatable {
    case welcomeBonus(Flipcash_Activity_V1_WelcomeBonusNotificationMetadata)
    case gaveUsdc(Flipcash_Activity_V1_GaveUsdcNotificationMetadata)
    case receivedUsdc(Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata)
    case withdrewUsdc(Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata)
    case sentUsdc(Flipcash_Activity_V1_SentUsdcNotificationMetadata)
    case depositedUsdc(Flipcash_Activity_V1_DepositedUsdcNotificationMetadata)
    case paidUsdc(Flipcash_Activity_V1_PaidUsdcNotificationMetadata)
    case distributedUsdc(Flipcash_Activity_V1_DistributedUsdcNotificationMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata, rhs: Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.welcomeBonus, .welcomeBonus): return {
        guard case .welcomeBonus(let l) = lhs, case .welcomeBonus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gaveUsdc, .gaveUsdc): return {
        guard case .gaveUsdc(let l) = lhs, case .gaveUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receivedUsdc, .receivedUsdc): return {
        guard case .receivedUsdc(let l) = lhs, case .receivedUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withdrewUsdc, .withdrewUsdc): return {
        guard case .withdrewUsdc(let l) = lhs, case .withdrewUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sentUsdc, .sentUsdc): return {
        guard case .sentUsdc(let l) = lhs, case .sentUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.depositedUsdc, .depositedUsdc): return {
        guard case .depositedUsdc(let l) = lhs, case .depositedUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paidUsdc, .paidUsdc): return {
        guard case .paidUsdc(let l) = lhs, case .paidUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributedUsdc, .distributedUsdc): return {
        guard case .distributedUsdc(let l) = lhs, case .distributedUsdc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Flipcash_Activity_V1_NotificationId? = nil
  fileprivate var _paymentAmount: Flipcash_Common_V1_UsdcPaymentAmount? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Flipcash_Activity_V1_WelcomeBonusNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_GaveUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_SentUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vault of the gift card account that was created for the cash link
  public var vault: Flipcash_Common_V1_PublicKey {
    get {return _vault ?? Flipcash_Common_V1_PublicKey()}
    set {_vault = newValue}
  }
  /// Returns true if `vault` has been explicitly set.
  public var hasVault: Bool {return self._vault != nil}
  /// Clears the value of `vault`. Subsequent reads from it will return its default value.
  public mutating func clearVault() {self._vault = nil}

  /// Whether the cancel action can be initiated by the user
  public var canInitiateCancelAction: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vault: Flipcash_Common_V1_PublicKey? = nil
}

public struct Flipcash_Activity_V1_DepositedUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Flipcash_Activity_V1_PaidUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paymentMetadata: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.OneOf_PaymentMetadata? = nil

  public var pool: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata {
    get {
      if case .pool(let v)? = paymentMetadata {return v}
      return Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata()
    }
    set {paymentMetadata = .pool(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PaymentMetadata: Equatable {
    case pool(Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.OneOf_PaymentMetadata, rhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.OneOf_PaymentMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pool, .pool): return {
        guard case .pool(let l) = lhs, case .pool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Payment metadata for betting pools
  public struct PoolPaymentMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pool that was entered for this payment
    public var poolID: Flipcash_Pool_V1_PoolId {
      get {return _poolID ?? Flipcash_Pool_V1_PoolId()}
      set {_poolID = newValue}
    }
    /// Returns true if `poolID` has been explicitly set.
    public var hasPoolID: Bool {return self._poolID != nil}
    /// Clears the value of `poolID`. Subsequent reads from it will return its default value.
    public mutating func clearPoolID() {self._poolID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _poolID: Flipcash_Pool_V1_PoolId? = nil
  }

  public init() {}
}

public struct Flipcash_Activity_V1_DistributedUsdcNotificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var distributionMetadata: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.OneOf_DistributionMetadata? = nil

  public var pool: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata {
    get {
      if case .pool(let v)? = distributionMetadata {return v}
      return Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata()
    }
    set {distributionMetadata = .pool(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DistributionMetadata: Equatable {
    case pool(Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.OneOf_DistributionMetadata, rhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.OneOf_DistributionMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pool, .pool): return {
        guard case .pool(let l) = lhs, case .pool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Distribution metadata for betting pools
  public struct PoolDistributionMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pool where funds were distributed from
    public var poolID: Flipcash_Pool_V1_PoolId {
      get {return _poolID ?? Flipcash_Pool_V1_PoolId()}
      set {_poolID = newValue}
    }
    /// Returns true if `poolID` has been explicitly set.
    public var hasPoolID: Bool {return self._poolID != nil}
    /// Clears the value of `poolID`. Subsequent reads from it will return its default value.
    public mutating func clearPoolID() {self._poolID = nil}

    /// The outcome for this pool for the user that indicates the reason for
    /// receiving the distribution.
    public var outcome: Flipcash_Pool_V1_UserOutcome = .unknownOutcoe

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _poolID: Flipcash_Pool_V1_PoolId? = nil
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipcash_Activity_V1_ActivityFeedType: @unchecked Sendable {}
extension Flipcash_Activity_V1_NotificationState: @unchecked Sendable {}
extension Flipcash_Activity_V1_NotificationId: @unchecked Sendable {}
extension Flipcash_Activity_V1_Notification: @unchecked Sendable {}
extension Flipcash_Activity_V1_Notification.OneOf_AdditionalMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_GaveUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_SentUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DepositedUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidUsdcNotificationMetadata.OneOf_PaymentMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedUsdcNotificationMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.OneOf_DistributionMetadata: @unchecked Sendable {}
extension Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipcash.activity.v1"

extension Flipcash_Activity_V1_ActivityFeedType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TRANSACTION_HISTORY"),
  ]
}

extension Flipcash_Activity_V1_NotificationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFICATION_STATE_UNKNOWN"),
    1: .same(proto: "NOTIFICATION_STATE_PENDING"),
    2: .same(proto: "NOTIFICATION_STATE_COMPLETED"),
  ]
}

extension Flipcash_Activity_V1_NotificationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_NotificationId, rhs: Flipcash_Activity_V1_NotificationId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "localized_text"),
    3: .standard(proto: "payment_amount"),
    4: .same(proto: "ts"),
    10: .same(proto: "state"),
    5: .standard(proto: "welcome_bonus"),
    6: .standard(proto: "gave_usdc"),
    7: .standard(proto: "received_usdc"),
    8: .standard(proto: "withdrew_usdc"),
    9: .standard(proto: "sent_usdc"),
    11: .standard(proto: "deposited_usdc"),
    12: .standard(proto: "paid_usdc"),
    13: .standard(proto: "distributed_usdc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localizedText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      case 5: try {
        var v: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .welcomeBonus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .welcomeBonus(v)
        }
      }()
      case 6: try {
        var v: Flipcash_Activity_V1_GaveUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .gaveUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .gaveUsdc(v)
        }
      }()
      case 7: try {
        var v: Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .receivedUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .receivedUsdc(v)
        }
      }()
      case 8: try {
        var v: Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .withdrewUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .withdrewUsdc(v)
        }
      }()
      case 9: try {
        var v: Flipcash_Activity_V1_SentUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .sentUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .sentUsdc(v)
        }
      }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 11: try {
        var v: Flipcash_Activity_V1_DepositedUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .depositedUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .depositedUsdc(v)
        }
      }()
      case 12: try {
        var v: Flipcash_Activity_V1_PaidUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .paidUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .paidUsdc(v)
        }
      }()
      case 13: try {
        var v: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata?
        var hadOneofValue = false
        if let current = self.additionalMetadata {
          hadOneofValue = true
          if case .distributedUsdc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalMetadata = .distributedUsdc(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.localizedText.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedText, fieldNumber: 2)
    }
    try { if let v = self._paymentAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.additionalMetadata {
    case .welcomeBonus?: try {
      guard case .welcomeBonus(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .gaveUsdc?: try {
      guard case .gaveUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .receivedUsdc?: try {
      guard case .receivedUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .withdrewUsdc?: try {
      guard case .withdrewUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sentUsdc?: try {
      guard case .sentUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 10)
    }
    switch self.additionalMetadata {
    case .depositedUsdc?: try {
      guard case .depositedUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .paidUsdc?: try {
      guard case .paidUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .distributedUsdc?: try {
      guard case .distributedUsdc(let v)? = self.additionalMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_Notification, rhs: Flipcash_Activity_V1_Notification) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.localizedText != rhs.localizedText {return false}
    if lhs._paymentAmount != rhs._paymentAmount {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.state != rhs.state {return false}
    if lhs.additionalMetadata != rhs.additionalMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WelcomeBonusNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeBonusNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata, rhs: Flipcash_Activity_V1_WelcomeBonusNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_GaveUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GaveUsdcNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_GaveUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_GaveUsdcNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceivedUsdcNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_ReceivedUsdcNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrewUsdcNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_WithdrewUsdcNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_SentUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentUsdcNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vault"),
    2: .standard(proto: "can_initiate_cancel_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vault) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canInitiateCancelAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.canInitiateCancelAction != false {
      try visitor.visitSingularBoolField(value: self.canInitiateCancelAction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_SentUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_SentUsdcNotificationMetadata) -> Bool {
    if lhs._vault != rhs._vault {return false}
    if lhs.canInitiateCancelAction != rhs.canInitiateCancelAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DepositedUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositedUsdcNotificationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DepositedUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_DepositedUsdcNotificationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_PaidUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaidUsdcNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata?
        var hadOneofValue = false
        if let current = self.paymentMetadata {
          hadOneofValue = true
          if case .pool(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.paymentMetadata = .pool(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .pool(let v)? = self.paymentMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata) -> Bool {
    if lhs.paymentMetadata != rhs.paymentMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Activity_V1_PaidUsdcNotificationMetadata.protoMessageName + ".PoolPaymentMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata, rhs: Flipcash_Activity_V1_PaidUsdcNotificationMetadata.PoolPaymentMetadata) -> Bool {
    if lhs._poolID != rhs._poolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DistributedUsdcNotificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributedUsdcNotificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata?
        var hadOneofValue = false
        if let current = self.distributionMetadata {
          hadOneofValue = true
          if case .pool(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.distributionMetadata = .pool(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .pool(let v)? = self.distributionMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata, rhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata) -> Bool {
    if lhs.distributionMetadata != rhs.distributionMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.protoMessageName + ".PoolDistributionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "outcome"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.outcome) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.outcome != .unknownOutcoe {
      try visitor.visitSingularEnumField(value: self.outcome, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata, rhs: Flipcash_Activity_V1_DistributedUsdcNotificationMetadata.PoolDistributionMetadata) -> Bool {
    if lhs._poolID != rhs._poolID {return false}
    if lhs.outcome != rhs.outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
