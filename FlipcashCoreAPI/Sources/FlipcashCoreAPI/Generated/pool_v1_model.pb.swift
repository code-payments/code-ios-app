// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pool/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// UserOutcome is an enum of states for user outcomes in a pool
public enum Flipcash_Pool_V1_UserOutcome: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownOutcoe // = 0

  /// Pool isn't resolved, so no user outcome is available
  case noOutcome // = 1

  /// User is a winner in the pool
  case winOutcome // = 2

  /// User is a loser in the pool
  case loseOutcome // = 3

  /// User was refunded
  case refundOutcome // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownOutcoe
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownOutcoe
    case 1: self = .noOutcome
    case 2: self = .winOutcome
    case 3: self = .loseOutcome
    case 4: self = .refundOutcome
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownOutcoe: return 0
    case .noOutcome: return 1
    case .winOutcome: return 2
    case .loseOutcome: return 3
    case .refundOutcome: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flipcash_Pool_V1_UserOutcome: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Flipcash_Pool_V1_UserOutcome] = [
    .unknownOutcoe,
    .noOutcome,
    .winOutcome,
    .loseOutcome,
    .refundOutcome,
  ]
}

#endif  // swift(>=4.2)

/// PoolId uniquely identifies a pool via a rendezvous public key
public struct Flipcash_Pool_V1_PoolId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Resolution is a resolution to a pool that declares the winning outcome chosen
/// by the pool creator
public struct Flipcash_Pool_V1_Resolution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Flipcash_Pool_V1_Resolution.OneOf_Kind? = nil

  /// The yes/no outcome the creator has chosen as the winning outcome
  public var booleanResolution: Bool {
    get {
      if case .booleanResolution(let v)? = kind {return v}
      return false
    }
    set {kind = .booleanResolution(newValue)}
  }

  /// A refund to all participants. No outcome was decided
  public var refundResolution: Flipcash_Pool_V1_Resolution.Refund {
    get {
      if case .refundResolution(let v)? = kind {return v}
      return Flipcash_Pool_V1_Resolution.Refund()
    }
    set {kind = .refundResolution(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The yes/no outcome the creator has chosen as the winning outcome
    case booleanResolution(Bool)
    /// A refund to all participants. No outcome was decided
    case refundResolution(Flipcash_Pool_V1_Resolution.Refund)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_Resolution.OneOf_Kind, rhs: Flipcash_Pool_V1_Resolution.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.booleanResolution, .booleanResolution): return {
        guard case .booleanResolution(let l) = lhs, case .booleanResolution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.refundResolution, .refundResolution): return {
        guard case .refundResolution(let l) = lhs, case .refundResolution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Refund {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Pool metadata signed by the rendezvous key
public struct Flipcash_Pool_V1_SignedPoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Flipcash_Pool_V1_PoolId {
    get {return _id ?? Flipcash_Pool_V1_PoolId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The user ID that created this pool
  public var creator: Flipcash_Common_V1_UserId {
    get {return _creator ?? Flipcash_Common_V1_UserId()}
    set {_creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return self._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {self._creator = nil}

  /// The pool name, which should ask a yes/no question to bet against
  public var name: String = String()

  /// The buy in amount for a bet
  public var buyIn: Flipcash_Common_V1_FiatPaymentAmount {
    get {return _buyIn ?? Flipcash_Common_V1_FiatPaymentAmount()}
    set {_buyIn = newValue}
  }
  /// Returns true if `buyIn` has been explicitly set.
  public var hasBuyIn: Bool {return self._buyIn != nil}
  /// Clears the value of `buyIn`. Subsequent reads from it will return its default value.
  public mutating func clearBuyIn() {self._buyIn = nil}

  /// Destination where bet payments will be made to fund the pool
  public var fundingDestination: Flipcash_Common_V1_PublicKey {
    get {return _fundingDestination ?? Flipcash_Common_V1_PublicKey()}
    set {_fundingDestination = newValue}
  }
  /// Returns true if `fundingDestination` has been explicitly set.
  public var hasFundingDestination: Bool {return self._fundingDestination != nil}
  /// Clears the value of `fundingDestination`. Subsequent reads from it will return its default value.
  public mutating func clearFundingDestination() {self._fundingDestination = nil}

  /// Is the pool currently open to take bets?
  public var isOpen: Bool = false

  /// The pool resolution, if one is made
  public var resolution: Flipcash_Pool_V1_Resolution {
    get {return _resolution ?? Flipcash_Pool_V1_Resolution()}
    set {_resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  public var hasResolution: Bool {return self._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  public mutating func clearResolution() {self._resolution = nil}

  /// Timestamp pool was created at
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Timestamp the pool was closed at
  public var closedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _closedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_closedAt = newValue}
  }
  /// Returns true if `closedAt` has been explicitly set.
  public var hasClosedAt: Bool {return self._closedAt != nil}
  /// Clears the value of `closedAt`. Subsequent reads from it will return its default value.
  public mutating func clearClosedAt() {self._closedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Flipcash_Pool_V1_PoolId? = nil
  fileprivate var _creator: Flipcash_Common_V1_UserId? = nil
  fileprivate var _buyIn: Flipcash_Common_V1_FiatPaymentAmount? = nil
  fileprivate var _fundingDestination: Flipcash_Common_V1_PublicKey? = nil
  fileprivate var _resolution: Flipcash_Pool_V1_Resolution? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _closedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Pool metadata
public struct Flipcash_Pool_V1_PoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verifiedMetadata: Flipcash_Pool_V1_SignedPoolMetadata {
    get {return _storage._verifiedMetadata ?? Flipcash_Pool_V1_SignedPoolMetadata()}
    set {_uniqueStorage()._verifiedMetadata = newValue}
  }
  /// Returns true if `verifiedMetadata` has been explicitly set.
  public var hasVerifiedMetadata: Bool {return _storage._verifiedMetadata != nil}
  /// Clears the value of `verifiedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVerifiedMetadata() {_uniqueStorage()._verifiedMetadata = nil}

  /// Signature of the SignedPoolMetadata message with the rendezvous public key of the pool
  public var rendezvousSignature: Flipcash_Common_V1_Signature {
    get {return _storage._rendezvousSignature ?? Flipcash_Common_V1_Signature()}
    set {_uniqueStorage()._rendezvousSignature = newValue}
  }
  /// Returns true if `rendezvousSignature` has been explicitly set.
  public var hasRendezvousSignature: Bool {return _storage._rendezvousSignature != nil}
  /// Clears the value of `rendezvousSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRendezvousSignature() {_uniqueStorage()._rendezvousSignature = nil}

  /// The set of bets made against this pool
  public var bets: [Flipcash_Pool_V1_BetMetadata] {
    get {return _storage._bets}
    set {_uniqueStorage()._bets = newValue}
  }

  /// Consolidated summary of bets made against this pool
  public var betSummary: Flipcash_Pool_V1_BetSummary {
    get {return _storage._betSummary ?? Flipcash_Pool_V1_BetSummary()}
    set {_uniqueStorage()._betSummary = newValue}
  }
  /// Returns true if `betSummary` has been explicitly set.
  public var hasBetSummary: Bool {return _storage._betSummary != nil}
  /// Clears the value of `betSummary`. Subsequent reads from it will return its default value.
  public mutating func clearBetSummary() {_uniqueStorage()._betSummary = nil}

  /// User-specific summary data related to this pool. This is provided against
  /// authenticated RPCs
  public var userSummary: Flipcash_Pool_V1_UserPoolSummary {
    get {return _storage._userSummary ?? Flipcash_Pool_V1_UserPoolSummary()}
    set {_uniqueStorage()._userSummary = newValue}
  }
  /// Returns true if `userSummary` has been explicitly set.
  public var hasUserSummary: Bool {return _storage._userSummary != nil}
  /// Clears the value of `userSummary`. Subsequent reads from it will return its default value.
  public mutating func clearUserSummary() {_uniqueStorage()._userSummary = nil}

  /// Paging token specific to each user that enables access to paging APIs
  public var pagingToken: Flipcash_Common_V1_PagingToken {
    get {return _storage._pagingToken ?? Flipcash_Common_V1_PagingToken()}
    set {_uniqueStorage()._pagingToken = newValue}
  }
  /// Returns true if `pagingToken` has been explicitly set.
  public var hasPagingToken: Bool {return _storage._pagingToken != nil}
  /// Clears the value of `pagingToken`. Subsequent reads from it will return its default value.
  public mutating func clearPagingToken() {_uniqueStorage()._pagingToken = nil}

  /// Has the funding destination been initialized? Bet payments cannot be made
  /// until this has occurred.
  public var isFundingDestinationInitialized: Bool {
    get {return _storage._isFundingDestinationInitialized}
    set {_uniqueStorage()._isFundingDestinationInitialized = newValue}
  }

  /// Derivation index used to derive the pool account's authority. This is only
  /// valid against authenticated RPCs made by the pool creator
  public var derivationIndex: UInt64 {
    get {return _storage._derivationIndex}
    set {_uniqueStorage()._derivationIndex = newValue}
  }

  /// The creator's user profile
  public var creatorProfile: Flipcash_Profile_V1_UserProfile {
    get {return _storage._creatorProfile ?? Flipcash_Profile_V1_UserProfile()}
    set {_uniqueStorage()._creatorProfile = newValue}
  }
  /// Returns true if `creatorProfile` has been explicitly set.
  public var hasCreatorProfile: Bool {return _storage._creatorProfile != nil}
  /// Clears the value of `creatorProfile`. Subsequent reads from it will return its default value.
  public mutating func clearCreatorProfile() {_uniqueStorage()._creatorProfile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BetId uniquely identifies a bet via an intent ID
public struct Flipcash_Pool_V1_BetId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BetOutcome is the user's outcome that they bet against
public struct Flipcash_Pool_V1_BetOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Flipcash_Pool_V1_BetOutcome.OneOf_Kind? = nil

  /// The yes/no outcome the user has bet against
  public var booleanOutcome: Bool {
    get {
      if case .booleanOutcome(let v)? = kind {return v}
      return false
    }
    set {kind = .booleanOutcome(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The yes/no outcome the user has bet against
    case booleanOutcome(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_BetOutcome.OneOf_Kind, rhs: Flipcash_Pool_V1_BetOutcome.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.booleanOutcome, .booleanOutcome): return {
        guard case .booleanOutcome(let l) = lhs, case .booleanOutcome(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// BetSummary contains a consolidated summary of bets made against a pool
public struct Flipcash_Pool_V1_BetSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Flipcash_Pool_V1_BetSummary.OneOf_Kind? = nil

  /// The yes/no outcome users have bet in the pool
  public var booleanSummary: Flipcash_Pool_V1_BetSummary.BooleanBetSummary {
    get {
      if case .booleanSummary(let v)? = kind {return v}
      return Flipcash_Pool_V1_BetSummary.BooleanBetSummary()
    }
    set {kind = .booleanSummary(newValue)}
  }

  /// The total fiat paid for bets against the pool
  public var totalAmountBet: Flipcash_Common_V1_FiatPaymentAmount {
    get {return _totalAmountBet ?? Flipcash_Common_V1_FiatPaymentAmount()}
    set {_totalAmountBet = newValue}
  }
  /// Returns true if `totalAmountBet` has been explicitly set.
  public var hasTotalAmountBet: Bool {return self._totalAmountBet != nil}
  /// Clears the value of `totalAmountBet`. Subsequent reads from it will return its default value.
  public mutating func clearTotalAmountBet() {self._totalAmountBet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The yes/no outcome users have bet in the pool
    case booleanSummary(Flipcash_Pool_V1_BetSummary.BooleanBetSummary)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_BetSummary.OneOf_Kind, rhs: Flipcash_Pool_V1_BetSummary.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.booleanSummary, .booleanSummary): return {
        guard case .booleanSummary(let l) = lhs, case .booleanSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public struct BooleanBetSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var numYes: UInt32 = 0

    public var numNo: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _totalAmountBet: Flipcash_Common_V1_FiatPaymentAmount? = nil
}

public struct Flipcash_Pool_V1_UserPoolSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outcome for the user for a pool
  public var outcome: Flipcash_Pool_V1_UserPoolSummary.OneOf_Outcome? = nil

  public var none: Flipcash_Pool_V1_UserPoolSummary.NoOutcome {
    get {
      if case .none(let v)? = outcome {return v}
      return Flipcash_Pool_V1_UserPoolSummary.NoOutcome()
    }
    set {outcome = .none(newValue)}
  }

  public var win: Flipcash_Pool_V1_UserPoolSummary.WinOutcome {
    get {
      if case .win(let v)? = outcome {return v}
      return Flipcash_Pool_V1_UserPoolSummary.WinOutcome()
    }
    set {outcome = .win(newValue)}
  }

  public var lose: Flipcash_Pool_V1_UserPoolSummary.LoseOutcome {
    get {
      if case .lose(let v)? = outcome {return v}
      return Flipcash_Pool_V1_UserPoolSummary.LoseOutcome()
    }
    set {outcome = .lose(newValue)}
  }

  public var refund: Flipcash_Pool_V1_UserPoolSummary.RefundOutcome {
    get {
      if case .refund(let v)? = outcome {return v}
      return Flipcash_Pool_V1_UserPoolSummary.RefundOutcome()
    }
    set {outcome = .refund(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The outcome for the user for a pool
  public enum OneOf_Outcome: Equatable {
    case none(Flipcash_Pool_V1_UserPoolSummary.NoOutcome)
    case win(Flipcash_Pool_V1_UserPoolSummary.WinOutcome)
    case lose(Flipcash_Pool_V1_UserPoolSummary.LoseOutcome)
    case refund(Flipcash_Pool_V1_UserPoolSummary.RefundOutcome)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary.OneOf_Outcome, rhs: Flipcash_Pool_V1_UserPoolSummary.OneOf_Outcome) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.none, .none): return {
        guard case .none(let l) = lhs, case .none(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.win, .win): return {
        guard case .win(let l) = lhs, case .win(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lose, .lose): return {
        guard case .lose(let l) = lhs, case .lose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.refund, .refund): return {
        guard case .refund(let l) = lhs, case .refund(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Pool isn't resolved, so no user outcome is available
  public struct NoOutcome {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// User is a winner in the pool
  public struct WinOutcome {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var amountWon: Flipcash_Common_V1_FiatPaymentAmount {
      get {return _amountWon ?? Flipcash_Common_V1_FiatPaymentAmount()}
      set {_amountWon = newValue}
    }
    /// Returns true if `amountWon` has been explicitly set.
    public var hasAmountWon: Bool {return self._amountWon != nil}
    /// Clears the value of `amountWon`. Subsequent reads from it will return its default value.
    public mutating func clearAmountWon() {self._amountWon = nil}

    public var totalAmountReceived: Flipcash_Common_V1_FiatPaymentAmount {
      get {return _totalAmountReceived ?? Flipcash_Common_V1_FiatPaymentAmount()}
      set {_totalAmountReceived = newValue}
    }
    /// Returns true if `totalAmountReceived` has been explicitly set.
    public var hasTotalAmountReceived: Bool {return self._totalAmountReceived != nil}
    /// Clears the value of `totalAmountReceived`. Subsequent reads from it will return its default value.
    public mutating func clearTotalAmountReceived() {self._totalAmountReceived = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _amountWon: Flipcash_Common_V1_FiatPaymentAmount? = nil
    fileprivate var _totalAmountReceived: Flipcash_Common_V1_FiatPaymentAmount? = nil
  }

  /// User is a loser in the pool
  public struct LoseOutcome {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var amountLost: Flipcash_Common_V1_FiatPaymentAmount {
      get {return _amountLost ?? Flipcash_Common_V1_FiatPaymentAmount()}
      set {_amountLost = newValue}
    }
    /// Returns true if `amountLost` has been explicitly set.
    public var hasAmountLost: Bool {return self._amountLost != nil}
    /// Clears the value of `amountLost`. Subsequent reads from it will return its default value.
    public mutating func clearAmountLost() {self._amountLost = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _amountLost: Flipcash_Common_V1_FiatPaymentAmount? = nil
  }

  /// User was refunded
  public struct RefundOutcome {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var amountRefunded: Flipcash_Common_V1_FiatPaymentAmount {
      get {return _amountRefunded ?? Flipcash_Common_V1_FiatPaymentAmount()}
      set {_amountRefunded = newValue}
    }
    /// Returns true if `amountRefunded` has been explicitly set.
    public var hasAmountRefunded: Bool {return self._amountRefunded != nil}
    /// Clears the value of `amountRefunded`. Subsequent reads from it will return its default value.
    public mutating func clearAmountRefunded() {self._amountRefunded = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _amountRefunded: Flipcash_Common_V1_FiatPaymentAmount? = nil
  }

  public init() {}
}

/// Bet metadata signed by the rendezvous key
public struct Flipcash_Pool_V1_SignedBetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var betID: Flipcash_Pool_V1_BetId {
    get {return _betID ?? Flipcash_Pool_V1_BetId()}
    set {_betID = newValue}
  }
  /// Returns true if `betID` has been explicitly set.
  public var hasBetID: Bool {return self._betID != nil}
  /// Clears the value of `betID`. Subsequent reads from it will return its default value.
  public mutating func clearBetID() {self._betID = nil}

  /// The user making the bet, which is unique for a given pool
  public var userID: Flipcash_Common_V1_UserId {
    get {return _userID ?? Flipcash_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The outcome the user has bet against
  public var selectedOutcome: Flipcash_Pool_V1_BetOutcome {
    get {return _selectedOutcome ?? Flipcash_Pool_V1_BetOutcome()}
    set {_selectedOutcome = newValue}
  }
  /// Returns true if `selectedOutcome` has been explicitly set.
  public var hasSelectedOutcome: Bool {return self._selectedOutcome != nil}
  /// Clears the value of `selectedOutcome`. Subsequent reads from it will return its default value.
  public mutating func clearSelectedOutcome() {self._selectedOutcome = nil}

  /// The destination where payout will be made if the user selected the correct
  /// outcome.
  public var payoutDestination: Flipcash_Common_V1_PublicKey {
    get {return _payoutDestination ?? Flipcash_Common_V1_PublicKey()}
    set {_payoutDestination = newValue}
  }
  /// Returns true if `payoutDestination` has been explicitly set.
  public var hasPayoutDestination: Bool {return self._payoutDestination != nil}
  /// Clears the value of `payoutDestination`. Subsequent reads from it will return its default value.
  public mutating func clearPayoutDestination() {self._payoutDestination = nil}

  /// Timestamp the bet was made
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _betID: Flipcash_Pool_V1_BetId? = nil
  fileprivate var _userID: Flipcash_Common_V1_UserId? = nil
  fileprivate var _selectedOutcome: Flipcash_Pool_V1_BetOutcome? = nil
  fileprivate var _payoutDestination: Flipcash_Common_V1_PublicKey? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Bet metadata
public struct Flipcash_Pool_V1_BetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verifiedMetadata: Flipcash_Pool_V1_SignedBetMetadata {
    get {return _verifiedMetadata ?? Flipcash_Pool_V1_SignedBetMetadata()}
    set {_verifiedMetadata = newValue}
  }
  /// Returns true if `verifiedMetadata` has been explicitly set.
  public var hasVerifiedMetadata: Bool {return self._verifiedMetadata != nil}
  /// Clears the value of `verifiedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVerifiedMetadata() {self._verifiedMetadata = nil}

  /// Signature of the SignedBetMetadata message with the rendezvous public key of the pool
  public var rendezvousSignature: Flipcash_Common_V1_Signature {
    get {return _rendezvousSignature ?? Flipcash_Common_V1_Signature()}
    set {_rendezvousSignature = newValue}
  }
  /// Returns true if `rendezvousSignature` has been explicitly set.
  public var hasRendezvousSignature: Bool {return self._rendezvousSignature != nil}
  /// Clears the value of `rendezvousSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRendezvousSignature() {self._rendezvousSignature = nil}

  /// Has the intent for bet payment been submitted?
  public var isIntentSubmitted: Bool = false

  /// The better's user profile
  public var betterProfile: Flipcash_Profile_V1_UserProfile {
    get {return _betterProfile ?? Flipcash_Profile_V1_UserProfile()}
    set {_betterProfile = newValue}
  }
  /// Returns true if `betterProfile` has been explicitly set.
  public var hasBetterProfile: Bool {return self._betterProfile != nil}
  /// Clears the value of `betterProfile`. Subsequent reads from it will return its default value.
  public mutating func clearBetterProfile() {self._betterProfile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _verifiedMetadata: Flipcash_Pool_V1_SignedBetMetadata? = nil
  fileprivate var _rendezvousSignature: Flipcash_Common_V1_Signature? = nil
  fileprivate var _betterProfile: Flipcash_Profile_V1_UserProfile? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipcash_Pool_V1_UserOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_PoolId: @unchecked Sendable {}
extension Flipcash_Pool_V1_Resolution: @unchecked Sendable {}
extension Flipcash_Pool_V1_Resolution.OneOf_Kind: @unchecked Sendable {}
extension Flipcash_Pool_V1_Resolution.Refund: @unchecked Sendable {}
extension Flipcash_Pool_V1_SignedPoolMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_PoolMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetId: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetOutcome.OneOf_Kind: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetSummary: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetSummary.OneOf_Kind: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetSummary.BooleanBetSummary: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary.OneOf_Outcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary.NoOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary.WinOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary.LoseOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_UserPoolSummary.RefundOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_SignedBetMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipcash.pool.v1"

extension Flipcash_Pool_V1_UserOutcome: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OUTCOE"),
    1: .same(proto: "NO_OUTCOME"),
    2: .same(proto: "WIN_OUTCOME"),
    3: .same(proto: "LOSE_OUTCOME"),
    4: .same(proto: "REFUND_OUTCOME"),
  ]
}

extension Flipcash_Pool_V1_PoolId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoolId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_PoolId, rhs: Flipcash_Pool_V1_PoolId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_Resolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resolution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boolean_resolution"),
    2: .standard(proto: "refund_resolution"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .booleanResolution(v)
        }
      }()
      case 2: try {
        var v: Flipcash_Pool_V1_Resolution.Refund?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .refundResolution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .refundResolution(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .booleanResolution?: try {
      guard case .booleanResolution(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .refundResolution?: try {
      guard case .refundResolution(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_Resolution, rhs: Flipcash_Pool_V1_Resolution) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_Resolution.Refund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_Resolution.protoMessageName + ".Refund"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_Resolution.Refund, rhs: Flipcash_Pool_V1_Resolution.Refund) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_SignedPoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedPoolMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .same(proto: "name"),
    4: .standard(proto: "buy_in"),
    5: .standard(proto: "funding_destination"),
    6: .standard(proto: "is_open"),
    7: .same(proto: "resolution"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "closed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._buyIn) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._fundingDestination) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isOpen) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._resolution) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._closedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._buyIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fundingDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isOpen != false {
      try visitor.visitSingularBoolField(value: self.isOpen, fieldNumber: 6)
    }
    try { if let v = self._resolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._closedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_SignedPoolMetadata, rhs: Flipcash_Pool_V1_SignedPoolMetadata) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs.name != rhs.name {return false}
    if lhs._buyIn != rhs._buyIn {return false}
    if lhs._fundingDestination != rhs._fundingDestination {return false}
    if lhs.isOpen != rhs.isOpen {return false}
    if lhs._resolution != rhs._resolution {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._closedAt != rhs._closedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_PoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoolMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verified_metadata"),
    2: .standard(proto: "rendezvous_signature"),
    3: .same(proto: "bets"),
    7: .standard(proto: "bet_summary"),
    8: .standard(proto: "user_summary"),
    4: .standard(proto: "paging_token"),
    5: .standard(proto: "is_funding_destination_initialized"),
    6: .standard(proto: "derivation_index"),
    9: .standard(proto: "creator_profile"),
  ]

  fileprivate class _StorageClass {
    var _verifiedMetadata: Flipcash_Pool_V1_SignedPoolMetadata? = nil
    var _rendezvousSignature: Flipcash_Common_V1_Signature? = nil
    var _bets: [Flipcash_Pool_V1_BetMetadata] = []
    var _betSummary: Flipcash_Pool_V1_BetSummary? = nil
    var _userSummary: Flipcash_Pool_V1_UserPoolSummary? = nil
    var _pagingToken: Flipcash_Common_V1_PagingToken? = nil
    var _isFundingDestinationInitialized: Bool = false
    var _derivationIndex: UInt64 = 0
    var _creatorProfile: Flipcash_Profile_V1_UserProfile? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _verifiedMetadata = source._verifiedMetadata
      _rendezvousSignature = source._rendezvousSignature
      _bets = source._bets
      _betSummary = source._betSummary
      _userSummary = source._userSummary
      _pagingToken = source._pagingToken
      _isFundingDestinationInitialized = source._isFundingDestinationInitialized
      _derivationIndex = source._derivationIndex
      _creatorProfile = source._creatorProfile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._verifiedMetadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rendezvousSignature) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._bets) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._pagingToken) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isFundingDestinationInitialized) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._derivationIndex) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._betSummary) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._userSummary) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._creatorProfile) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._verifiedMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rendezvousSignature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._bets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bets, fieldNumber: 3)
      }
      try { if let v = _storage._pagingToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isFundingDestinationInitialized != false {
        try visitor.visitSingularBoolField(value: _storage._isFundingDestinationInitialized, fieldNumber: 5)
      }
      if _storage._derivationIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._derivationIndex, fieldNumber: 6)
      }
      try { if let v = _storage._betSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._userSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._creatorProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_PoolMetadata, rhs: Flipcash_Pool_V1_PoolMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._verifiedMetadata != rhs_storage._verifiedMetadata {return false}
        if _storage._rendezvousSignature != rhs_storage._rendezvousSignature {return false}
        if _storage._bets != rhs_storage._bets {return false}
        if _storage._betSummary != rhs_storage._betSummary {return false}
        if _storage._userSummary != rhs_storage._userSummary {return false}
        if _storage._pagingToken != rhs_storage._pagingToken {return false}
        if _storage._isFundingDestinationInitialized != rhs_storage._isFundingDestinationInitialized {return false}
        if _storage._derivationIndex != rhs_storage._derivationIndex {return false}
        if _storage._creatorProfile != rhs_storage._creatorProfile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetId, rhs: Flipcash_Pool_V1_BetId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boolean_outcome"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .booleanOutcome(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .booleanOutcome(let v)? = self.kind {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetOutcome, rhs: Flipcash_Pool_V1_BetOutcome) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boolean_summary"),
    10: .standard(proto: "total_amount_bet"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Pool_V1_BetSummary.BooleanBetSummary?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .booleanSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .booleanSummary(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._totalAmountBet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .booleanSummary(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalAmountBet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetSummary, rhs: Flipcash_Pool_V1_BetSummary) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._totalAmountBet != rhs._totalAmountBet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetSummary.BooleanBetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_BetSummary.protoMessageName + ".BooleanBetSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_yes"),
    2: .standard(proto: "num_no"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numYes) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numNo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numYes != 0 {
      try visitor.visitSingularUInt32Field(value: self.numYes, fieldNumber: 1)
    }
    if self.numNo != 0 {
      try visitor.visitSingularUInt32Field(value: self.numNo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetSummary.BooleanBetSummary, rhs: Flipcash_Pool_V1_BetSummary.BooleanBetSummary) -> Bool {
    if lhs.numYes != rhs.numYes {return false}
    if lhs.numNo != rhs.numNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_UserPoolSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPoolSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
    2: .same(proto: "win"),
    3: .same(proto: "lose"),
    4: .same(proto: "refund"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flipcash_Pool_V1_UserPoolSummary.NoOutcome?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .none(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .none(v)
        }
      }()
      case 2: try {
        var v: Flipcash_Pool_V1_UserPoolSummary.WinOutcome?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .win(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .win(v)
        }
      }()
      case 3: try {
        var v: Flipcash_Pool_V1_UserPoolSummary.LoseOutcome?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .lose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .lose(v)
        }
      }()
      case 4: try {
        var v: Flipcash_Pool_V1_UserPoolSummary.RefundOutcome?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .refund(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .refund(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.outcome {
    case .none?: try {
      guard case .none(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .win?: try {
      guard case .win(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .lose?: try {
      guard case .lose(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .refund?: try {
      guard case .refund(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary, rhs: Flipcash_Pool_V1_UserPoolSummary) -> Bool {
    if lhs.outcome != rhs.outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_UserPoolSummary.NoOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_UserPoolSummary.protoMessageName + ".NoOutcome"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary.NoOutcome, rhs: Flipcash_Pool_V1_UserPoolSummary.NoOutcome) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_UserPoolSummary.WinOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_UserPoolSummary.protoMessageName + ".WinOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_won"),
    2: .standard(proto: "total_amount_received"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amountWon) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalAmountReceived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amountWon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalAmountReceived {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary.WinOutcome, rhs: Flipcash_Pool_V1_UserPoolSummary.WinOutcome) -> Bool {
    if lhs._amountWon != rhs._amountWon {return false}
    if lhs._totalAmountReceived != rhs._totalAmountReceived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_UserPoolSummary.LoseOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_UserPoolSummary.protoMessageName + ".LoseOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_lost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amountLost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amountLost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary.LoseOutcome, rhs: Flipcash_Pool_V1_UserPoolSummary.LoseOutcome) -> Bool {
    if lhs._amountLost != rhs._amountLost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_UserPoolSummary.RefundOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Flipcash_Pool_V1_UserPoolSummary.protoMessageName + ".RefundOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_refunded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amountRefunded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amountRefunded {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_UserPoolSummary.RefundOutcome, rhs: Flipcash_Pool_V1_UserPoolSummary.RefundOutcome) -> Bool {
    if lhs._amountRefunded != rhs._amountRefunded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_SignedBetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedBetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bet_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "selected_outcome"),
    4: .standard(proto: "payout_destination"),
    5: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._betID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedOutcome) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payoutDestination) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._betID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._selectedOutcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payoutDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_SignedBetMetadata, rhs: Flipcash_Pool_V1_SignedBetMetadata) -> Bool {
    if lhs._betID != rhs._betID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._selectedOutcome != rhs._selectedOutcome {return false}
    if lhs._payoutDestination != rhs._payoutDestination {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verified_metadata"),
    2: .standard(proto: "rendezvous_signature"),
    3: .standard(proto: "is_intent_submitted"),
    4: .standard(proto: "better_profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._verifiedMetadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rendezvousSignature) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isIntentSubmitted) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._betterProfile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._verifiedMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rendezvousSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isIntentSubmitted != false {
      try visitor.visitSingularBoolField(value: self.isIntentSubmitted, fieldNumber: 3)
    }
    try { if let v = self._betterProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetMetadata, rhs: Flipcash_Pool_V1_BetMetadata) -> Bool {
    if lhs._verifiedMetadata != rhs._verifiedMetadata {return false}
    if lhs._rendezvousSignature != rhs._rendezvousSignature {return false}
    if lhs.isIntentSubmitted != rhs.isIntentSubmitted {return false}
    if lhs._betterProfile != rhs._betterProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
