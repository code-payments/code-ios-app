// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pool/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PoolId uniquely identifies a pool via a rendezvous public key
public struct Flipcash_Pool_V1_PoolId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Resolution is a resolution to a pool that declares the winning outcome chosen
/// by the pool creator
public struct Flipcash_Pool_V1_Resolution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Flipcash_Pool_V1_Resolution.OneOf_Kind? = nil

  /// The yes/no outcome the creator has chosen as the winning outcome
  public var booleanResolution: Bool {
    get {
      if case .booleanResolution(let v)? = kind {return v}
      return false
    }
    set {kind = .booleanResolution(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The yes/no outcome the creator has chosen as the winning outcome
    case booleanResolution(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_Resolution.OneOf_Kind, rhs: Flipcash_Pool_V1_Resolution.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.booleanResolution, .booleanResolution): return {
        guard case .booleanResolution(let l) = lhs, case .booleanResolution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Pool metadata signed by the rendezvous key
public struct Flipcash_Pool_V1_SignedPoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Flipcash_Pool_V1_PoolId {
    get {return _id ?? Flipcash_Pool_V1_PoolId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The user ID that created this pool
  public var creator: Flipcash_Common_V1_UserId {
    get {return _creator ?? Flipcash_Common_V1_UserId()}
    set {_creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return self._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {self._creator = nil}

  /// The pool name, which should ask a yes/no question to bet against
  public var name: String = String()

  /// The buy in amount for a bet
  public var buyIn: Flipcash_Common_V1_FiatPaymentAmount {
    get {return _buyIn ?? Flipcash_Common_V1_FiatPaymentAmount()}
    set {_buyIn = newValue}
  }
  /// Returns true if `buyIn` has been explicitly set.
  public var hasBuyIn: Bool {return self._buyIn != nil}
  /// Clears the value of `buyIn`. Subsequent reads from it will return its default value.
  public mutating func clearBuyIn() {self._buyIn = nil}

  /// Destination where bet payments will be made to fund the pool
  public var fundingDestination: Flipcash_Common_V1_PublicKey {
    get {return _fundingDestination ?? Flipcash_Common_V1_PublicKey()}
    set {_fundingDestination = newValue}
  }
  /// Returns true if `fundingDestination` has been explicitly set.
  public var hasFundingDestination: Bool {return self._fundingDestination != nil}
  /// Clears the value of `fundingDestination`. Subsequent reads from it will return its default value.
  public mutating func clearFundingDestination() {self._fundingDestination = nil}

  /// Is the pool currently open to take bets?
  public var isOpen: Bool = false

  /// The pool resolution, if one is made
  public var resolution: Flipcash_Pool_V1_Resolution {
    get {return _resolution ?? Flipcash_Pool_V1_Resolution()}
    set {_resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  public var hasResolution: Bool {return self._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  public mutating func clearResolution() {self._resolution = nil}

  /// Timestamp pool was created at
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Flipcash_Pool_V1_PoolId? = nil
  fileprivate var _creator: Flipcash_Common_V1_UserId? = nil
  fileprivate var _buyIn: Flipcash_Common_V1_FiatPaymentAmount? = nil
  fileprivate var _fundingDestination: Flipcash_Common_V1_PublicKey? = nil
  fileprivate var _resolution: Flipcash_Pool_V1_Resolution? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Pool metadata
public struct Flipcash_Pool_V1_PoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verifiedMetadata: Flipcash_Pool_V1_SignedPoolMetadata {
    get {return _verifiedMetadata ?? Flipcash_Pool_V1_SignedPoolMetadata()}
    set {_verifiedMetadata = newValue}
  }
  /// Returns true if `verifiedMetadata` has been explicitly set.
  public var hasVerifiedMetadata: Bool {return self._verifiedMetadata != nil}
  /// Clears the value of `verifiedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVerifiedMetadata() {self._verifiedMetadata = nil}

  /// Signature of the SignedPoolMetadata message with the rendezvous public key of the pool
  public var rendezvousSignature: Flipcash_Common_V1_Signature {
    get {return _rendezvousSignature ?? Flipcash_Common_V1_Signature()}
    set {_rendezvousSignature = newValue}
  }
  /// Returns true if `rendezvousSignature` has been explicitly set.
  public var hasRendezvousSignature: Bool {return self._rendezvousSignature != nil}
  /// Clears the value of `rendezvousSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRendezvousSignature() {self._rendezvousSignature = nil}

  /// The set of bets (with verified payment) made against this pool
  public var bets: [Flipcash_Pool_V1_BetMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _verifiedMetadata: Flipcash_Pool_V1_SignedPoolMetadata? = nil
  fileprivate var _rendezvousSignature: Flipcash_Common_V1_Signature? = nil
}

/// BetId uniquely identifies a bet via an intent ID
public struct Flipcash_Pool_V1_BetId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BetOutcome is the user's outcome that they bet against
public struct Flipcash_Pool_V1_BetOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Flipcash_Pool_V1_BetOutcome.OneOf_Kind? = nil

  /// The yes/no outcome the user has bet against
  public var booleanOutcome: Bool {
    get {
      if case .booleanOutcome(let v)? = kind {return v}
      return false
    }
    set {kind = .booleanOutcome(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The yes/no outcome the user has bet against
    case booleanOutcome(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Flipcash_Pool_V1_BetOutcome.OneOf_Kind, rhs: Flipcash_Pool_V1_BetOutcome.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.booleanOutcome, .booleanOutcome): return {
        guard case .booleanOutcome(let l) = lhs, case .booleanOutcome(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Bet metadata signed by the rendezvous key
public struct Flipcash_Pool_V1_SignedBetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var betID: Flipcash_Pool_V1_BetId {
    get {return _betID ?? Flipcash_Pool_V1_BetId()}
    set {_betID = newValue}
  }
  /// Returns true if `betID` has been explicitly set.
  public var hasBetID: Bool {return self._betID != nil}
  /// Clears the value of `betID`. Subsequent reads from it will return its default value.
  public mutating func clearBetID() {self._betID = nil}

  /// The user making the bet, which is unique for a given pool
  public var userID: Flipcash_Common_V1_UserId {
    get {return _userID ?? Flipcash_Common_V1_UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  /// The outcome the user has bet against
  public var selectedOutcome: Flipcash_Pool_V1_BetOutcome {
    get {return _selectedOutcome ?? Flipcash_Pool_V1_BetOutcome()}
    set {_selectedOutcome = newValue}
  }
  /// Returns true if `selectedOutcome` has been explicitly set.
  public var hasSelectedOutcome: Bool {return self._selectedOutcome != nil}
  /// Clears the value of `selectedOutcome`. Subsequent reads from it will return its default value.
  public mutating func clearSelectedOutcome() {self._selectedOutcome = nil}

  /// The destination where payout will be made if the user selected the correct
  /// outcome.
  public var payoutDestination: Flipcash_Common_V1_PublicKey {
    get {return _payoutDestination ?? Flipcash_Common_V1_PublicKey()}
    set {_payoutDestination = newValue}
  }
  /// Returns true if `payoutDestination` has been explicitly set.
  public var hasPayoutDestination: Bool {return self._payoutDestination != nil}
  /// Clears the value of `payoutDestination`. Subsequent reads from it will return its default value.
  public mutating func clearPayoutDestination() {self._payoutDestination = nil}

  /// Timestamp the bet was made
  public var ts: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ts ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return self._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {self._ts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _betID: Flipcash_Pool_V1_BetId? = nil
  fileprivate var _userID: Flipcash_Common_V1_UserId? = nil
  fileprivate var _selectedOutcome: Flipcash_Pool_V1_BetOutcome? = nil
  fileprivate var _payoutDestination: Flipcash_Common_V1_PublicKey? = nil
  fileprivate var _ts: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Bet metadata
public struct Flipcash_Pool_V1_BetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verifiedMetadata: Flipcash_Pool_V1_SignedBetMetadata {
    get {return _verifiedMetadata ?? Flipcash_Pool_V1_SignedBetMetadata()}
    set {_verifiedMetadata = newValue}
  }
  /// Returns true if `verifiedMetadata` has been explicitly set.
  public var hasVerifiedMetadata: Bool {return self._verifiedMetadata != nil}
  /// Clears the value of `verifiedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearVerifiedMetadata() {self._verifiedMetadata = nil}

  /// Signature of the SignedBetMetadata message with the rendezvous public key of the pool
  public var rendezvousSignature: Flipcash_Common_V1_Signature {
    get {return _rendezvousSignature ?? Flipcash_Common_V1_Signature()}
    set {_rendezvousSignature = newValue}
  }
  /// Returns true if `rendezvousSignature` has been explicitly set.
  public var hasRendezvousSignature: Bool {return self._rendezvousSignature != nil}
  /// Clears the value of `rendezvousSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRendezvousSignature() {self._rendezvousSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _verifiedMetadata: Flipcash_Pool_V1_SignedBetMetadata? = nil
  fileprivate var _rendezvousSignature: Flipcash_Common_V1_Signature? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Flipcash_Pool_V1_PoolId: @unchecked Sendable {}
extension Flipcash_Pool_V1_Resolution: @unchecked Sendable {}
extension Flipcash_Pool_V1_Resolution.OneOf_Kind: @unchecked Sendable {}
extension Flipcash_Pool_V1_SignedPoolMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_PoolMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetId: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetOutcome: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetOutcome.OneOf_Kind: @unchecked Sendable {}
extension Flipcash_Pool_V1_SignedBetMetadata: @unchecked Sendable {}
extension Flipcash_Pool_V1_BetMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flipcash.pool.v1"

extension Flipcash_Pool_V1_PoolId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoolId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_PoolId, rhs: Flipcash_Pool_V1_PoolId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_Resolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resolution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boolean_resolution"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .booleanResolution(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .booleanResolution(let v)? = self.kind {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_Resolution, rhs: Flipcash_Pool_V1_Resolution) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_SignedPoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedPoolMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .same(proto: "name"),
    4: .standard(proto: "buy_in"),
    5: .standard(proto: "funding_destination"),
    6: .standard(proto: "is_open"),
    7: .same(proto: "resolution"),
    8: .standard(proto: "created_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._buyIn) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._fundingDestination) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isOpen) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._resolution) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._buyIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fundingDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isOpen != false {
      try visitor.visitSingularBoolField(value: self.isOpen, fieldNumber: 6)
    }
    try { if let v = self._resolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_SignedPoolMetadata, rhs: Flipcash_Pool_V1_SignedPoolMetadata) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs.name != rhs.name {return false}
    if lhs._buyIn != rhs._buyIn {return false}
    if lhs._fundingDestination != rhs._fundingDestination {return false}
    if lhs.isOpen != rhs.isOpen {return false}
    if lhs._resolution != rhs._resolution {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_PoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoolMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verified_metadata"),
    2: .standard(proto: "rendezvous_signature"),
    3: .same(proto: "bets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._verifiedMetadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rendezvousSignature) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._verifiedMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rendezvousSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.bets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_PoolMetadata, rhs: Flipcash_Pool_V1_PoolMetadata) -> Bool {
    if lhs._verifiedMetadata != rhs._verifiedMetadata {return false}
    if lhs._rendezvousSignature != rhs._rendezvousSignature {return false}
    if lhs.bets != rhs.bets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetId, rhs: Flipcash_Pool_V1_BetId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boolean_outcome"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .booleanOutcome(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .booleanOutcome(let v)? = self.kind {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetOutcome, rhs: Flipcash_Pool_V1_BetOutcome) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_SignedBetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedBetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bet_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "selected_outcome"),
    4: .standard(proto: "payout_destination"),
    5: .same(proto: "ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._betID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedOutcome) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payoutDestination) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._betID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._selectedOutcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payoutDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_SignedBetMetadata, rhs: Flipcash_Pool_V1_SignedBetMetadata) -> Bool {
    if lhs._betID != rhs._betID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs._selectedOutcome != rhs._selectedOutcome {return false}
    if lhs._payoutDestination != rhs._payoutDestination {return false}
    if lhs._ts != rhs._ts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flipcash_Pool_V1_BetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verified_metadata"),
    2: .standard(proto: "rendezvous_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._verifiedMetadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rendezvousSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._verifiedMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rendezvousSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Flipcash_Pool_V1_BetMetadata, rhs: Flipcash_Pool_V1_BetMetadata) -> Bool {
    if lhs._verifiedMetadata != rhs._verifiedMetadata {return false}
    if lhs._rendezvousSignature != rhs._rendezvousSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
